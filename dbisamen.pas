{************************************************************************
*
*      Main DBISAM engine functionality and objects source
*
*      Copyright 1996-2005  Elevate Software
*      All rights reserved.
*
*************************************************************************}

{$I dbisamcp.inc}

unit dbisamen;

interface

uses SysUtils, Classes,

{$I dbisamvr.inc}

Windows, Messages, WinSock,
ScktComp,

dbisamcn, dbisamlb, dbisamcr;


type

   TDataLocale = class;
   TDataEngine = class;
   TBaseFile = class;
   TMemoryFile = class;
   TPhysicalFile = class;
   TEngineFile = class;
   TBufferedFile = class;
   TDataSession = class;
   TDataDirectoryLocks = class;
   TDataDirectory = class;
   TDataFile = class;
   TIndexFile = class;
   TBlobFile = class;
   TDataTable = class;
   TDataCursor = class;
   TFilter = class;
   TBlobBuffer = class;

   TDataLocale = class(TObject)
      private
         FDataEngine: TDataEngine;
         FID: Integer;
         FName: string;
         FShortName: string;
         FCharMap: TLocaleCharMap;
         FCharMapBuilt: Boolean;
      public
         constructor Create(Owner: TDataEngine);
         property ID: Integer read FID write FID;
         property Name: string read FName write FName;
         property ShortName: string read FShortName write FShortName;
         function GetCharMap: TLocaleCharMap;
      end;

   TBaseFile = class(TObject)
      private
         FDataEngine: TDataEngine;
         FFileSection: Pointer;
         FExclusive: Boolean;
         FReadOnly: Boolean;
         FMarkedReadOnly: Boolean;
         FTemporary: Boolean;
         FHidden: Boolean;
         FFileName: string;
         FFileSize: Int64;
         FLocksList: TList;
         FUseCount: Word;
         FHandlesList: TList;
         FLastHandle: Integer;
         procedure FreeLocks;
         procedure FreeHandles;
         function FindLock(Value: Int64; var IndexPos: Integer): Boolean;
         function GetHandlePos(FileHandle: Integer): Integer;
      protected
         function GetFileSize: Int64; virtual;
      public
         constructor Create(Owner: TDataEngine); virtual;
         destructor Destroy; override;
         property Exclusive: Boolean read FExclusive write FExclusive;
         property ReadOnly: Boolean read FReadOnly write FReadOnly;
         property MarkedReadOnly: Boolean read FMarkedReadOnly;
         property Temporary: Boolean read FTemporary write FTemporary;
         property Hidden: Boolean read FHidden write FHidden;
         property FileName: string read FFileName write FFileName;
         property FileSize: Int64 read GetFileSize;
         property UseCount: Word read FUseCount;
         function CreateNew: Integer; virtual;
         function Open: Integer; virtual;
         procedure Close(FileHandle: Integer); virtual;
         function Rename(const NewName: string): Integer; virtual;
         function Delete: Integer; virtual;
         function Read(FileHandle: Integer; var Buffer;
                       NumBytes: Integer): Integer; virtual;
         function Write(FileHandle: Integer; const Buffer;
                        NumBytes: Integer): Integer; virtual;
         function Flush(FileHandle: Integer): Boolean; virtual;
         function Seek(FileHandle: Integer; Position: Int64;
                       From: Word): Int64; virtual;
         function Lock(Offset: Int64; LockLength: Int64): Boolean; virtual;
         function Unlock(Offset: Int64; LockLength: Int64): Boolean; virtual;
         procedure LockFileSection;
         procedure UnlockFileSection;
      end;

   TMemoryFile = class(TBaseFile)
      private
         FFileBuffers: TList;
         FFileBufferSize: Integer;
      public
         constructor Create(Owner: TDataEngine); override;
         destructor Destroy; override;
         property FileBufferSize: Integer read FFileBufferSize;
         procedure ResizeFileBuffer(NewSize: Integer);
         function CreateNew: Integer; override;
         function Read(FileHandle: Integer; var Buffer;
                       NumBytes: Integer): Integer; override;
         function Write(FileHandle: Integer; const Buffer;
                        NumBytes: Integer): Integer; override;
      end;

   TPhysicalFile = class(TBaseFile)
      private
         FPhysicalHandle: Integer;
      protected
         function GetFileSize: Int64; override;
      public
         constructor Create(Owner: TDataEngine); override;
         destructor Destroy; override;
         function CreateNew: Integer; override;
         function Open: Integer; override;
         procedure Close(FileHandle: Integer); override;
         function Rename(const NewName: string): Integer; override;
         function Delete: Integer; override;
         function Read(FileHandle: Integer; var Buffer;
                       NumBytes: Integer): Integer; override;
         function Write(FileHandle: Integer; const Buffer;
                        NumBytes: Integer): Integer; override;
         function Flush(FileHandle: Integer): Boolean; override;
         function Seek(FileHandle: Integer; Position: Int64;
                       From: Word): Int64; override;
         function Lock(Offset: Int64; LockLength: Int64): Boolean; override;
         function Unlock(Offset: Int64; LockLength: Int64): Boolean; override;
      end;

   TDataEngine = class(TObject)
      private
         FInitialized: Boolean;
         FIsServer: Boolean;
         FLocaleSection: Pointer;
         FIsWindows95: Boolean;
         FServer: TObject;
         FErrorSection: Pointer;
         FOSErrorNumber: Integer;
         FSocketErrorNumber: Integer;
         FLastErrorNumber: Word;
         FLastOSErrorNumber: Integer;
         FLastSocketErrorNumber: Integer;
         FLastErrorRemoteName: string;
         FLastErrorUserName: string;
         FLastErrorDatabaseName: string;
         FLastErrorTableName: string;
         FLastErrorFieldName: string;
         FLastErrorIndexName: string;
         FLastErrorMessage: string;
         FLastErrorProcedureName: string;
         FLastErrorEventName: string;
         FLastErrorLine: Integer;
         FLastErrorColumn: Integer;
         FLocaleList: TList;
         FLargeFileSupport: Boolean;
         FMaximumFileSize: Int64;
         FMaximumNumRecords: Integer;
         FLockFileName: string;
         FFileLockByte: Int64;
         FRecordLockByte: Int64;
         FFileLockRange: Int64;
         FTransLockRange: Int64;
         FReadLockRange: Int64;
         FWriteLockRange: Int64;
         FTransWriteLockRange: Int64;
         FRecordLockRange: Int64;
         FTransLockByte: Int64;
         FReadLockByte: Int64;
         FWriteLockByte: Int64;
         FTransWriteLockByte: Int64;
         FSemaphoreLockByte: Int64;
         FSemaphoreLockRange: Int64;
         FPhysicalFileList: TList;
         FPhysicalFileListSection: Pointer;
         FMemoryFileList: TList;
         FMemoryFileListSection: Pointer;
         FSignature: string;
         FSignatureDigest: TMD5Digest;
         FDataExtension: string;
         FIndexExtension: string;
         FBlobExtension: string;
         FDataBackupExtension: string;
         FIndexBackupExtension: string;
         FBlobBackupExtension: string;
         FDataUpgradeExtension: string;
         FIndexUpgradeExtension: string;
         FBlobUpgradeExtension: string;
         FDataTempExtension: string;
         FIndexTempExtension: string;
         FBlobTempExtension: string;
         FTempTablesInDataDirectory: Boolean;
         FMaxDataBufferSize: Integer;
         FMaxDataBufferCount: Integer;
         FMaxIndexBufferSize: Integer;
         FMaxIndexBufferCount: Integer;
         FMaxBlobBufferSize: Integer;
         FMaxBlobBufferCount: Integer;
         FFilterIndexThreshhold: Byte;
         FReadLockWaitTime: Word;
         FReadLockRetries: Word;
         FWriteLockWaitTime: Word;
         FWriteLockRetries: Word;
         FTransLockWaitTime: Word;
         FTransLockRetries: Word;
         { Version 5 }
         FMaxReadLockCount: Word;
         { Version 5 }
         FFunctionCount: Word;
         FFunctionDefinitions: array [1..MAX_NUM_FUNCS] of pFunctionDefinition;
         FCryptoInitClientData: Integer;
         FCryptoInitCallback: pCryptoInitCallback;
         FEncryptBlockClientData: Integer;
         FEncryptBlockCallback: pEncryptBlockCallback;
         FDecryptBlockClientData: Integer;
         FDecryptBlockCallback: pDecryptBlockCallback;
         FCryptoResetClientData: Integer;
         FCryptoResetCallback: pCryptoResetCallback;
         FCompressClientData: Integer;
         FCompressCallback: pCompressCallback;
         FDecompressClientData: Integer;
         FDecompressCallback: pDecompressCallback;
         FTextIndexFilterClientData: Integer;
         FTextIndexFilterCallback: pTextIndexFilterCallback;
         FTextIndexTokenFilterClientData: Integer;
         FTextIndexTokenFilterCallback: pTextIndexTokenFilterCallback;
         FFunctionClientData: Integer;
         FFunctionCallback: pFunctionCallback;
         FGetFunctionsClientData: Integer;
         FGetFunctionsCallback: pGetFunctionsCallback;
         FTriggerClientData: Integer;
         FTriggerCallback: pTriggerCallback;
         FErrorClientData: Integer;
         FErrorCallback: pErrorCallback;
         FServerStartClientData: Integer;
         FServerStartCallback: pServerNotifyCallback;
         FServerStopClientData: Integer;
         FServerStopCallback: pServerNotifyCallback;
         FServerLogEventClientData: Integer;
         FServerLogEventCallback: pServerLogEventCallback;
         FServerLogCountClientData: Integer;
         FServerLogCountCallback: pServerLogCountCallback;
         FServerLogRecordClientData: Integer;
         FServerLogRecordCallback: pServerLogRecordCallback;
         FServerConnectClientData: Integer;
         FServerConnectCallback: pServerConnectCallback;
         FServerReconnectClientData: Integer;
         FServerReconnectCallback: pServerReconnectCallback;
         FServerLoginClientData: Integer;
         FServerLoginCallback: pServerLoginCallback;
         FServerLogoutClientData: Integer;
         FServerLogoutCallback: pServerLogoutCallback;
         FServerDisconnectClientData: Integer;
         FServerDisconnectCallback: pServerDisconnectCallback;
         FServerScheduledEventClientData: Integer;
         FServerScheduledEventCallback: pServerScheduledEventCallback;
         FServerProcedureClientData: Integer;
         FServerProcedureCallback: pServerProcedureCallback;
         FDataSessionList: TList;
         FDataSessionSection: Pointer;
         procedure SetSignature(const Value: string);
         procedure FreeDataSessions;
         procedure LockDataSessionList;
         procedure UnlockDataSessionList;
         procedure FreeLocales;
         procedure FreePhysicalFiles;
         procedure FreeMemoryFiles;
         procedure LockPhysicalFileList;
         procedure UnlockPhysicalFileList;
         procedure LockMemoryFileList;
         procedure UnlockMemoryFileList;
         procedure LockErrorInformation;
         procedure UnlockErrorInformation;
         procedure ClearErrorContexts;
         procedure AssignErrorContexts(ErrorCode: Word;
                                       OSErrorCode: Integer;
                                       SocketErrorCode: Integer;
                                       const ErrorRemoteName: string;
                                       const ErrorUserName: string;
                                       const ErrorDatabaseName: string;
                                       const ErrorTableName: string;
                                       const ErrorFieldName: string;
                                       const ErrorIndexName: string;
                                       const ErrorMessage: string;
                                       const ErrorProcedureName: string;
                                       const ErrorEventName: string;
                                       ErrorLine: Integer; ErrorColumn: Integer);
         procedure GetFunctions;
         procedure FreeFunctions;
      public
         constructor Create;
         destructor Destroy; override;
         property Initialized: Boolean read FInitialized;
         property IsServer: Boolean read FIsServer write FIsServer;
         property IsWindows95: Boolean read FIsWindows95 write FIsWindows95;
         property Signature: string read FSignature write SetSignature;
         property SignatureDigest: TMD5Digest read FSignatureDigest;
         property LastErrorNumber: Word read FLastErrorNumber;
         property LastOSErrorNumber: Integer read FLastOSErrorNumber;
         property LastSocketErrorNumber: Integer read FLastSocketErrorNumber;
         property LastErrorRemoteName: string read FLastErrorRemoteName;
         property LastErrorUserName: string read FLastErrorUserName;
         property LastErrorDatabaseName: string read FLastErrorDatabaseName;
         property LastErrorTableName: string read FLastErrorTableName;
         property LastErrorFieldName: string read FLastErrorFieldName;
         property LastErrorIndexName: string read FLastErrorIndexName;
         property LastErrorMessage: string read FLastErrorMessage;
         property LastErrorProcedureName: string read FLastErrorProcedureName;
         property LastErrorEventName: string read FLastErrorEventName;
         property LastErrorLine: Integer read FLastErrorLine;
         property LastErrorColumn: Integer read FLastErrorColumn;
         property LargeFileSupport: Boolean read FLargeFileSupport
                                            write FLargeFileSupport;
         property MaximumFileSize: Int64 read FMaximumFileSize;
         property MaximumNumRecords: Integer read FMaximumNumRecords;
         property LockFileName: string read FLockFileName;
         property FileLockByte: Int64 read FFileLockByte;
         property RecordLockByte: Int64 read FRecordLockByte;
         property FileLockRange: Int64 read FFileLockRange;
         property TransLockRange: Int64 read FTransLockRange;
         property ReadLockRange: Int64 read FReadLockRange;
         property WriteLockRange: Int64 read FWriteLockRange;
         property TransWriteLockRange: Int64 read FTransWriteLockRange;
         property RecordLockRange: Int64 read FRecordLockRange;
         property TransLockByte: Int64 read FTransLockByte;
         property ReadLockByte: Int64 read FReadLockByte;
         property WriteLockByte: Int64 read FWriteLockByte;
         property TransWriteLockByte: Int64 read FTransWriteLockByte;
         property SemaphoreLockByte: Int64 read FSemaphoreLockByte;
         property SemaphoreLockRange: Int64 read FSemaphoreLockRange;
         { Version 5 }
         property MaxReadLockCount: Word read FMaxReadLockCount write FMaxReadLockCount;
         { Version 5 }
         property DataExtension: string read FDataExtension write FDataExtension;
         property IndexExtension: string read FIndexExtension write FIndexExtension;
         property BlobExtension: string read FBlobExtension write FBlobExtension;
         property DataBackupExtension: string read FDataBackupExtension
                                              write FDataBackupExtension;
         property IndexBackupExtension: string read FIndexBackupExtension
                                               write FIndexBackupExtension;
         property BlobBackupExtension: string read FBlobBackupExtension
                                              write FBlobBackupExtension;
         property DataUpgradeExtension: string read FDataUpgradeExtension
                                              write FDataUpgradeExtension;
         property IndexUpgradeExtension: string read FIndexUpgradeExtension
                                               write FIndexUpgradeExtension;
         property BlobUpgradeExtension: string read FBlobUpgradeExtension
                                              write FBlobUpgradeExtension;
         property DataTempExtension: string read FDataTempExtension
                                              write FDataTempExtension;
         property IndexTempExtension: string read FIndexTempExtension
                                               write FIndexTempExtension;
         property BlobTempExtension: string read FBlobTempExtension
                                              write FBlobTempExtension;
         property TempTablesInDataDirectory: Boolean read FTempTablesInDataDirectory
                                                    write FTempTablesInDataDirectory;
         property MaxDataBufferSize: Integer read FMaxDataBufferSize
                                               write FMaxDataBufferSize;
         property MaxDataBufferCount: Integer read FMaxDataBufferCount
                                                write FMaxDataBufferCount;
         property MaxIndexBufferSize: Integer read FMaxIndexBufferSize
                                               write FMaxIndexBufferSize;
         property MaxIndexBufferCount: Integer read FMaxIndexBufferCount
                                               write FMaxIndexBufferCount;
         property MaxBlobBufferSize: Integer read FMaxBlobBufferSize
                                              write FMaxBlobBufferSize;
         property MaxBlobBufferCount: Integer read FMaxBlobBufferCount
                                               write FMaxBlobBufferCount;
         property FilterIndexThreshhold: Byte read FFilterIndexThreshhold
                                                 write FFilterIndexThreshhold;
         property ReadLockWaitTime: Word read FReadLockWaitTime
                                         write FReadLockWaitTime;
         property ReadLockRetries: Word read FReadLockRetries
                                        write FReadLockRetries;
         property WriteLockWaitTime: Word read FWriteLockWaitTime
                                         write FWriteLockWaitTime;
         property WriteLockRetries: Word read FWriteLockRetries
                                        write FWriteLockRetries;
         property TransLockWaitTime: Word read FTransLockWaitTime
                                          write FTransLockWaitTime;
         property TransLockRetries: Word read FTransLockRetries
                                        write FTransLockRetries;
         property FunctionCount: Word read FFunctionCount;
         property LocaleList: TList read FLocaleList;
         procedure PopulateLocales;
         procedure Initialize(const LockFile: string;
                              const ServerName: string;
                              const ServerDescription: string;
                              const ServerMainAddress: string;
                              ServerMainPort: Integer;
                              ServerMainThreadCacheSize: Integer;
                              const ServerAdminAddress: string;
                              ServerAdminPort: Integer;
                              ServerAdminThreadCacheSize: Integer;
                              ServerEncryptedOnly: Boolean;
                              const ServerEncryptionPassword: string;
                              const ServerConfigFileName: string;
                              const ServerConfigPassword: string;
                              ServerLicensedConnections: Word);
         procedure Reset;
         function ValidVersion(VersionByte: Byte): Boolean;
         function VersionToStr(VersionByte: Byte): string;
         procedure SetCryptoInitCallback(ClientData: Integer;
                                         CryptoInitCallback: pCryptoInitCallback);
         procedure SetEncryptBlockCallback(ClientData: Integer;
                                      EncryptBlockCallback: pEncryptBlockCallback);
         procedure SetDecryptBlockCallback(ClientData: Integer;
                                      DecryptBlockCallback: pDecryptBlockCallback);
         procedure SetCryptoResetCallback(ClientData: Integer;
                                          CryptoResetCallback: pCryptoResetCallback);
         procedure CryptoInit(Key: Pointer; KeyLen: Integer;
                              out OutData: Pointer; out OutDataBytes: Integer);
         procedure EncryptBlock(Data: Pointer; BlockBuffer: Pointer);
         procedure DecryptBlock(Data: Pointer; BlockBuffer: Pointer);
         procedure CryptoReset(Data: Pointer);
         procedure Encrypt(Data: Pointer; Buffer: PChar; BufferSize: Integer);
         procedure Decrypt(Data: Pointer; Buffer: PChar; BufferSize: Integer);
         procedure SetCompressCallback(ClientData: Integer;
                                       CompressCallback: pCompressCallback);
         procedure SetDecompressCallback(ClientData: Integer;
                                         DecompressCallback: pDecompressCallback);
         procedure Compress(const InBuffer: Pointer; InBytes: Integer; Level: Byte;
                            out OutBuffer: Pointer; out OutBytes: Integer);
         procedure Decompress(const InBuffer: Pointer; InBytes: Integer;
                              out OutBuffer: Pointer; out OutBytes: Integer);
         procedure BuildWordList(const TableName: string; const FieldName: string;
                                 WordBuffer: PChar; WordBufferSize: Integer;
                                 WordList: TLocaleStringList; const SpaceChars: TCharSet;
                                 const IncludeChars: TCharSet; Occurrences: Boolean;
                                 PartialWords: Boolean);
         procedure GetDefaultTextIndexParams(StopWordsList: TStrings;
                                             var TextSpaceChars: TCharSet;
                                             var TextIncludeChars: TCharSet);
         function GetDefaultTextIndexSpaceChars: TCharSet;
         function GetDefaultTextIndexIncludeChars: TCharSet;
         procedure SetTextIndexFilterCallback(ClientData: Integer;
                                              TextIndexFilterCallback: pTextIndexFilterCallback);
         procedure TextIndexFilter(const TableName: string; const FieldName: string;
                                   const InBuffer: Pointer; InBytes: Integer;
                                   out OutBuffer: Pointer; out OutBytes: Integer);
         procedure SetTextIndexTokenFilterCallback(ClientData: Integer;
                                                   TextIndexTokenFilterCallback: pTextIndexTokenFilterCallback);
         procedure TextIndexTokenFilter(const TableName: string; const FieldName: string;
                                        const TextIndexToken: string; var Include: Boolean);
         procedure SetCustomFunctionCallback(ClientData: Integer;
                                             FunctionCallback: pFunctionCallback);
         procedure SetGetCustomFunctionsCallback(ClientData: Integer;
                                                 GetFunctionsCallback: pGetFunctionsCallback);
         procedure CustomFunction(const FunctionName: string;
                                 InParamCount: Word;
                                 const InParamDefinitions: array of pFieldDefinition;
                                 InRecordBuffer: PChar;
                                 ResultDataType: Byte;
                                 out ResultSize: Integer;
                                 out ResultBuffer: PChar);
         function GetFunctionDefinitionByPos(FunctionIndex: Word): pFunctionDefinition;
         function GetFunctionDefinitionByName(const NameOfFunction: string): pFunctionDefinition;
         procedure SetTriggerCallback(ClientData: Integer;
                                      TriggerCallback: pTriggerCallback);
         procedure SetErrorCallback(ClientData: Integer;
                                    ErrorCallback: pErrorCallback);
         procedure Trigger(TriggerType: Byte;
                           DataSession: TDataSession;
                           DataDirectory: TDataDirectory;
                           DataCursor: TDataCursor;
                           RecordNumber: Integer;
                           RecordBuffer: PChar;
                           OldRecordBuffer: PChar);
         procedure Error(ErrorType: Byte;
                         DataSession: TDataSession;
                         DataDirectory: TDataDirectory;
                         DataCursor: TDataCursor;
                         RecordNumber: Integer;
                         RecordBuffer: PChar;
                         E: Exception; var Response: Byte);
         procedure GetFileNames(IsMemory: Boolean; const DirMask: string;
                                IncludeExtensions: Boolean;
                                List: TStrings);
         function FindFile(const Value: string; IsMemory: Boolean;
                           var IndexPos: Integer): Boolean;
         function FileExists(const Value: string; IsMemory: Boolean;
                             IsHidden: Boolean): Boolean;
         function GetTempFileName(const TempDirectory: string; const Extension: string;
                                  IsMemory: Boolean; IsHidden: Boolean): string;
         function CreateFile(Value: string; IsMemory: Boolean;
                             var NewFile: TBaseFile;
                             IsTemporary: Boolean; IsHidden: Boolean): Integer;
         function OpenFile(Value: string; IsMemory: Boolean;
                           var NewFile: TBaseFile; var IsMarkedReadOnly: Boolean;
                           var IsReadOnly: Boolean; IsExclusive: Boolean;
                           IsTemporary: Boolean; IsHidden: Boolean): Integer;
         function CloseFile(ExistingFile: TBaseFile; IsMemory: Boolean;
                            FileHandle: Integer): Integer;
         function RenameFile(const Value: string; IsMemory: Boolean; const NewName: string): Integer;
         function CopyToFile(FromFile: TBaseFile;
                             FromHandle: Integer; ToIsMemory: Boolean;
                             const ToName: string;
                             Compression: Byte;
                             ClientData: Integer;
                             CopyFileCallback: pCopyFileCallback;
                             ProgressPercent: Word): Integer;
         function CopyFromFile(ToFile: TBaseFile; ToHandle: Integer;
                               FromIsMemory: Boolean;
                               const FromName: string;
                               ClientData: Integer;
                               CopyFileCallback: pCopyFileCallback;
                               ProgressPercent: Word): Integer;
         function CopyToHandle(FromFile: TBaseFile; FromHandle: Integer;
                               ToFile: TBaseFile; ToHandle: Integer;
                               Compression: Byte;
                               ClientData: Integer;
                               CopyFileCallback: pCopyFileCallback;
                               ProgressPercent: Word): Integer;
         function CopyFromHandle(ToFile: TBaseFile; ToHandle: Integer;
                                 FromFile: TBaseFile; FromHandle: Integer;
                                 TotalBytes: Int64;
                                 ClientData: Integer;
                                 CopyFileCallback: pCopyFileCallback;
                                 ProgressPercent: Word): Integer;
         function SkipFromHandle(FromFile: TBaseFile; FromHandle: Integer;
                                 TotalBytes: Int64): Integer;
         function DeleteFile(const Value: string; IsMemory: Boolean): Integer;
         procedure GetErrorString(ErrorCode: Word; Msg: PChar);
         function OSError: Integer;
         procedure RaiseError(ErrorCode: Word;
                              const ErrorRemoteName: string='';
                              const ErrorUserName: string='';
                              const ErrorDatabaseName: string='';
                              const ErrorTableName: string='';
                              const ErrorFieldName: string='';
                              const ErrorIndexName: string='';
                              const ErrorMessage: string='';
                              const ErrorProcedureName: string='';
                              const ErrorEventName: string='';
                              ErrorLine: Integer=0; ErrorColumn: Integer=0);
         function ConvertExceptionToCode(E: Exception): Word;
         function TranslateErrorConstant(Value: Word): string;
         function TranslateRequestConstant(Value: Word): string;
         procedure LockLocaleSettings;
         procedure UnlockLocaleSettings;
         procedure GetDefaultLocaleSettings(LocaleID: Integer;
                                            var LocaleSettings: TLocaleSettings);
         procedure GetLocaleSettings(var LocaleSettings: TLocaleSettings);
         procedure SetLocaleSettings(var NewLocaleSettings: TLocaleSettings);
         function IsValidLocale(LocaleID: Integer): Boolean;
         function IsValidLocaleConstant(const LocaleConstant: string): Boolean;
         function ConvertLocaleConstantToID(const LocaleConstant: string): Integer;
         function ConvertIDToLocaleConstant(LocaleID: Integer): string;
         function GetLocaleCharMap(LocaleID: Integer): TLocaleCharMap;
         procedure GetLocaleNames(List: TStrings);
         procedure StartDataSession(var Value: TDataSession);
         procedure CloseDataSession(Value: TDataSession);
         procedure SetServerStartCallback(ClientData: Integer;
                                            StartCallback: pServerNotifyCallback);
         procedure SetServerStopCallback(ClientData: Integer;
                                           StopCallback: pServerNotifyCallback);
         procedure SetServerLogEventCallback(ClientData: Integer;
                                             LogEventCallback: pServerLogEventCallback);
         procedure SetServerLogCountCallback(ClientData: Integer;
                                             LogCountCallback: pServerLogCountCallback);
         procedure SetServerLogRecordCallback(ClientData: Integer;
                                              LogRecordCallback: pServerLogRecordCallback);
         procedure SetServerConnectCallback(ClientData: Integer;
                                              ConnectCallback: pServerConnectCallback);
         procedure SetServerReconnectCallback(ClientData: Integer;
                                                ReconnectCallback: pServerReconnectCallback);
         procedure SetServerLoginCallback(ClientData: Integer;
                                            LoginCallback: pServerLoginCallback);
         procedure SetServerLogoutCallback(ClientData: Integer;
                                             LogoutCallback: pServerLogoutCallback);
         procedure SetServerDisconnectCallback(ClientData: Integer;
                                                 DisconnectCallback: pServerDisconnectCallback);
         procedure SetServerScheduledEventCallback(ClientData: Integer;
                                                     ScheduledEventCallback: pServerScheduledEventCallback);
         procedure SetServerProcedureCallback(ClientData: Integer;
                                               ProcedureCallback: pServerProcedureCallback);
         procedure GetServerUserNames(List: TStrings);
         procedure GetServerUser(const UserName: string; var UserPassword: string;
                                 var UserDescription: string; var IsAdministrator: Boolean;
                                 var MaxConnections: Word);
         procedure AddServerUser(const UserName: string; const UserPassword: string;
                                 const UserDescription: string; IsAdministrator: Boolean;
                                 MaxConnections: Word);
         procedure ModifyServerUser(const UserName: string; const UserPassword: string;
                                    const UserDescription: string; IsAdministrator: Boolean;
                                    MaxConnections: Word);
         procedure ModifyServerUserPassword(const UserName: string; const UserPassword: string);
         procedure DeleteServerUser(const UserName: string);
         procedure GetServerDatabaseNames(List: TStrings);
         procedure GetServerDatabase(const DatabaseName: string;
                                     var DatabaseDescription: string;
                                     var ServerPath: string);
         procedure AddServerDatabase(const DatabaseName: string;
                                     const DatabaseDescription: string;
                                     const ServerPath: string);
         procedure ModifyServerDatabase(const DatabaseName: string;
                                        const DatabaseDescription: string;
                                        const ServerPath: string);
         procedure DeleteServerDatabase(const DatabaseName: string);
         procedure GetServerDatabaseUserNames(const DatabaseName: string;
                                              List: TStrings);
         procedure GetServerDatabaseUser(const DatabaseName: string;
                                         const AuthorizedUser: string;
                                         var UserRights: Integer);
         procedure AddServerDatabaseUser(const DatabaseName: string;
                                         const AuthorizedUser: string;
                                         RightsToAssign: Integer);
         procedure ModifyServerDatabaseUser(const DatabaseName: string;
                                            const AuthorizedUser: string;
                                            RightsToAssign: Integer);
         procedure DeleteServerDatabaseUser(const DatabaseName: string;
                                            const AuthorizedUser: string);
         procedure GetServerProcedureNames(List: TStrings);
         procedure GetServerProcedure(const ProcedureName: string;
                                      var ProcedureDescription: string);
         procedure AddServerProcedure(const ProcedureName: string;
                                      const ProcedureDescription: string);
         procedure ModifyServerProcedure(const ProcedureName: string;
                                         const ProcedureDescription: string);
         procedure DeleteServerProcedure(const ProcedureName: string);
         procedure GetServerProcedureUserNames(const ProcedureName: string;
                                               List: TStrings);
         procedure GetServerProcedureUser(const ProcedureName: string;
                                          const AuthorizedUser: string;
                                          var UserRights: Integer);
         procedure AddServerProcedureUser(const ProcedureName: string;
                                          const AuthorizedUser: string;
                                          RightsToAssign: Integer);
         procedure ModifyServerProcedureUser(const ProcedureName: string;
                                             const AuthorizedUser: string;
                                             RightsToAssign: Integer);
         procedure DeleteServerProcedureUser(const ProcedureName: string;
                                             const AuthorizedUser: string);
         procedure GetServerEventNames(List: TStrings);
         procedure GetServerEvent(const EventName: string; var EventDescription: string;
                                  var EventRunType: Byte;
                                  var EventStartDate: TDateTime;
                                  var EventEndDate: TDateTime;
                                  var EventStartTime: TDateTime;
                                  var EventEndTime: TDateTime;
                                  var EventInterval: Word;
                                  var EventDays: TConfigDays;
                                  var EventDayOfMonth: Byte;
                                  var EventDayOfWeek: Byte;
                                  var EventMonths: TConfigMonths;
                                  var EventLastRun: TDateTime);
         procedure AddServerEvent(const EventName: string; const EventDescription: string;
                                  EventRunType: Byte;
                                  EventStartDate: TDateTime;
                                  EventEndDate: TDateTime;
                                  EventStartTime: TDateTime;
                                  EventEndTime: TDateTime;
                                  EventInterval: Word;
                                  EventDays: TConfigDays;
                                  EventDayOfMonth: Byte;
                                  EventDayOfWeek: Byte;
                                  EventMonths: TConfigMonths);
         procedure ModifyServerEvent(const EventName: string; const EventDescription: string;
                                     EventRunType: Byte;
                                     EventStartDate: TDateTime;
                                     EventEndDate: TDateTime;
                                     EventStartTime: TDateTime;
                                     EventEndTime: TDateTime;
                                     EventInterval: Word;
                                     EventDays: TConfigDays;
                                     EventDayOfMonth: Byte;
                                     EventDayOfWeek: Byte;
                                     EventMonths: TConfigMonths);
         procedure DeleteServerEvent(const EventName: string);
         procedure GetServerConfig(var DenyLogins: Boolean; var MaxConnections: Word;
                                   var ConnectTimeout: Word; var DeadSessionInterval: Word;
                                   var DeadSessionExpires: Word; var MaxDeadSessions: Word;
                                   var TempDirectory: string;
                                   AuthorizedAddresses: TStrings; BlockedAddresses: TStrings);
         procedure ModifyServerConfig(DenyLogins: Boolean; MaxConnections: Word;
                                      ConnectTimeout: Word; DeadSessionInterval: Word;
                                      DeadSessionExpires: Word; MaxDeadSessions: Word;
                                      const TempDirectory: string;
                                      AuthorizedAddresses: TStrings; BlockedAddresses: TStrings);
         procedure ServerStart;
         procedure ServerStop;
         procedure LogServerEvent(LogRecord: TDataLogRecord);
         function GetServerLogCount: Integer;
         function GetServerLogRecord(Number: Integer): TDataLogRecord;
         function ServerConnect(IsEncrypted: Boolean;
                                const ConnectAddress: string): TObject;
         procedure ServerReconnect(IsEncrypted: Boolean;
                                   const ConnectAddress: string;
                                   UserData: TObject);
         procedure ServerLogin(const UserName: string;
                               UserData: TObject);
         procedure ServerLogout(var UserData: TObject);
         procedure ServerDisconnect(UserData: TObject;
                                    const LastConnectAddress: string);
         procedure ServerScheduledEvent(const EventName: string;
                                        var Completed: Boolean);
         procedure StartAdminServer;
         procedure StopAdminServer;
         procedure StartMainServer;
         procedure StopMainServer;
         function GetServerUTCDateTime: TDateTime;
         function GetServerUpTime: Int64;
         function GetServerMemoryUsage: double;
         function GetServerSessionCount: Integer;
         function GetServerConnectedSessionCount: Integer;
         function GetServerSessionInfo(SessionNum: Integer;
                                       var SessionID: Integer;
                                       var CreatedOn: TDateTime;
                                       var LastConnectedOn: TDateTime;
                                       var UserName: string;
                                       var UserAddress: string;
                                       var IsEncryptedSession: Boolean;
                                       var LastUserAddress: string): Boolean;
         function DisconnectServerSession(SessionID: Integer): Boolean;
         function RemoveServerSession(SessionID: Integer): Boolean;
         procedure ServerProcedure(DataSession: TDataSession;
                                   const ProcedureName: string;
                                   InParamCount: Word;
                                   const InParamDefinitions: array of pFieldDefinition;
                                   InRecordBuffer: PChar;
                                   out OutParamCount: Word;
                                   out OutParamDefinitions: array of pFieldDefinition;
                                   out OutRecordBuffer: PChar;
                                   out OutBlobCount: Word;
                                   out OutBlobBuffers: array of PChar);
      end;

   TEngineFile = class(TObject)
      private
         FInMemory: Boolean;
         FBaseFile: TBaseFile;
         FFileName: string;
         FHandle: Integer;
         FExclusive: Boolean;
         FReadOnly: Boolean;
         FMarkedReadOnly: Boolean;
         FIsOpen: Boolean;
         FTemporary: Boolean;
         FHidden: Boolean;
      protected
         function GetProperFileName: string; virtual;
      public
         constructor Create(Owner: TObject); virtual;
         destructor Destroy; override;
         property InMemory: Boolean read FInMemory write FInMemory;
         property BaseFile: TBaseFile read FBaseFile;
         property Handle: Integer read FHandle;
         property Exclusive: Boolean read FExclusive write FExclusive;
         property ReadOnly: Boolean read FReadOnly write FReadOnly;
         property MarkedReadOnly: Boolean read FMarkedReadOnly;
         property FileName: string read FFileName write FFileName;
         property ProperFileName: string read GetProperFileName;
         property IsOpen: Boolean read FIsOpen;
         property Temporary: Boolean read FTemporary write FTemporary;
         property Hidden: Boolean read FHidden write FHidden;
         procedure OpenFile; virtual;
         procedure CloseFile; virtual;
         procedure CreateFile; virtual;
         procedure DeleteFile; virtual;
         procedure RenameFile(const NewName: string); virtual;
         procedure CopyToFile(const NewName: string;
                              Compression: Byte;
                              ClientData: Integer;
                              CopyFileCallback: pCopyFileCallback;
                              ProgressPercent: Word); virtual;
         procedure CopyFromFile(const FromName: string;
                                ClientData: Integer;
                                CopyFileCallback: pCopyFileCallback;
                                ProgressPercent: Word); virtual;
         procedure CopyTo(EngineFile: TEngineFile;
                          Compression: Byte;
                          ClientData: Integer;
                          CopyFileCallback: pCopyFileCallback;
                          ProgressPercent: Word); virtual;
         procedure CopyFrom(EngineFile: TEngineFile;
                            TotalBytes: Int64;
                            ClientData: Integer;
                            CopyFileCallback: pCopyFileCallback;
                            ProgressPercent: Word); virtual;
         procedure SkipFrom(EngineFile: TEngineFile;
                            TotalBytes: Int64); virtual;
         function Read(var Buffer; NumBytes: Integer;
                       IgnoreLessBytes: Boolean): Integer; virtual;
         procedure Write(const Buffer; NumBytes: Integer); virtual;
         procedure Flush; virtual;
         function Seek(Position: Int64; From: Word): Int64;
         function GetPos: Int64;
         function GetSize: Int64;
         function LockRegion(Offset: Int64; LockLength: Int64;
                             LockIt: Boolean): Boolean;
         function Exists: Boolean;
         procedure LockFile;
         procedure UnlockFile;
      end;

   TBuffer = class(TObject)
      private
         FBufferedFile: TBufferedFile;
         FIsDirty: Boolean;
         FUseCount: Word;
         FNumber: Integer;
         FBuffer: PChar;
         FBufferSize: Integer;
         FSize: Integer;
         FNextBuffer: TBuffer;
         FPrevBuffer: TBuffer;
         procedure ResizeFileBuffer(Value: Integer);
         procedure SetSize(Value: Integer);
         procedure SetNumber(Value: Integer);
      public
         constructor Create(Owner: TBufferedFile); virtual;
         destructor Destroy; override;
         property BufferedFile: TBufferedFile read FBufferedFile;
         property Buffer: PChar read FBuffer;
         property IsDirty: Boolean read FIsDirty write FIsDirty;
         property UseCount: Word read FUseCount;
         property NextBuffer: TBuffer read FNextBuffer write FNextBuffer;
         property PrevBuffer: TBuffer read FPrevBuffer write FPrevBuffer;
         property Number: Integer read FNumber write SetNumber;
         property Size: Integer read FSize write SetSize;
         procedure Copy(ToCopy: TBuffer); virtual;
         procedure CopyBuffer(BufferToCopy: PChar); virtual;
         procedure CopyToBuffer(BufferToCopyTo: PChar); virtual;
         procedure Initialize(DefinitionPos: Byte=0); virtual;
         procedure Read(ReadBuffer: PChar); virtual;
         procedure Write(WriteBuffer: PChar); virtual;
         procedure IncUseCount;
         procedure DecUseCount;
         procedure ClearUseCount;
         function IsEqualTo(ToCompare: TBuffer): Boolean; virtual;
         function IsEqualToBuffer(BufferToCompare: PChar): Boolean; virtual;
      end;

   TBufferedFile = class(TEngineFile)
      private
         FDataTable: TDataTable;
         FReadBuffer: PChar;
         FReadBufferSize: Integer;
         FReadSize: Integer;
         FReadFilePos: Int64;
         FWriteBuffer: PChar;
         FWriteBufferSize: Integer;
         FFirstBuffer: TBuffer;
         FLastBuffer: TBuffer;
         FBuffers: TList;
         FWriteBuffers: TList;
         FCacheHits: Integer;
         FCacheMisses: Integer;
         FReads: Integer;
         FTotalReads: Int64;
         FWrites: Integer;
         FReadAheadBuffers: Integer;
         function GetTableName: string;
         function GetProperDataDirectoryName: string;
         function GetFileSize: Int64;
         procedure ReadBuffers(DefinitionPos: Byte; BufferNum: Integer;
                               NumBuffers: Integer; Direction: Byte;
                               InsertIndex: Integer;
                               var BufferToGet: TBuffer);
         procedure ResizeReadBuffer(Value: Integer);
         procedure ResizeWriteBuffer(Value: Integer);
         function FindBuffer(BufferNum: Integer; var BufferIndex: Integer): Boolean;
         procedure CreateNewBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                    var BufferToCreate: TBuffer);
         procedure InsertAsFirstBuffer(BufferToInsert: TBuffer);
         procedure MoveToFirstBuffer(BufferToMove: TBuffer);
         procedure DeleteBuffer(BufferToDelete: TBuffer);
         function FindFirstBuffer(BufferNum: Integer;
                                  var BufferToGet: TBuffer): Boolean;
         function FindBufferToDelete: TBuffer;
         procedure GetNewBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                var BufferIndex: Integer; var BufferToGet: TBuffer);
         procedure ClearLastBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                   var BufferIndex: Integer; var BufferToGet: TBuffer);
         function DeleteLastBuffer: Boolean;
      protected
         function CreateBuffer: TBuffer; virtual; abstract;
         procedure CorruptError; virtual; abstract;
         procedure CheckMaxBuffers; virtual; abstract;
         procedure IncNextBuffer; virtual; abstract;
         function CalculateCapacity: Integer; virtual; abstract;
         function CalculateReadAhead: Integer; virtual; abstract;
         function GetIOBlockSize: Word; virtual; abstract;
         function GetBufferSize: Word; virtual; abstract;
         function GetHeaderSize: Int64; virtual; abstract;
         function GetIOBlocksUsed: Integer; virtual; abstract;
         function GetLastUpdateStamp: Integer; virtual; abstract;
         function GetMRUBuffers: Byte; virtual; abstract;
         function GetBufferExpand: Byte; virtual; abstract;
         function GetReadAheadBuffers(DataCursor: TDataCursor;
                                      Direction: Byte): Integer; virtual;
      public
         constructor Create(Owner: TObject); override;
         destructor Destroy; override;
         property DataTable: TDataTable read FDataTable;
         property TableName: string read GetTableName;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         property IOBlockSize: Word read GetIOBlockSize;
         property BufferSize: Word read GetBufferSize;
         property IOBlocksUsed: Integer read GetIOBlocksUsed;
         property HeaderSize: Int64 read GetHeaderSize;
         property FileSize: Int64 read GetFileSize;
         property MRUBuffers: Byte read GetMRUBuffers;
         property BufferExpand: Byte read GetBufferExpand;
         property CacheHits: Integer read FCacheHits;
         property CacheMisses: Integer read FCacheMisses;
         property Reads: Integer read FReads;
         property TotalReads: Int64 read FTotalReads;
         property Writes: Integer read FWrites;
         property ReadAheadBuffers: Integer read FReadAheadBuffers;
         property LastUpdateStamp: Integer read GetLastUpdateStamp;
         procedure CreateFile; override;
         procedure OpenFile; override;
         procedure InitializeBuffers; virtual;
         procedure CloseFile; override;
         procedure ReadHeader; virtual; abstract;
         function WriteHeader(ForceHeader: Boolean): Boolean; virtual; abstract;
         procedure UpdateHeaderStamp; virtual; abstract;
         procedure ClearHeader; virtual;
         procedure CheckHeader; virtual; abstract;
         function RepairHeader(DataCursor: TDataCursor;
                               VerifyOnly: Boolean): Boolean; virtual; abstract;
         function GetBuffer(DataCursor: TDataCursor; DefinitionPos: Byte;
                            BufferNum: Integer; ReadAhead: Boolean; Direction: Byte;
                            var BufferToGet: TBuffer): Boolean;
         procedure PutBuffer(BufferToRelease: TBuffer);
         procedure FreeBuffers;
         function FlushBuffers(Internal: Boolean=False): Boolean;
         procedure AdjustBuffers;
         function CheckForChanges: Boolean; virtual; abstract;
      end;

   TDataPassword = class(TObject)
      private
         FDataSession: TDataSession;
         FPassword: string;
         FDigest: TMD5Digest;
         FData: Pointer;
         FDataSize: Integer;
      public
         constructor Create(Owner: TDataSession);
         destructor Destroy; override;
         property Password: string read FPassword;
         property Digest: TMD5Digest read FDigest;
         property Data: Pointer read FData;
         procedure Initialize(const Password: string);
         function CompareDigest(Value: TMD5Digest): Boolean;
         function ComparePassword(const Value: string): Boolean;
         procedure Copy(Value: TDataPassword);
      end;

   TPingThread = class(TThread)
      private
         FDataSession: TDataSession;
         FEvent: Pointer;
      protected
         procedure Execute; override;
      public
         constructor Create(Owner: TDataSession);
         destructor Destroy; override;
         property DataSession: TDataSession read FDataSession
                                            write FDataSession;
         procedure Ping;
      end;

   { Allows waits for data without using TWinSocketStream and
     works around a bug in Kylix sockets.pas WaitForData where
     it can return False on disconnects }

   TDataSocket = class(TClientSocket)
      public
         function WaitForData(Timeout: Integer): Boolean;
      end;

   TDataSession = class(TObject)
      private
         FDataEngine: TDataEngine;
         FName: string;
         FDataDirectoryList: TList;
         FPrivateDirectory: string;
         FProgress: Word;
         FPasswordList: TList;
         FPasswordStack: TList;
         FForceBufferFlush: Boolean;
         FStrictChangeDetection: Boolean;
         FLockRetries: Byte;
         FLockWait: Word;
         FLockProtocol: Byte;
         FIsRemote: Boolean;
         FInsideEngine: Boolean;
         FSessionLock: Pointer;
         FReconnectStopAsking: Boolean;
         FPing: Boolean;
         FPingInterval: Word;
         FPingTimer: TThreadTimer;
         FPinging: Boolean;
         FPingThread: TPingThread;
         FRemoteID: Integer;
         FRemoteEngineVersion: Currency;
         { Version 5 }
         FRemoteEngineBuildNumber: Integer;
         { Version 5 }
         FIsEncrypted: Boolean;
         FEncryptPassword: string;
         FEncryptDigest: TMD5Digest;
         FEncryptData: Pointer;
         FEncryptDataSize: Integer;
         FCompression: Byte;
         FConnected: Boolean;
         FLoggedIn: Boolean;
         FHost: string;
         FAddress: string;
         FPort: Integer;
         FService: string;
         FUserName: string;
         FPassword: string;
         FTracing: Boolean;
         FSocket: TDataSocket;
         FOldErrorProc: TSocketErrorProc;
         FInitializingConnection: Boolean;
         FPackPos: Integer;
         FRequestHeader: TRequestHeader;
         FSendBuffer: PChar;
         FSendBufferSize: Integer;
         FUnpackPos: Integer;
         FReplyHeader: TReplyHeader;
         FReceiveBuffer: PChar;
         FReceiveBufferSize: Integer;
         FTimeOut: Word;
         FLoginClientData: Integer;
         FLoginCallback: pLoginCallback;
         FTimeoutClientData: Integer;
         FTimeoutCallback: pTimeoutCallback;
         FSendClientData: Integer;
         FSendCallback: pSendReceiveCallback;
         FReceiveClientData: Integer;
         FReceiveCallback: pSendReceiveCallback;
         FTraceClientData: Integer;
         FTraceCallback: pTraceCallback;
         FReconnectClientData: Integer;
         FReconnectCallback: pReconnectCallback;
         FGetPathClientData: Integer;
         FGetPathCallback: pGetPathCallback;
         FGetRightsClientData: Integer;
         FGetRightsCallback: pGetRightsCallback;
         FCheckRightsClientData: Integer;
         FCheckRightsCallback: pCheckRightsCallback;
         FPasswordClientData: Integer;
         FPasswordCallback: pPasswordCallback;
         FSavePasswordClientData: Integer;
         FSavePasswordCallback: pPasswordCallback;
         FProcedureProgressClientData: Integer;
         FProcedureProgressCallback: pProcedureProgressCallback;
         FCallbackSessionObject: TObject;
         { Version 5}
         FSessionLastAutoInc: Integer;
         { Version 5}
         function GetHasOpenDirectories: Boolean;
         procedure FreeDataDirectories;
         function GetPrivateDirectory: string;
         procedure SetPrivateDirectory(const Value: string);
         function GetProgressPercent: Word;
         procedure SetProgress(Value: Word);
         procedure SetForceBufferFlush(Value: Boolean);
         procedure SetStrictChangeDetection(Value: Boolean);
         procedure SetLockRetries(Value: Byte);
         procedure SetLockWait(Value: Word);
         procedure SetLockProtocol(Value: Byte);
         procedure SetIsRemote(Value: Boolean);
         procedure SetIsEncrypted(Value: Boolean);
         procedure SetEncryptPassword(const Value: string);
         function DoLogin: Boolean;
         function DoTimeout(var StayConnected: Boolean): Boolean;
         procedure DoSendProgress(NumBytes: Integer; PercentDone: Word);
         procedure DoReceiveProgress(NumBytes: Integer; PercentDone: Word);
         procedure DoTrace(TraceRecord: TDataTraceRecord);
         procedure SetConnectionParams;
         procedure SetReconnectionParams;
         procedure FreeEncryptData;
         procedure ResizeSendBuffer(Value: Integer; ShrinkBuffer: Boolean=False);
         procedure ResizeReceiveBuffer(Value: Integer; ShrinkBuffer: Boolean=False);
         function CheckForDigest(Value: TMD5Digest): TDataPassword;
         function InternalReceive: Byte;
         function InternalSend: Boolean;
         function GetIsServer: Boolean;
         procedure SetInsideEngine(Value: Boolean);
         function SocketConnected: Boolean;
         function WaitForData(TimeOut: Integer): Boolean;
         function ReceiveBuffer(var Buffer; Count: Integer): Integer;
         function SendBuffer(var Buffer; Count: Integer): Integer;
         procedure SetPing(Value: Boolean);
         procedure SetPingInterval(Value: Word);
         procedure StartPinging;
         procedure StopPinging;
         procedure PingTimerTimer(Sender: TObject);
         function GetStackPassword(const Value: string): TDataPassword;
         procedure FreeAllPasswords;
      public
         constructor Create(Owner: TDataEngine);
         destructor Destroy; override;
         property Name: string read FName write FName;
         property DataDirectoryList: TList read FDataDirectoryList;
         property HasOpenDirectories: Boolean read GetHasOpenDirectories;
         property PrivateDirectory: string read GetPrivateDirectory
                                           write SetPrivateDirectory;
         property Progress: Word read FProgress write SetProgress;
         property ProgressPercent: Word read GetProgressPercent;
         property ForceBufferFlush: Boolean read FForceBufferFlush
                                            write SetForceBufferFlush;
         property StrictChangeDetection: Boolean read FStrictChangeDetection
                                                 write SetStrictChangeDetection;
         property LockRetries: Byte read FLockRetries write SetLockRetries;
         property LockWait: Word read FLockWait write SetLockWait;
         property LockProtocol: Byte read FLockProtocol write SetLockProtocol;
         property IsRemote: Boolean read FIsRemote write SetIsRemote;
         property IsServer: Boolean read GetIsServer;
         property InsideEngine: Boolean read FInsideEngine write SetInsideEngine;
         property IsEncrypted: Boolean read FIsEncrypted write SetIsEncrypted;
         property EncryptPassword: string read FEncryptPassword write SetEncryptPassword;
         property Compression: Byte read FCompression write FCompression;
         property TimeOut: Word read FTimeOut write FTimeOut;
         property Ping: Boolean read FPing write SetPing;
         property PingInterval: Word read FPingInterval write SetPingInterval;
         property Pinging: Boolean read FPinging write FPinging;
         property RemoteID: Integer read FRemoteID;
         property Host: string read FHost write FHost;
         property Address: string read FAddress write FAddress;
         property Port: Integer read FPort write FPort;
         property Service: string read FService write FService;
         property UserName: string read FUserName write FUserName;
         property Password: string read FPassword write FPassword;
         property Connected: Boolean read FConnected;
         property LoggedIn: Boolean read FLoggedIn;
         property Tracing: Boolean read FTracing write FTracing;
         property SendBufferSize: Integer read FSendBufferSize;
         property ReceiveBufferSize: Integer read FReceiveBufferSize;
         property RemoteEngineVersion: Currency read FRemoteEngineVersion;
         { Version 5}
         property RemoteEngineBuildNumber: Integer read FRemoteEngineBuildNumber;
         { Version 5}
         property CallbackSessionObject: TObject read FCallbackSessionObject
                                                 write FCallbackSessionObject;
         { Version 5}
         property SessionLastAutoInc: Integer read FSessionLastAutoInc
                                              write FSessionLastAutoInc;
         { Version 5}
         function GetSendBuffer: PChar;
         function GetReceiveBuffer: PChar;
         function AskForPassword: Boolean;
         procedure AddPassword(const Value: string);
         procedure DeletePassword(const Value: string);
         procedure DeleteAllPasswords;
         function CheckForPassword(const Value: string): Boolean;
         function GetDataPassword(const Value: string): TDataPassword;
         { Version 5 }
         function OpenDataDirectory(const DataDirectoryName: string;
                                    const DataDirectoryPath: string;
                                    KeepSharedTablesOpen: Boolean;
                                    NoRemoteCall: Boolean;
                                    CompareNames: Boolean=False): TDataDirectory;
         { Version 5 }
         procedure CloseDataDirectory(ExistingDataDirectory: TDataDirectory;
                                      NoRemoteCall: Boolean);
         procedure Connect;
         function CheckReconnect(var Continue: Boolean;
                                 var StopAsking: Boolean): Boolean;
         procedure HandleReconnect;
         procedure Reconnect;
         procedure Disconnect;
         procedure Login;
         procedure Logout;
         procedure SetSessionParams;
         { Version 5 }
         procedure RemoveAllRemoteMemoryTables;
         { Version 5 }
         procedure StartRemoteRequest;
         procedure EndRemoteRequest;
         procedure CheckCallbacks(NewClientData: Integer);
         procedure SetLoginCallback(ClientData: Integer;
                                    LoginCallback: pLoginCallback);
         procedure SetTimeoutCallback(ClientData: Integer;
                                      TimeoutCallback: pTimeoutCallback);
         procedure SetSendCallback(ClientData: Integer;
                                   SendCallback: pSendReceiveCallback);
         procedure SetReceiveCallback(ClientData: Integer;
                                      ReceiveCallback: pSendReceiveCallback);
         procedure SetTraceCallback(ClientData: Integer;
                                    TraceCallback: pTraceCallback);
         procedure SetReconnectCallback(ClientData: Integer;
                                        ReconnectCallback: pReconnectCallback);
         procedure SetGetPathCallback(ClientData: Integer;
                                      GetPathCallback: pGetPathCallback);
         procedure SetGetRightsCallback(ClientData: Integer;

                                        GetRightsCallback: pGetRightsCallback);
         procedure SetCheckRightsCallback(ClientData: Integer;
                                          CheckRightsCallback: pCheckRightsCallback);
         procedure SetPasswordCallback(ClientData: Integer;
                                       PasswordCallback: pPasswordCallback);
         procedure SavePasswordCallbackData;
         procedure RestorePasswordCallbackData;
         procedure SetProcedureProgressCallback(ClientData: Integer;
                                                ProcedureProgressCallback: pProcedureProgressCallback);
         function GetRequestCode: Word;
         procedure SetRequestCode(Value: Word);
         function GetResultCode: Word;
         procedure Send;
         procedure SendReceive;
         procedure Receive(var CallbackType: Word);
         function GetRemoteLocation: string;
         procedure BeginPack;
         procedure Pack(const Buffer; BufferSize: Integer);
         procedure EndPack;
         procedure BeginUnpack;
         function Unpack(var Buffer): Integer;
         function SkipUnpack: Integer;
         function RemainingReplySize: Integer;
         procedure UnpackException;
         procedure CheckForException;
         procedure CheckForConnection;
         procedure GetRemoteUserNames(UserNamesList: TStrings);
         procedure GetRemoteUser(const UserName: string; var UserPassword: string;
                                 var UserDescription: string;
                                 var IsAdministrator: Boolean;
                                 var MaxConnections: Word);
         procedure AddRemoteUser(const UserName: string; const UserPassword: string;
                                 const UserDescription: string;
                                 IsAdministrator: Boolean;
                                 MaxConnections: Word);
         procedure ModifyRemoteUser(const UserName: string; const UserPassword: string;
                                    const UserDescription: string;
                                    IsAdministrator: Boolean;
                                    MaxConnections: Word);
         procedure ModifyRemoteUserPassword(const UserName: string;
                                            const UserPassword: string);
         procedure DeleteRemoteUser(const UserName: string);
         procedure GetRemoteDatabaseNames(DatabaseNamesList: TStrings);
         procedure GetRemoteDatabase(const DatabaseName: string;
                                     var DatabaseDescription: string;
                                     var ServerPath: string);
         procedure AddRemoteDatabase(const DatabaseName: string;
                                     const DatabaseDescription: string;
                                     const ServerPath: string);
         procedure ModifyRemoteDatabase(const DatabaseName: string;
                                        const DatabaseDescription: string;
                                        const ServerPath: string);
         procedure DeleteRemoteDatabase(const DatabaseName: string);
         procedure AddRemoteDatabaseUser(const DatabaseName: string;
                                         const AuthorizedUser: string;
                                          RightsToAssign: Integer);
         procedure ModifyRemoteDatabaseUser(const DatabaseName: string;
                                            const AuthorizedUser: string;
                                            RightsToAssign: Integer);
         procedure DeleteRemoteDatabaseUser(const DatabaseName: string;
                                            const AuthorizedUser: string);
         procedure GetRemoteDatabaseUser(const DatabaseName: string;
                                         const AuthorizedUser: string;
                                          var UserRights: Integer);
         procedure GetRemoteDatabaseUserNames(const DatabaseName: string;
                                              DatabaseUserNamesList: TStrings);
         procedure GetRemoteProcedureNames(ProcedureNamesList: TStrings);
         procedure GetRemoteProcedure(const ProcedureName: string;
                                      var ProcedureDescription: string);
         procedure AddRemoteProcedure(const ProcedureName: string;
                                      const ProcedureDescription: string);
         procedure ModifyRemoteProcedure(const ProcedureName: string;
                                         const ProcedureDescription: string);
         procedure DeleteRemoteProcedure(const ProcedureName: string);
         procedure AddRemoteProcedureUser(const ProcedureName: string;
                                          const AuthorizedUser: string;
                                           RightsToAssign: Integer);
         procedure ModifyRemoteProcedureUser(const ProcedureName: string;
                                             const AuthorizedUser: string;
                                              RightsToAssign: Integer);
         procedure DeleteRemoteProcedureUser(const ProcedureName: string;
                                             const AuthorizedUser: string);
         procedure GetRemoteProcedureUser(const ProcedureName: string;
                                          const AuthorizedUser: string;
                                           var UserRights: Integer);
         procedure GetRemoteProcedureUserNames(const ProcedureName: string;
                                               ProcedureUserNamesList: TStrings);
         procedure GetRemoteEventNames(EventNamesList: TStrings);
         procedure GetRemoteEvent(const EventName: string; var EventDescription: string;
                                  var EventRunType: Byte;
                                  var EventStartDate: TDateTime;
                                  var EventEndDate: TDateTime;
                                  var EventStartTime: TDateTime;
                                  var EventEndTime: TDateTime;
                                  var EventInterval: Word;
                                  var EventDays: TConfigDays;
                                  var EventDayOfMonth: Byte;
                                  var EventDayOfWeek: Byte;
                                  var EventMonths: TConfigMonths;
                                  var EventLastRun: TDateTime);
         procedure AddRemoteEvent(const EventName: string; const EventDescription: string;
                                  EventRunType: Byte;
                                  EventStartDate: TDateTime;
                                  EventEndDate: TDateTime;
                                  EventStartTime: TDateTime;
                                  EventEndTime: TDateTime;
                                  EventInterval: Word;
                                  EventDays: TConfigDays;
                                  EventDayOfMonth: Byte;
                                  EventDayOfWeek: Byte;
                                  EventMonths: TConfigMonths);
         procedure ModifyRemoteEvent(const EventName: string; const EventDescription: string;
                                     EventRunType: Byte;
                                     EventStartDate: TDateTime;
                                     EventEndDate: TDateTime;
                                     EventStartTime: TDateTime;
                                     EventEndTime: TDateTime;
                                     EventInterval: Word;
                                     EventDays: TConfigDays;
                                     EventDayOfMonth: Byte;
                                     EventDayOfWeek: Byte;
                                     EventMonths: TConfigMonths);
         procedure DeleteRemoteEvent(const EventName: string);
         procedure GetRemoteConfig(var DenyLogins: Boolean; var MaxConnections: Word;
                                   var ConnectTimeout: Word; var DeadSessionInterval: Word;
                                   var DeadSessionExpires: Word; var MaxDeadSessions: Word;
                                   var TempDirectory: string;
                                   AuthorizedAddresses: TStrings;
                                   BlockedAddresses: TStrings);
         procedure ModifyRemoteConfig(DenyLogins: Boolean; MaxConnections: Word;
                                      ConnectTimeout: Word; DeadSessionInterval: Word;
                                      DeadSessionExpires: Word; MaxDeadSessions: Word;
                                      const TempDirectory: string;
                                      AuthorizedAddresses: TStrings;
                                      BlockedAddresses: TStrings);
         function GetRemoteLogCount: Integer;
         function GetRemoteLogRecord(Number: Integer): TDataLogRecord;
         procedure StartRemoteServer;
         procedure StopRemoteServer;
         function GetRemoteEngineVersion: string;
         function GetRemoteDateTime: TDateTime;
         function GetRemoteUTCDateTime: TDateTime;
         function GetRemoteUpTime: Int64;
         function GetRemoteServerName: string;
         function GetRemoteServerDescription: string;
         function GetRemoteMemoryUsage: double;
         function GetRemoteMainAddress: string;
         function GetRemoteMainPort: Integer;
         function GetRemoteMainThreadCacheSize: Integer;
         function GetRemoteAdminAddress: string;
         function GetRemoteAdminPort: Integer;
         function GetRemoteAdminThreadCacheSize: Integer;
         function GetRemoteSessionCount: Integer;
         function GetRemoteConnectedSessionCount: Integer;
         function GetRemoteSessionInfo(SessionNum: Integer;
                                       var SessionID: Integer;
                                       var CreatedOn: TDateTime;
                                       var LastConnectedOn: TDateTime;
                                       var UserName: string;
                                       var UserAddress: string;
                                       var IsEncryptedSession: Boolean;
                                       var LastAddress: string): Boolean;
         function DisconnectRemoteSession(SessionID: Integer): Boolean;
         function RemoveRemoteSession(SessionID: Integer): Boolean;
         procedure PackParameters(ParamCount: Word;
                                  const ParamDefinitions: array of pFieldDefinition;
                                  RecordBuffer: PChar);
         procedure UnpackParameters(out OutParamCount: Word;
                                    out OutParamDefinitions: array of pFieldDefinition;
                                    out OutRecordBuffer: PChar;
                                    out OutBlobCount: Word;
                                    out OutBlobBuffers: array of PChar);
         procedure ServerProcedure(const ProcedureName: string;
                                   InParamCount: Word;
                                   const InParamDefinitions: array of pFieldDefinition;
                                   InRecordBuffer: PChar;
                                   out OutParamCount: Word;
                                   out OutParamDefinitions: array of pFieldDefinition;
                                   out OutRecordBuffer: PChar;
                                   out OutBlobCount: Word;
                                   out OutBlobBuffers: array of PChar);
         procedure CallRemoteProcedure(const ProcedureName: string;
                                       InParamCount: Word;
                                       const InParamDefinitions: array of pFieldDefinition;
                                       InRecordBuffer: PChar;
                                       out OutParamCount: Word;
                                       out OutParamDefinitions: array of pFieldDefinition;
                                       out OutRecordBuffer: PChar;
                                       out OutBlobCount: Word;
                                       out OutBlobBuffers: array of PChar);
         procedure DoGetPath(const DataDirectoryName: string;
                             var Path: string);
         procedure DoGetRights(const DataDirectoryName: string;
                               var Rights: Integer);
         procedure DoCheckRights(DataDirectory: TObject; RightToCheck: Byte);
         procedure DoProcedureProgress(const Status: string; PercentDone: Word;
                                       var Abort: Boolean);
      end;

   TLockState = (lsReadLocked,lsWriteLocked,lsTransLocked);

   TLockStates = set of TLockState;

   TDataTableLocks = class(TObject)
      private
         FDataDirectoryLocks: TDataDirectoryLocks;
         FTableID: Integer;
         FTableName: string;
         FLockStates: TLockStates;
         FReadLockSlot: Word;
         function GetProperDataDirectoryName: string;
      public
         constructor Create(Owner: TDataDirectoryLocks);
         property DataDirectoryLocks: TDataDirectoryLocks read FDataDirectoryLocks;
         property TableID: Integer read FTableID write FTableID;
         property TableName: string read FTableName write FTableName;
         property LockStates: TLockStates read FLockStates;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         procedure Read(Buffer: PChar);
         procedure Write(Buffer: PChar);
         function ReadLock: Boolean;
         procedure ReadUnlock;
         function WriteLock(TransLock: Boolean): Boolean;
         procedure WriteUnlock(TransUnlock: Boolean);
         function TransLock: Boolean;
         procedure TransUnlock;
      end;

   TDataDirectoryLocks = class(TObject)
      private
         FDataDirectory: TDataDirectory;
         FLockFile: TEngineFile;
         FLockFileBuffer: PChar;
         FLockFileBufferSize: Integer;
         FUpdateCount: Integer;
         FLockSlot: Word;
         FDataTableLocksList: TList;
         FReadOnly: Boolean;
         procedure FreeDataTableLocks;
         procedure ResizeLockFileBuffer(Value: Integer);
         procedure PopulateDataTables;
         procedure ReadLockFile;
         procedure ReadUnlockFile;
         procedure WriteLockFile;
         procedure WriteUnlockFile;
         procedure ReadDataTables;
         procedure WriteDataTables;
         function ReadLock(var LockSlot: Word; BeginByte: Int64;
                           Retries: Word; WaitTime: Word): Boolean;
         function ReadUnlock(LockSlot: Word; BeginByte: Int64): Boolean;
         function WriteLock(BeginByte: Int64; Range: Int64;
                            Retries: Word; WaitTime: Word): Boolean;
         function WriteUnlock(BeginByte: Int64; Range: Int64): Boolean;
          function GetProperDataDirectoryName: string;
      public
         constructor Create(Owner: TDataDirectory);
         destructor Destroy; override;
         property DataDirectory: TDataDirectory read FDataDirectory;
         property LockFile: TEngineFile read FLockFile;
         property DataTableLocksList: TList read FDataTableLocksList;
         property ReadOnly: Boolean read FReadOnly;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         procedure Open;
         procedure CheckTableLimit;
         function FindDataTable(const TableName: string): Integer;
         function AddDataTable(const TableName: string): TDataTableLocks;
         procedure TransLockDataDirectory;
         procedure TransUnlockDataDirectory;
         procedure TransWriteLockDataDirectory;
         procedure TransWriteUnlockDataDirectory;
      end;

   TDataDirectory = class(TSafeObject)
      private
         FDataSession: TDataSession;
         FRemoteID: Integer;
         FName: string;
         FDirectory: string;
         FReadOnly: Boolean;
         FKeepTablesOpen: Boolean;
         FLocks: TDataDirectoryLocks;
         FDataTableList: TList;
         FTransactionDataTableList: TList;
         FDataCursorList: TList;
         FQueryStatementList: TList;
         FUseCount: Word;
         FInTransaction: Boolean;
         FRestrictedTransaction: Boolean;
         FServerRights: Integer;
         FSteppedProgressCallback: pSteppedProgressCallback;
         FSteppedProgressClientData: Integer;
         FLogCallback: pLogCallback;
         FLogClientData: Integer;
         FCallbackDatabaseObject: TObject;
         function GetHasOpenTables: Boolean;
         function FindDataTable(const Value: string;
                                var IndexPos: Integer): Boolean;
         procedure FreeDataTables;
         procedure CloseUnusedDataTables;
         procedure FreeDataCursors;
         procedure FreeQueryStatements;
         procedure SetRequestCode(Value: Word);
         procedure Send;
         procedure SendReceive;
         procedure Receive;
         procedure StartRemoteRequest;
         procedure EndRemoteRequest;
         procedure BeginPack;
         procedure Pack(const Buffer; BufferSize: Integer);
         procedure EndPack;
         function Unpack(var Buffer): Integer;
         procedure CheckForException;
         procedure CheckForConnection;
         function GetIsRemote: Boolean;
         function GetIsEncrypted: Boolean;
         function GetConnected: Boolean;
         function GetProperDataDirectoryName: string;
         function GetInMemory: Boolean;
         function GetProgressPercent: Word;
         function GetRemoteEngineVersion: Currency;
         { Version 5 }
         function GetRemoteEngineBuildNumber: Integer;
         { Version 5 }
         procedure DoSteppedProgress(const Step: string;
                                     PercentDone: Word);
         procedure DoLog(const LogMessage: string);
      public
         constructor Create(Owner: TDataSession; const NewName: string;
                            const NewDirectory: string); reintroduce; overload;
         destructor Destroy; override;
         property DataSession: TDataSession read FDataSession;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         property IsRemote: Boolean read GetIsRemote;
         property IsEncrypted: Boolean read GetIsEncrypted;
         property RemoteID: Integer read FRemoteID write FRemoteID;
         property Connected: Boolean read GetConnected;
         property DataTableList: TList read FDataTableList;
         property TransactionDataTableList: TList read FTransactionDataTableList; 
         property HasOpenTables: Boolean read GetHasOpenTables;
         property Name: string read FName write FName;
         property Directory: string read FDirectory;
         property InMemory: Boolean read GetInMemory;
         property ReadOnly: Boolean read FReadOnly;
         property KeepTablesOpen: Boolean read FKeepTablesOpen write FKeepTablesOpen;
         property UseCount: Word read FUseCount;
         property Locks: TDataDirectoryLocks read FLocks;
         property InTransaction: Boolean read FInTransaction;
         property RestrictedTransaction: Boolean read FRestrictedTransaction;
         property ServerRights: Integer read FServerRights write FServerRights;
         property ProgressPercent: Word read GetProgressPercent;
         property RemoteEngineVersion: Currency read GetRemoteEngineVersion;
         { Version 5 }
         property RemoteEngineBuildNumber: Integer read GetRemoteEngineBuildNumber;
         { Version 5 }
         property CallbackDatabaseObject: TObject read FCallbackDatabaseObject
                                                 write FCallbackDatabaseObject;
         procedure IncUseCount;
         procedure DecUseCount;
         { Version 5 }
         procedure ListTableNames(TableNameList: TStrings;
                                  PartialDirectory: Boolean=False);
         { Version 5 }
         function CreateDataTable(const NewTableName: string;
                                  NewLocaleID: Integer;
                                  NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                  NewEncrypted: Boolean; NewPassword: string;
                                  NewDescription: string;
                                  NewIndexPageSize: Integer;
                                  NewBlobBlockSize: Integer;
                                  NewLastAutoIncID: Integer;
                                  NumberOfFields: Word;
                                  const FieldDefinitions: array of pFieldDefinition;
                                  NumberOfIndexes: Byte;
                                  const IndexDefinitions: array of pIndexDefinition;
                                  IsTemporary: Boolean): TDataTable;
         function OpenDataTable(const ExistingTableName: string;
                                const ExistingErrorTableName: string;
                                IsExclusive: Boolean; IsTemporary: Boolean;
                                IsResultSet: Boolean; IsSourceTable: Boolean;
                                IsSystemOpen: Boolean; DoHeaderChecks: Boolean=True): TDataTable;
         procedure CloseDataTable(ExistingDataTable: TDataTable;
                                  FreeIfTemporary: Boolean;
                                  IsResultSet: Boolean;
                                  IsSourceTable: Boolean;
                                  IsSystemOpen: Boolean);
         procedure RenameDataTable(const ExistingTableName: string;
                                   NewDataDirectory: TDataDirectory;
                                   const NewTableName: string;
                                   BackupExtensions: Boolean);
         procedure DeleteDataTable(const ExistingTableName: string);
         function DataTableExists(const SearchTableName: string;
                                  OpenOnly: Boolean;
                                  IsTemporary: Boolean): Boolean;
         function GetTempDataTableName: string;
         procedure CheckNotReadOnly(const TableName: string);
         procedure CheckTransaction;
         procedure StartTransaction(NoRemoteCall: Boolean;
                                    TablesList: TStrings);
         procedure CommitTransaction(ForceFlush: Boolean;
                                     ReleaseLocks: Boolean;
                                     NoRemoteCall: Boolean);
         procedure RollbackTransaction(NoRemoteCall: Boolean);
         procedure AddDataCursor(Cursor: TObject);
         procedure RemoveDataCursor(Cursor: TObject);
         procedure AddQueryStatement(Statement: TObject);
         procedure RemoveQueryStatement(Statement: TObject);
         procedure CheckCallbacks(NewClientData: Integer);
         function Backup(const BackupName: string;
                         const BackupDescription: string;
                         Compression: Byte;
                         BackupTables: TStrings;
                         SendProgress: Boolean; SendLog: Boolean): Boolean;
         function BackupInfo(const BackupName: string;
                             var BackupDescription: string;
                             var BackupDateTime: TDateTime;
                             BackupTables: TStrings): Boolean;
         function Restore(const BackupName: string;
                          BackupTables: TStrings;
                          SendProgress: Boolean; SendLog: Boolean): Boolean;
         procedure SetSteppedProgressCallback(ClientData: Integer;
                                             SteppedProgressCallback: pSteppedProgressCallback);
         procedure SetLogCallback(ClientData: Integer;
                                  LogCallback: pLogCallback);
      end;

   TRecord = class(TBuffer)
      private
         function GetStatus: Byte;
         procedure SetStatus(Value: Byte);
         function GetNextFreeNumber: Integer;
         procedure SetNextFreeNumber(Value: Integer);
         function GetOriginalNumber: Integer;
         procedure SetOriginalNumber(Value: Integer);
         function GetID: Integer;
         procedure SetID(Value: Integer);
         function GetHash: TMD5Digest;
         procedure SetHash(Value: TMD5Digest);
      public
         property Status: Byte read GetStatus write SetStatus;
         property NextFreeNumber: Integer read GetNextFreeNumber write SetNextFreeNumber;
         property OriginalNumber: Integer read GetOriginalNumber write SetOriginalNumber;
         property ID: Integer read GetID write SetID;
         property Hash: TMD5Digest read GetHash write SetHash;
         procedure Copy(BufferToCopy: TBuffer); override;
         procedure Initialize(DefinitionPos: Byte=0); override;
         procedure Read(ReadBuffer: PChar); override;
         procedure Write(WriteBuffer: PChar); override;
      end;

   TDataFile = class(TBufferedFile)
      private
         FHeader: TDataHeader;
         FFieldsAreDirty: Boolean;
         FFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
         FRecordIDField: TFieldDefinition;
         FRecordHashField: TFieldDefinition;
         function GetFieldCount: Word;
         function GetBlobFieldCount: Word;
         function GetBlobBlockSize: Integer;
         function GetIndexPageSize: Integer;
         function GetLocaleID: Integer;
         function GetUserMajorVersion: Word;
         function GetUserMinorVersion: Word;
         function GetVersionNum: Byte;
         procedure AddFields(NumberOfFields: Word;
                             const FieldDefinitions: array of pFieldDefinition);
         procedure ReadFields;
         function WriteFields: Boolean;
         procedure SetRecordCount(Value: Integer);
         function GetRecordCount: Integer;
         function GetNextFreeRecordNumber: Integer;
         procedure SetNextFreeRecordNumber(Value: Integer);
         function GetLastRecordID: Integer;
         procedure SetLastRecordID(Value: Integer);
         function GetNextRecordID: Integer;
         function GetLastAutoIncID: Integer;
         procedure SetLastAutoIncID(Value: Integer);
         procedure SetLastBlobSignature(Value: Integer);
         function GetLastBlobSignature: Integer;
         function GetNextBlobSignature: Integer;
         function GetDescription: string;
         function GetLastUpdated: TDateTime;
         function GetEncrypted: Boolean;
         procedure FreeFieldDefinitions;
      protected
         function GetProperFileName: string; override;
         function CreateBuffer: TBuffer; override;
         procedure CorruptError; override;
         procedure CheckMaxBuffers; override;
         procedure IncNextBuffer; override;
         function CalculateCapacity: Integer; override;
         function CalculateReadAhead: Integer; override;
         function GetIOBlockSize: Word; override;
         function GetBufferSize: Word; override;
         function GetHeaderSize: Int64; override;
         function GetIOBlocksUsed: Integer; override;
         function GetLastUpdateStamp: Integer; override;
         function GetMRUBuffers: Byte; override;
         function GetBufferExpand: Byte; override;
         function GetReadAheadBuffers(DataCursor: TDataCursor;
                                      Direction: Byte): Integer; override;
      public
         constructor Create(Owner: TObject); override;
         destructor Destroy; override;
         property Description: string read GetDescription;
         property LastUpdated: TDateTime read GetLastUpdated;
         property Encrypted: Boolean read GetEncrypted;
         property RecordCount: Integer read GetRecordCount
                                       write SetRecordCount;
         property FieldCount: Word read GetFieldCount;
         property BlobFieldCount: Word read GetBlobFieldCount;
         property BlobBlockSize: Integer read GetBlobBlockSize;
         property IndexPageSize: Integer read GetIndexPageSize;
         property LocaleID: Integer read GetLocaleID;
         property UserMajorVersion: Word read GetUserMajorVersion;
         property UserMinorVersion: Word read GetUserMinorVersion;
         property VersionNum: Byte read GetVersionNum;
         procedure CreateFile; override;
         procedure OpenFile; override;
         procedure CloseFile; override;
         procedure GetHeader(var Header: TDataHeader);
         procedure ReadHeader; override;
         function WriteHeader(ForceHeader: Boolean): Boolean; override;
         procedure UpdateHeaderStamp; override;
         procedure ClearHeader; override;
         procedure CheckHeader; override;
         function RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean; override;
         procedure UpdateHeader(NewLocaleID: Integer;
                                NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                NewEncrypted: Boolean; NewDigest: TMD5Digest;
                                const NewDescription: string;
                                NewIndexPageSize: Integer;
                                NewBlobBlockSize: Integer;
                                NewLastAutoIncID: Integer);
         function CheckForChanges: Boolean; override;
         procedure IncRecordCount;
         procedure DecRecordCount;
         function GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
         function GetFieldNumber(NameOfField: string): Word;
         function GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
         function GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
         procedure UpdateFieldDefinitionByPos(FieldIndex: Word;
                                               Buffer: pFieldDefinition);
         function LockRecord(RecordToLock: Integer): Boolean;
         function UnlockRecord(RecordToUnlock: Integer): Boolean;
         function LockTable: Boolean;
         function UnlockTable: Boolean;
         function LockSemaphore(SemaphoreToLock: Integer): Boolean;
         function UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
         procedure UnpackStaticTableInfo;
         procedure UnpackVariableTableInfo;
         procedure LocalUnpackVariableTableInfo(DataCursor: TDataCursor);
      end;

   TPage = class(TBuffer)
      private
         FHeader: TPageHeader;
         FKeySize: Word;
         FKeyUnique: Boolean;
         FNoKeyStatistics: Boolean;
         FKeyCompressionType: Byte;
         function GetPageType: Byte;
         procedure SetPageType(Value: Byte);
         function GetCompressedSize: Word;
         function GetNumberOfKeys: Word;
         procedure SetNumberOfKeys(Value: Word);
         function GetMaximumKeys: Word;
         function GetTotalLowerKeyCount: Integer;
         function GetLeftNumber: Integer;
         procedure SetLeftNumber(Value: Integer);
         function GetRightNumber: Integer;
         procedure SetRightNumber(Value: Integer);
         function CalculateDuplicateByteCount(PriorKeyCounter: Integer;
                                              KeyCounter: Integer): Byte;
         function CalculateTrailingByteCount(KeyCounter: Integer;
                                             DuplicateCount: Byte): Byte;
         function GetDuplicateByteCount(KeyCounter: Integer): Byte;
         procedure SetDuplicateByteCount(KeyCounter: Integer; Value: Byte);
         function GetTrailingByteCount(KeyCounter: Integer): Byte;
         procedure SetTrailingByteCount(KeyCounter: Integer; Value: Byte);
         procedure CalculateCompressedSize(KeyCounter: Integer; Inserted: Boolean);
         procedure RecalculateTotalCompressedSize;
         procedure CompressPageData(PageBuffer: PChar);
         procedure UnCompressPageData(PageBuffer: PChar);
      public
         property PageType: Byte read GetPageType write SetPageType;
         property CompressedSize: Word read GetCompressedSize;
         property NumberOfKeys: Word read GetNumberOfKeys write SetNumberOfKeys;
         property MaximumKeys: Word read GetMaximumKeys;
         property TotalLowerKeyCount: Integer read GetTotalLowerKeyCount;
         property LeftNumber: Integer read GetLeftNumber write SetLeftNumber;
         property RightNumber: Integer read GetRightNumber write SetRightNumber;
         property KeySize: Word read FKeySize;
         property KeyUnique: Boolean read FKeyUnique;
         property NoKeyStatistics: Boolean read FNoKeyStatistics;
         property KeyCompressionType: Byte read FKeyCompressionType;
         procedure Initialize(DefinitionPos: Byte=0); override;
         procedure Read(ReadBuffer: PChar); override;
         procedure Write(WriteBuffer: PChar); override;
         procedure Copy(BufferToCopy: TBuffer); override;
         function GetKey(KeyCounter: Integer): PChar;
         procedure InsertKey(NewBuffer: PChar; var KeyCounter: Integer);
         procedure UpdateKey(NewBuffer: PChar; KeyCounter: Integer);
         procedure DeleteKey(var KeyCounter: Integer);
         function GetRecordNumber(KeyCounter: Integer): Integer;
         procedure SetRecordNumber(KeyCounter: Integer; Value: Integer);
         function GetLowerKeyCount(KeyCounter: Integer): Integer;
         procedure SetLowerKeyCount(KeyCounter: Integer; Value: Integer);
         procedure IncLowerKeyCount(KeyCounter: Integer);
         procedure DecLowerKeyCount(KeyCounter: Integer);
         function GetPageKeyCount(KeyCounter: Integer): Integer;
         function PageDataOverflowed: Boolean;
         procedure AllocateBuffer;
      end;

   TIndexFile = class(TBufferedFile)
      private
         FHeader: TIndexHeader;
         FIndexesAreDirty: Boolean;
         FIndexDefinitions: array [0..MAX_NUM_INDEXES] of TIndexDefinition;
         function GetIndexCount: Byte;
         procedure SetIndexCount(Value: Byte);
         function GetAutoPrimaryIndex: Boolean;
         function CheckPageNumber(PageNumber: Integer): Boolean;
         procedure ReadIndexes;
         function WriteIndexes(ForceIndexes: Boolean): Boolean;
         procedure FreeIndexDefinitions;
      protected
         function GetProperFileName: string; override;
         function CreateBuffer: TBuffer; override;
         procedure CorruptError; override;
         procedure CheckMaxBuffers; override;
         procedure IncNextBuffer; override;
         function CalculateCapacity: Integer; override;
         function CalculateReadAhead: Integer; override;
         function GetIOBlockSize: Word; override;
         function GetBufferSize: Word; override;
         function GetHeaderSize: Int64; override;
         function GetIOBlocksUsed: Integer; override;
         function GetLastUpdateStamp: Integer; override;
         function GetMRUBuffers: Byte; override;
         function GetBufferExpand: Byte; override;
      public
         constructor Create(Owner: TObject); override;
         destructor Destroy; override;
         property IndexCount: Byte read GetIndexCount write SetIndexCount;
         property AutoPrimaryIndex: Boolean read GetAutoPrimaryIndex;
         function CheckForChanges: Boolean; override;
         procedure OpenFile; override;
         procedure CloseFile; override;
         procedure CreateFile; override;
         procedure AddPrimaryIndex(NewIndexDefinition: pIndexDefinition);
         procedure AddSecondaryIndex(NewIndexDefinition: pIndexDefinition);
         procedure DeleteIndex(IndexPos: Byte; AdjustIndexDefinitions: Boolean);
         function GetIndexDefinition(IndexPos: Byte): pIndexDefinition;
         procedure SetIndexDefinition(IndexPos: Byte; Buffer: pIndexDefinition);
         procedure UpdateIndexDefinition(IndexPos: Byte; Buffer: pIndexDefinition);
         function IndexExists(const NewName: string): Boolean;
         procedure GetHeader(var Header: TIndexHeader);
         procedure ReadHeader; override;
         function WriteHeader(ForceHeader: Boolean): Boolean; override;
         procedure UpdateHeaderStamp; override;
         procedure ClearHeader; override;
         procedure CheckHeader; override;
         function RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean; override;
         function GetRootPageNumber(IndexPos: Byte): Integer;
         procedure SetRootPageNumber(IndexPos: Byte; Value: Integer);
         function GetNextFreePageNumber: Integer;
         procedure SetNextFreePageNumber(Value: Integer);
         function GetDataRootPageNumber(IndexPos: Byte): Integer;
         procedure SetDataRootPageNumber(IndexPos: Byte; Value: Integer);
         procedure UnpackStaticTableInfo;
      end;

   TBlock = class(TBuffer)
      private
         FHeader: TBlockHeader;
         function GetLength: Word;
         procedure SetLength(Value: Word);
         function GetTotalLength: Integer;
         procedure SetTotalLength(Value: Integer);
         function GetSignature: Integer;
         procedure SetSignature(Value: Integer);
         function GetPrevNumber: Integer;
         procedure SetPrevNumber(Value: Integer);
         function GetNextNumber: Integer;
         procedure SetNextNumber(Value: Integer);
      public
         property Length: Word read GetLength write SetLength;
         property TotalLength: Integer read GetTotalLength write SetTotalLength;
         property Signature: Integer read GetSignature write SetSignature;
         property PrevNumber: Integer read GetPrevNumber write SetPrevNumber;
         property NextNumber: Integer read GetNextNumber write SetNextNumber;
         procedure Initialize(DefinitionPos: Byte=0); override;
         procedure Read(ReadBuffer: PChar); override;
         procedure Write(WriteBuffer: PChar); override;
         procedure Copy(BufferToCopy: TBuffer); override;
         function GetBlockData(Offset: Word; LengthToGet: Word;
                               BlobBuffer: PChar): Word;
         function PutBlockData(Offset: Word; LengthToSet: Word;
                               BlobBuffer: PChar): Word;
         procedure TruncateBlockData(Offset: Word);
      end;

   TBlobFile = class(TBufferedFile)
      private
         FHeader: TBlobHeader;
         function CheckBlockNumber(BlockNumber: Integer): Boolean;
      protected
         function GetProperFileName: string; override;
         function CreateBuffer: TBuffer; override;
         procedure CorruptError; override;
         procedure CheckMaxBuffers; override;
         procedure IncNextBuffer; override;
         function CalculateCapacity: Integer; override;
         function CalculateReadAhead: Integer; override;
         function GetIOBlockSize: Word; override;
         function GetBufferSize: Word; override;
         function GetHeaderSize: Int64; override;
         function GetIOBlocksUsed: Integer; override;
         function GetLastUpdateStamp: Integer; override;
         function GetMRUBuffers: Byte; override;
         function GetBufferExpand: Byte; override;
         function GetReadAheadBuffers(DataCursor: TDataCursor;
                                      Direction: Byte): Integer; override;
      public
         procedure OpenFile; override;
         procedure CreateFile; override;
         function CheckForChanges: Boolean; override;
         procedure GetHeader(var Header: TBlobHeader);
         procedure ReadHeader; override;
         function WriteHeader(ForceHeader: Boolean): Boolean; override;
         procedure UpdateHeaderStamp; override;
         procedure ClearHeader; override;
         procedure CheckHeader; override;
         function RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean; override;
         function GetNextFreeBlockNumber: Integer;
         procedure SetNextFreeBlockNumber(Value: Integer);
         procedure UnpackStaticTableInfo;
      end;

   TDataTable = class(TObject)
      private
         FDataDirectory: TDataDirectory;
         FUseCount: Word;
         FClientUseCount: Word;
         FTableName: string;
         FErrorTableName: string;
         FIsOpen: Boolean;
         FExclusive: Boolean;
         FReadOnly: Boolean;
         FMarkedReadOnly: Boolean;
         FTemporary: Boolean;
         FDataTableLocks: TDataTableLocks;
         FRecordLocks: TRecordsBitmap;
         FTransactionRecordLocks: TRecordsBitmap;
         FTableLock: Boolean;
         FTransactionTableLock: Boolean;
         FSemaphoreLocks: TRecordsBitmap;
         FDataFile: TDataFile;
         FIndexFile: TIndexFile;
         FBlobFile: TBlobFile;
         FMissingIndex: Boolean;
         FInTransaction: Boolean;
         FWrittenTo: Boolean;
         FDataPassword: TDataPassword;
         function GetRecordCount: Integer;
         procedure SetRecordCount(Value: Integer);
         function GetIndexCount: Byte;
         procedure SetIndexCount(Value: Byte);
         function GetAutoPrimaryIndex: Boolean;
         function GetFieldCount: Word;
         function GetBlobFieldCount: Word;
         function GetPhysicalRecordsUsed: Integer;
         function GetPhysicalPagesUsed: Integer;
         function GetPhysicalBlocksUsed: Integer;
         function GetRecordSize: Word;
         function GetRecordBufferSize: Word;
         function GetBlobBlockSize: Integer;
         function GetBlobBlockBufferSize: Integer;
         function GetIndexPageSize: Integer;
         function GetIndexPageBufferSize: Integer;
         function GetLocaleID: Integer;
         function GetUserMajorVersion: Word;
         function GetUserMinorVersion: Word;
         function GetVersionNum: Byte;
         function GetDataCacheHits: Integer;
         function GetDataCacheMisses: Integer;
         function GetDataReads: Integer;
         function GetDataWrites: Integer;
         function GetIndexCacheHits: Integer;
         function GetIndexCacheMisses: Integer;
         function GetIndexReads: Integer;
         function GetIndexWrites: Integer;
         function GetBlobCacheHits: Integer;
         function GetBlobCacheMisses: Integer;
         function GetBlobReads: Integer;
         function GetBlobWrites: Integer;
         function GetDescription: string;
         function GetLastUpdated: TDateTime;
         function GetEncrypted: Boolean;
         function GetPassword: string;
         function GetDataFileSize: Int64;
         function GetIndexFileSize: Int64;
         function GetBlobFileSize: Int64;
         function GetLastDataUpdateStamp: Integer;
         function GetLastIndexUpdateStamp: Integer;
         function GetLastBlobUpdateStamp: Integer;
         function Unpack(var Buffer): Integer;
         function GetIsRemote: Boolean;
         function GetConnected: Boolean;
         function GetProperDataDirectoryName: string;
         function GetDataSession: TDataSession;
         function GetProperTableName: string;
      public
         constructor Create(Owner: TDataDirectory); virtual;
         destructor Destroy; override;
         property DataSession: TDataSession read GetDataSession;
         property DataDirectory: TDataDirectory read FDataDirectory;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         property DataFile: TDataFile read FDataFile;
         property IndexFile: TIndexFile read FIndexFile;
         property BlobFile: TBlobFile read FBlobFile;
         property UseCount: Word read FUseCount;
         property ClientUseCount: Word read FClientUseCount;
         property Exclusive: Boolean read FExclusive write FExclusive;
         property ReadOnly: Boolean read FReadOnly write FReadOnly;
         property MarkedReadOnly: Boolean read FMarkedReadOnly;
         property TableName: string read FTableName write FTableName;
         property ErrorTableName: string read FErrorTableName write FErrorTableName;
         property ProperTableName: string read GetProperTableName;
         property DataTableLocks: TDataTableLocks read FDataTableLocks;
         property IsRemote: Boolean read GetIsRemote;
         property Connected: Boolean read GetConnected;
         property IsOpen: Boolean read FIsOpen;
         property Temporary: Boolean read FTemporary write FTemporary;
         property MissingIndex: Boolean read FMissingIndex;
         property Description: string read GetDescription;
         property LastUpdated: TDateTime read GetLastUpdated;
         property Encrypted: Boolean read GetEncrypted;
         property Password: string read GetPassword;
         property DataPassword: TDataPassword read FDataPassword
                                              write FDataPassword;
         property PhysicalRecordsUsed: Integer read GetPhysicalRecordsUsed;
         property PhysicalPagesUsed: Integer read GetPhysicalPagesUsed;
         property PhysicalBlocksUsed: Integer read GetPhysicalBlocksUsed;
         property LastDataUpdateStamp: Integer read GetLastDataUpdateStamp;
         property LastIndexUpdateStamp: Integer read GetLastIndexUpdateStamp;
         property LastBlobUpdateStamp: Integer read GetLastBlobUpdateStamp;
         property DataCacheHits: Integer read GetDataCacheHits;
         property DataCacheMisses: Integer read GetDataCacheMisses;
         property DataReads: Integer read GetDataReads;
         property DataWrites: Integer read GetDataWrites;
         property IndexCacheHits: Integer read GetIndexCacheHits;
         property IndexCacheMisses: Integer read GetIndexCacheMisses;
         property IndexReads: Integer read GetIndexReads;
         property IndexWrites: Integer read GetIndexWrites;
         property BlobCacheHits: Integer read GetBlobCacheHits;
         property BlobCacheMisses: Integer read GetBlobCacheMisses;
         property BlobReads: Integer read GetBlobReads;
         property BlobWrites: Integer read GetBlobWrites;
         property RecordCount: Integer read GetRecordCount
                                       write SetRecordCount;
         property FieldCount: Word read GetFieldCount;
         property BlobFieldCount: Word read GetBlobFieldCount;
         property RecordSize: Word read GetRecordSize;
         property RecordBufferSize: Word read GetRecordBufferSize;
         property BlobBlockSize: Integer read GetBlobBlockSize;
         property BlobBlockBufferSize: Integer read GetBlobBlockBufferSize;
         property IndexPageSize: Integer read GetIndexPageSize;
         property IndexPageBufferSize: Integer read GetIndexPageBufferSize;
         property LocaleID: Integer read GetLocaleID;
         property UserMajorVersion: Word read GetUserMajorVersion;
         property UserMinorVersion: Word read GetUserMinorVersion;
         property VersionNum: Byte read GetVersionNum;
         property IndexCount: Byte read GetIndexCount write SetIndexCount;
         property AutoPrimaryIndex: Boolean read GetAutoPrimaryIndex;
         property InTransaction: Boolean read FInTransaction;
         property DataFileSize: Int64 read GetDataFileSize;
         property IndexFileSize: Int64 read GetIndexFileSize;
         property BlobFileSize: Int64 read GetBlobFileSize;
         property WrittenTo: Boolean read FWrittenTo write FWrittenTo;
         procedure IncUseCount;
         procedure DecUseCount;
         procedure IncClientUseCount;
         procedure DecClientUseCount;
         procedure UnpackStaticTableInfo;
         procedure UnpackVariableTableInfo;
         procedure LocalUnpackVariableTableInfo(DataCursor: TDataCursor);
         procedure AssignTableParams(UseTemporaryFlag: Boolean);
         procedure OpenTable(SystemOpen: Boolean;
                             DoHeaderChecks: Boolean=True);
         { Version 5 }
         procedure CloseTable(FreeIfTemporary: Boolean;
                              SystemOpen: Boolean);
         { Version 5 }
         function AskForPassword: Boolean;
         function GetDataPassword(const Value: string): TDataPassword;
         procedure VerifyDigest(Value: TMD5Digest);
         function CheckForDigest(Value: TMD5Digest): TDataPassword;
         function GetDigestForPassword(const Value: string): TMD5Digest;
         procedure Encrypt(Buffer: PChar; BufferSize: Integer);
         procedure Decrypt(Buffer: PChar; BufferSize: Integer);
         function PerformChangeDetection: Boolean;
         function ReadLockTable: Boolean;
         procedure ReadUnlockTable;
         function WriteLockTable: Boolean;
         procedure WriteUnlockTable;
         function LockRecord(RecordToLock: Integer): Boolean;
         procedure UnlockRecord(RecordToUnlock: Integer);
         procedure UnlockAll(TransactionLocks: Boolean);
         procedure UnlockAllSemaphores;
         function LockTable: Boolean;
         procedure UnlockTable;
         function CheckForRecordLock(RecordNum: Integer): Boolean;
         function CheckForTransactionRecordLock(RecordNum: Integer): Boolean;
         function LockSemaphore(SemaphoreToLock: Integer): Boolean;
         function UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
         procedure CreateTable(NewLocaleID: Integer;
                               NewUserMajorVersion: Word;
                               NewUserMinorVersion: Word;
                               NewEncrypted: Boolean;
                               NewPassword: string;
                               NewDescription: string;
                               NewIndexPageSize: Integer;
                               NewBlobBlockSize: Integer;
                               NewLastAutoIncID: Integer;
                               NumberOfFields: Word;
                               const FieldDefinitions: array of pFieldDefinition;
                               NumberOfIndexes: Byte;
                               const IndexDefinitions: array of pIndexDefinition);
         procedure EmptyTable;
         procedure EmptyIndex;
         procedure DeleteTable;
         procedure RenameTable(NewDataDirectory: TDataDirectory;
                               const NewTableName: string; BackupExtensions: Boolean);
         procedure InternalBackupIndex(TempDataDirectory: TDataDirectory);
         procedure InternalRestoreIndex(TempDataDirectory: TDataDirectory;
                                        RemoveOnly: Boolean; RemoveBackup: Boolean);
         function GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
         function GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
         function GetFieldNumber(NameOfField: string): Word;
         function GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
         procedure UpdateFieldDefinitionByPos(FieldIndex: Word;
                                              Buffer: pFieldDefinition);
         function GetIndexDefinition(CurIndexPos: Byte): pIndexDefinition;
         procedure SetIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
         procedure UpdateIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
         function IndexExists(const NewName: string): Boolean;
         procedure AddPrimaryIndex(NewIndexDefinition: pIndexDefinition);
         procedure AddSecondaryIndex(NewIndexDefinition: pIndexDefinition);
         procedure DeleteIndex(CurIndexPos: Byte; AdjustIndexDefinitions: Boolean);
         procedure IncRecordCount;
         procedure DecRecordCount;
         procedure StartTransaction;
         procedure RollbackTransaction;
         procedure CommitTransaction(ForceFlush: Boolean; ReleaseLocks: Boolean);
         procedure FreeBuffers(AdjustBuffers: Boolean; ReadHeaders: Boolean;
                               ReadIndexes: Boolean);
         procedure FlushBuffers(AdjustBuffers: Boolean;
                                ForceDataHeader: Boolean;
                                ForceIndexHeader: Boolean;
                                ForceBlobHeader: Boolean;
                                ForceOSFlush: Boolean);
         procedure FlushOSBuffers;
         procedure UpdateHeaderStamps(UpdateDataHeader: Boolean;
                                      UpdateIndexHeader: Boolean;
                                      UpdateBlobHeader: Boolean);
         function RecordIsLocked(RecordNum: Integer): Boolean;
         function TableIsLocked: Boolean;
         procedure RepairHeaders(DataCursor: TDataCursor; VerifyOnly: Boolean;
                                 var DataValid: Boolean; var IndexValid: Boolean;
                                 var BlobValid: Boolean);
         { Version 5 }
         procedure ReadHeaders;
         { Version 5 }
         procedure CheckHeaders;
         procedure ClearIndexHeader;
         procedure ClearHeaders;
         procedure UpdateDataHeader(NewLocaleID: Integer;
                                    NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                    NewEncrypted: Boolean; const NewPassword: string;
                                    const NewDescription: string;
                                    NewIndexPageSize: Integer;
                                    NewBlobBlockSize: Integer;
                                    NewLastAutoIncID: Integer);
         procedure GetDataHeader(var Header: TDataHeader);
         procedure GetIndexHeader(var Header: TIndexHeader);
         procedure GetBlobHeader(var Header: TBlobHeader);
         function GetRootPageNumber(IndexPos: Byte): Integer;
         procedure SetRootPageNumber(IndexPos: Byte; Value: Integer);
         function GetDataRootPageNumber(IndexPos: Byte): Integer;
         procedure SetDataRootPageNumber(IndexPos: Byte; Value: Integer);
         function GetNextFreePageNumber: Integer;
         procedure SetNextFreePageNumber(Value: Integer);
         function GetPage(DataCursor: TDataCursor; DefinitionPos: Byte;
                          PageNum: Integer; var PageToGet: TPage): Boolean;
         procedure PutPage(PageToRelease: TPage);
         function CreatePage(IndexPos: Byte): TPage;
         procedure FreePage(var ExistingPage: TPage);
         function CreateRecord: TRecord;
         procedure FreeRecord(var ExistingRecord: TRecord);
         function GetLastRecordID: Integer;
         procedure SetLastRecordID(Value: Integer);
         function GetNextRecordID: Integer;
         function GetLastAutoIncID: Integer;
         procedure SetLastAutoIncID(Value: Integer);
         procedure SetLastBlobSignature(Value: Integer);
         function GetLastBlobSignature: Integer;
         function GetNextBlobSignature: Integer;
         function GetNextFreeRecordNumber: Integer;
         procedure SetNextFreeRecordNumber(Value: Integer);
         function GetRecord(DataCursor: TDataCursor; RecordNum: Integer;
                            ReadAhead: Boolean; Direction: Byte;
                            var RecordToGet: TRecord): Boolean;
         procedure PutRecord(RecordToRelease: TRecord);
         function GetNextFreeBlockNumber: Integer;
         procedure SetNextFreeBlockNumber(Value: Integer);
         function GetBlock(DataCursor: TDataCursor; BlockNum: Integer;
                           ReadAhead: Boolean; Direction: Byte;
                           var BlockToGet: TBlock): Boolean;
         procedure PutBlock(BlockToRelease: TBlock);
      end;

   TFilter = class(TObject)
      private
         FDataCursor: TDataCursor;
         FFreeFilterTokens: Boolean;
         FFilterTokens: TExpToken;
         FClientData: Integer;
         FCallbackFunction: pFilterFunction;
         FFilterBitmap: TRecordsBitmap;
         FIsActive: Boolean;
         FIsCallbackFilter: Boolean;
         FOptimizeLevel: TOptimizeLevel;
         FUseExistingBitmaps: Boolean;
         FRemoteID: Integer;
         FRewritten: Boolean;
         procedure ResetNextFilterToken(NextToken: TExpToken;
                                        RecordBuffer: PChar;
                                        ClientData: Integer;
                                        FieldCallback: pEvaluateFieldCallback;
                                        LocaleID: Integer);
         procedure EvaluateFilter(Bitmap: TRecordsBitmap;
                                  NextToken: TExpToken;
                                  UpperFilterOperator: TExpOperator);
         procedure BuildTextSearchBitmap(Bitmap: TRecordsBitmap;
                                         FieldNum: Word;
                                         const FieldName: string;
                                         WordBuffer: PChar;
                                         WordBufferSize: Integer);
         procedure BuildIndexedBitmap(Bitmap: TRecordsBitmap;
                                      Operator: TExpOperator;
                                      FieldToken: TExpToken;
                                      ConstantToken: TExpToken;
                                      PartialLength: Word);
         procedure BuildIndexedRangeBitmap(Bitmap: TRecordsBitmap;
                                           Operator: TExpOperator;
                                           FieldToken: TExpToken;
                                           FirstConstantToken: TExpToken;
                                           SecondConstantToken: TExpToken);
         procedure BuildNonIndexedBitmap(Bitmap: TRecordsBitmap;
                                         NextToken: TExpToken;
                                         UpperFilterOperator: TExpOperator;
                                         ClientFilterData: Integer;
                                         CallbackFilterFunction: pFilterFunction);
         procedure BuildNonDeletedBitmap(Bitmap: TRecordsBitmap);
      public
         constructor Create(Owner: TDataCursor;
                            NextToken: TExpToken;
                            FreeTokens: Boolean;
                            UseExisting: Boolean;
                            CalculateCosts: Boolean;
                            ClientFilterData: Integer;
                            CallbackFilterFunction: pFilterFunction);
         destructor Destroy; override;
         property IsCallbackFilter: Boolean read FIsCallbackFilter;
         property IsActive: Boolean read FIsActive;
         property OptimizeLevel: TOptimizeLevel read FOptimizeLevel write FOptimizeLevel;
         property UseExistingBitmaps: Boolean read FUseExistingBitmaps;
         property FilterTokens: TExpToken read FFilterTokens;
         property FilterBitmap: TRecordsBitmap read FFilterBitmap;
         property Rewritten: Boolean read FRewritten;
         procedure Activate;
         procedure Deactivate;
         { Version 5 }
         procedure Update(UpperOperator: TExpOperator);
         function VerifyRecord(RecordToVerify: Integer; RecordBuffer: PChar): Boolean;
         { Version 5 }
         procedure UpdateRecord(RecordToUpdate: Integer; RecordBuffer: PChar);
         procedure DeleteRecord(RecordDeleted: Integer);
         procedure ResetFilterExpression(RecordBuffer: PChar;
                                         ClientData: Integer;
                                         FieldCallback: pEvaluateFieldCallback;
                                         LocaleID: Integer);
         property ClientData: Integer read FClientData write FClientData;
         property CallbackFunction: pFilterFunction read FCallbackFunction;
         property RemoteID: Integer read FRemoteID write FRemoteID;
      end;

   TBlobBuffer = class(TSafeObject)
      private
         FDataCursor: TDataCursor;
         FIsDirty: Boolean;
         FSignature: Integer;
         FFieldDefinition: pFieldDefinition;
         FBlockNumber: Integer;
         { Version 5 }
         FRecordNumber: Integer;
         { Version 5 }
         FBuffer: PChar;
         FOldBuffer: PChar;
         FSize: Integer;
         FOldSize: Integer;
         FOpenMode: Byte;
         FUseCount: Word;
         FEngineAllocated: Boolean;
         FRemoteID: Integer;
         procedure SetSize(Value: Integer);
         procedure Compress;
         procedure Decompress;
      public
         constructor Create(Owner: TDataCursor); reintroduce; overload; virtual;
         destructor Destroy; override;
         property DataCursor: TDataCursor read FDataCursor;
         property Buffer: PChar read FBuffer;
         property OldBuffer: PChar read FOldBuffer;
         property IsDirty: Boolean read FIsDirty write FIsDirty;
         property Signature: Integer read FSignature write FSignature;
         property FieldDefinition: pFieldDefinition read FFieldDefinition
                                                    write FFieldDefinition;
         property BlockNumber: Integer read FBlockNumber write FBlockNumber;
         property RecordNumber: Integer read FRecordNumber write FRecordNumber;
         property Size: Integer read FSize write SetSize;
         property OldSize: Integer read FOldSize;
         property OpenMode: Byte read FOpenMode write FOpenMode;
         property UseCount: Word read FUseCount;
         property EngineAllocated: Boolean read FEngineAllocated write FEngineAllocated;
         property RemoteID: Integer read FRemoteID write FRemoteID;
         procedure SaveBuffer;
         procedure IncUseCount;
         procedure DecUseCount;
      end;

   TDataCursor = class(TSafeObject)
      private
         FDataDirectory: TDataDirectory;
         FDataTable: TDataTable;
         FRemoteID: Integer;
         FTableName: string;
         FErrorTableName: string;
         FLastDataUpdateStamp: Integer;
         FLastIndexUpdateStamp: Integer;
         FLastBlobUpdateStamp: Integer;
         FIsOpen: Boolean;
         FExclusive: Boolean;
         FReadOnly: Boolean;
         FMarkedReadOnly: Boolean;
         FResultSet: Boolean;
         FSourceTable: Boolean;
         FTemporary: Boolean;
         { Version 5 }
         FSystemOpen: Boolean;
         { Version 5 }
         FCachedUpdates: Boolean;
         FRepairing: Boolean;
         FAlteringStructure: Boolean;
         FSuppressRecordIDs: Boolean;
         FSuppressTriggers: Boolean;
         FCurrentRecord: TRecord;
         FLastRecord: TRecord;
         FScratchRecord: TRecord;
         FHashRecord: TRecord;
         FSteppedProgressCallback: pSteppedProgressCallback;
         FSteppedProgressClientData: Integer;
         FLogCallback: pLogCallback;
         FLogClientData: Integer;
         FProgressCallback: pProgressCallback;
         FProgressClientData: Integer;
         FDataLostCallback: pDataLostCallback;
         FDataLostClientData: Integer;
         FSequenceNumber: Integer;
         FCurrentPage: TPage;
         FCurKeyCounter: Integer;
         FCurIndexLevel: Byte;
         FParentPages: array [1..MAX_INDEX_LEVELS] of Integer;
         FIndexKeyCounters: array [1..MAX_INDEX_LEVELS] of Integer;
         FCurRecordNumber: Integer;
         FIndexName: string;
         FIndexPos: Byte;
         FKeySize: Word;
         FKeyFieldCount: Byte;
         FKeyFields: TKeyFields;
         FKeyCompressionType: Byte;
         FKeyDescending: Boolean;
         FKeyUnique: Boolean;
         FKeyCaseInsensitive: Boolean;
         FKeyFieldDefinitions: array [1..MAX_NUM_FLDSINKEY] of pFieldDefinition;
         FKeyDescendingFields: TDescendingKeyFields;
         FNoKeyStatistics: Boolean;
         FEOF: Boolean;
         FBOF: Boolean;
         FBeginSequenceNumber: Integer;
         FEndSequenceNumber: Integer;
         FFilterRecordCount: Integer;
         FBeginBuffer: array [0..MAX_KEYLEN-1] of Char;
         FEndBuffer: array [0..MAX_KEYLEN-1] of Char;
         FRangeInEffect: Boolean;
         FFilterExpressionParser: TExpressionParser;
         FFilterExpressionVerifier: TExpressionVerifier;
         FFilters: TList;
         FFiltersInEffect: Boolean;
         FFilterBitmap: TRecordsBitmap;
         FFilterKeyIndexPos: Integer;
         FFilterKeys: TList;
         FFilterKeyPos: Integer;
         FFilterExecutionTime: double;
         FRangeBitmap: TRecordsBitmap;
         FBlobBuffers: TList;
         FFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
         FLocaleID: Integer;
         FCharMap: TLocaleCharMap;
         FFieldCount: Word;
         FRecordSize: Word;
         FHasValidityChecks: Boolean;
         FHasDefaultValues: Boolean;
         FHasExpressionFields: Boolean;
         FHasAutoIncFields: Boolean;
         FCalculatingFields: Boolean;
         FBookmarkBuffer: array [0..MAX_KEYLEN-1] of Char;
         FRecordCount: Integer;
         FServerSynched: Boolean;
         FLastRequestHeader: TRequestHeader;
         FLocalUnpackPos: Integer;
         FLocalReplyHeader: TReplyHeader;
         FLocalReceiveBuffer: PChar;
         FLocalReceiveBufferSize: Integer;
         FTextStopWords: TLocaleStringList;
         FTextSpaceChars: TCharSet;
         FTextIncludeChars: TCharSet;
         FTextParamsDirty: Boolean;
         FTextParamsRead: Boolean;
         FRecordsToRead: Integer;
         FReadAheadBlocks: Integer;
         FTotalReadAheads: Integer;
         FTotalSizeReadAheads: Integer;
         FRecordIDList: TList;
         FCallbackRecordObject: TObject;
         FCacheDataSession: TDataSession;
         FCacheDataDirectory: TDataDirectory;
         FCacheDataCursor: TDataCursor;
         FCacheErrorClientData: Integer;
         FCacheErrorCallback: pCacheErrorCallback;
         FCacheCallbackRecordObject: TObject;
         FNoCursorChangeDetection: Boolean;
         procedure SetTableName(const Value: string);
         procedure SetErrorTableName(const Value: string);
         function GetProperTableName: string;
         function GetDataSession: TDataSession;
         function GetNextFreePageNumber: Integer;
         procedure SetNextFreePageNumber(Value: Integer);
         function GetRootPageNumber: Integer;
         procedure SetRootPageNumber(Value: Integer);
         function GetDataRootPageNumber: Integer;
         procedure SetDataRootPageNumber(Value: Integer);
         function GetRootPage(var RootPage: TPage; var FoundChanges: Boolean): Boolean;
         procedure GetNextFreePage(var NewPage: TPage);
         procedure GetNextFreeDataPage(var NewDataPage: TPage);
         procedure SetNextFreePage(EmptyPage: TPage);
         function GetDataRootPage(var DataRootPage: TPage): Boolean;
         function GetPage(PageNum: Integer; var PageToGet: TPage): Boolean;
         function GetDataPage(PageNum: Integer; var PageToGet: TPage): Boolean;
         procedure PutPage(PageToRelease: TPage);
         function CreatePage: TPage;
         procedure FreePage(var ExistingPage: TPage);
         function GetIndexKeyCounter: Integer;
         procedure SetIndexKeyCounter(KeyCounter: Integer);
         procedure ClearIndexKeyCounters;
         function GetParentNumber: Integer;
         procedure SetParentNumber(PageNum: Integer);
         procedure ClearParentNumbers;
         procedure IncCurIndexLevel;
         procedure DecCurIndexLevel;
         function CreateRecord: TRecord;
         procedure FreeRecord(var ExistingRecord: TRecord);
         function GetLastRecordID: Integer;
         procedure SetLastRecordID(Value: Integer);
         function GetNextRecordID: Integer;
         function GetLastAutoIncID: Integer;
         procedure SetLastAutoIncID(Value: Integer);
         procedure SetLastBlobSignature(Value: Integer);
         function GetLastBlobSignature: Integer;
         function GetNextBlobSignature: Integer;
         function GetNextFreeRecordNumber: Integer;
         procedure SetNextFreeRecordNumber(Value: Integer);
         procedure GetNextFreeRecord(var NewRecord: TRecord);
         procedure SetNextFreeRecord(EmptyRecord: TRecord);
         function GetRecord(RecordNum: Integer; ReadAhead: Boolean;
                            Direction: Byte; var RecordToGet: TRecord;
                            AssignNumber: Boolean=True): Boolean;
         procedure PutRecord(RecordToRelease: TRecord);
         function GetNextFreeBlockNumber: Integer;
         procedure SetNextFreeBlockNumber(Value: Integer);
         procedure GetNextFreeBlock(var NewBlock: TBlock);
         procedure SetNextFreeBlock(EmptyBlock: TBlock);
         function GetBlock(BlockNum: Integer; ReadAhead: Boolean;
                           ReadAheadBlocks: Integer; var BlockToGet: TBlock): Boolean;
         procedure PutBlock(BlockToRelease: TBlock);
         function GetBlobBlockSize: Integer;
         function GetBlobBlockBufferSize: Integer;
         function GetIndexPageSize: Integer;
         function GetIndexPageBufferSize: Integer;
         function GetLocaleID: Integer;
         function GetUserMajorVersion: Word;
         function GetUserMinorVersion: Word;
         function GetVersionNum: string;
         function GetRecordCount: Integer;
         function GetTotalRecordCount: Integer;
         procedure SetTotalRecordCount(Value: Integer);
         procedure IncTotalRecordCount;
         procedure DecTotalRecordCount;
         function GetInTransaction: Boolean;
         function GetRecordNumber: Integer;
         function GetPhysicalRecordNumber: Integer;
         function GetCurrentRecordBuffer: PChar;
         function GetAutoPrimaryIndex: Boolean;
         function GetIndexCount: Byte;
         procedure SetIndexCount(Value: Byte);
         procedure InternalSetIndexPos(Value: Byte);
         procedure SetIndexPos(Value: Byte);
         procedure SetIndexName(const Value: string);
         function GetBookmarkSize: Word;
         procedure RemoveDuplicateRecord(RecordToRemove: TRecord;
                                         IndexToSkip: Byte);
         function GetPhysicalRecordsUsed: Integer;
         function GetPhysicalPagesUsed: Integer;
         function GetPhysicalBlocksUsed: Integer;
         function GetDescription: string;
         function GetLastUpdated: TDateTime;
         function GetEncrypted: Boolean;
         function GetPassword: string;
         function GetFilterOptimizeLevel: TOptimizeLevel;
         function SearchIndexKeys(Buffer: PChar): Boolean;
         function VerifyIndexKey(Buffer: PChar;
                                 RecordNum: Integer): Boolean;
         function VerifyNextIndexPage(NextPageNum: Integer;
                                      KeyBuffer: PChar;
                                      UpperKeyCount: Integer): Boolean;
         function FindIndexKey(Buffer: PChar; IsSoftSeek: Boolean;
                               RestoreFlags: Boolean): Boolean;
         function FindExactIndexKey(Buffer: PChar): Boolean;
         function FindFilterKey(Buffer: PChar; var RetryPages: Boolean): Boolean;
         function ScanForward(var CurPage: TPage;
                              var SeqNumber: Integer;
                              var KeyCounter: Integer;
                              var RetryPages: Boolean;
                              var PageFound: Boolean): Boolean;
         function ScanBackward(var CurPage: TPage;
                               var SeqNumber: Integer;
                               var KeyCounter: Integer;
                               var RetryPages: Boolean;
                               var PageFound: Boolean): Boolean;
         function RangeScanForward(var CurPage: TPage;
                                   var SeqNumber: Integer;
                                   var KeyCounter: Integer;
                                   var RetryPages: Boolean;
                                   var PageFound: Boolean): Boolean;
         function RangeScanBackward(var CurPage: TPage;
                                    var SeqNumber: Integer;
                                    var KeyCounter: Integer;
                                    var RetryPages: Boolean;
                                    var PageFound: Boolean): Boolean;
         function FilterRangeScanForward(var CurPage: TPage;
                                         var SeqNumber: Integer;
                                         var KeyCounter: Integer;
                                         var RetryPages: Boolean;
                                         var PageFound: Boolean): Boolean;
         function FilterRangeScanBackward(var CurPage: TPage;
                                          var SeqNumber: Integer;
                                          var KeyCounter: Integer;
                                          var RetryPages: Boolean;
                                          var PageFound: Boolean): Boolean;
         function FilterScanForward(var CurPage: TPage;
                                    var SeqNumber: Integer;
                                    var KeyCounter: Integer;
                                    var RetryPages: Boolean;
                                    var PageFound: Boolean): Boolean;
         function FilterScanBackward(var CurPage: TPage;
                                     var SeqNumber: Integer;
                                     var KeyCounter: Integer;
                                     var RetryPages: Boolean;
                                     var PageFound: Boolean): Boolean;
         procedure GotoRecordNumber(Value: Integer);
         procedure GotoPhysicalRecordNumber(Value: Integer);
         function CheckWithinRangeBounds(var CurPage: TPage;
                                         var CurSequenceNumber: Integer;
                                         var CurKeyCounter: Integer;
                                         var FoundChanges: Boolean): Boolean;
         procedure ResetIndexPosition;
         procedure GotoFirstIndexPosition;
         procedure GotoLastIndexPosition;
         procedure SetBeginIndexRange(Buffer: PChar);
         procedure SetEndIndexRange(Buffer: PChar);
         procedure ActivateRange;
         procedure CancelRange;
         procedure UpdateRange;
         procedure AddFilterHandle(FilterHandle: Pointer;
                                   UseExisting: Boolean);
         procedure ActivateAllFilters;
         procedure DeactivateAllFilters;
         procedure DropAllFilters;
         procedure CheckForActiveFilters;
         function UpdateFilter(FilterToUpdate: TFilter): Integer;
         procedure UpdateAllFilters;
         procedure RebuildFilterBitmap;
         procedure RebuildFilterKeys;
         { Version 5 }
         function VerifyRecordInSet(RecordToVerify: Integer;
                                    RecordBuffer: PChar): Boolean;
         { Version 5 }
         procedure UpdateRecordInBitmap(RecordToUpdate: Integer;
                                        RecordBuffer: PChar);
         procedure UpdateRecordFilterKey(RecordToUpdate: Integer;
                                         RecordBuffer: PChar;
                                         OldRecordBuffer: PChar);
         procedure DeleteRecordInBitmap(RecordDeleted: Integer);
         procedure DeleteRecordFilterKey(RecordBuffer: PChar);
         procedure UpdateRangeBitmap;
         function GetNumReadAheadRecords(MaxNumReadAheadRecords: Integer;
                                         Direction: Byte): Integer;
         function CountSequentialPhysicalRecords(MaxNumRecords: Integer;
                                                 Direction: Byte): Integer;
         function GetBlockCount(TotalBytes: Integer): Integer;
         function GetNumReadAheadBlocks(MaxNumReadAheadBlocks: Integer;
                                        Direction: Byte): Integer;
         function IsUniqueIndex(UniquePos: Byte): Boolean;
         function CheckForKeyViolation(BufferToCheck: PChar): Boolean;
         procedure RaiseKeyViolationError;
         procedure AddIndexKey(NewBuffer: PChar; NewRecord: Integer);
         procedure UpdateIndexKey(OldBuffer: PChar;
                                  NewBuffer: PChar;
                                  NewRecord: Integer);
         procedure RemoveIndexKey(OldBuffer: PChar);
         { Version 5 }
         procedure VerifyPhysicalRecordPosition;
         procedure VerifyRecordPosition;
         { Version 5 }
         function GetKey: PChar;
         procedure SkipIndexKeys(Value: Integer);
         function CountIndexedRecords(FirstBuffer: PChar;
                                      SecondBuffer: PChar): Integer;
         procedure NavigateIndexedRecords(FirstBuffer: PChar;
                                          SecondBuffer: PChar;
                                          Bitmap: TRecordsBitmap);
         { Version 5 }
         procedure NavigateNonIndexedRecords(Bitmap: TRecordsBitmap;
                                             NextToken: TExpToken;
                                             UpperFilterOperator: TExpOperator;
                                             ClientFilterData: Integer;
                                             CallbackFilterFunction: pFilterFunction);
         { Version 5 }
         procedure NavigateNonDeletedRecords(Bitmap: TRecordsBitmap);
         { Version 5 }
         function EvaluateFilterForRecord(RecordBuffer: PChar;
                                          RecordNum: Integer;
                                          Bitmap: TRecordsBitmap;
                                          NextToken: TExpToken;
                                          ClientFilterData: Integer;
                                          CallbackFilterFunction: pFilterFunction): Boolean;
         { Version 5 }
         function EvaluateFilterFieldData(RecordBuffer: PChar;
                                          FieldToken: TExpToken): Boolean;
         procedure BuildRangeFromConstant(Operator: TExpOperator;
                                          DataType: Byte;
                                          DataSize: Word;
                                          PartialLength: Word;
                                          FirstBuffer: PChar;
                                          SecondBuffer: PChar;
                                          IsNull: Boolean;
                                          IncludeNulls: Boolean);
         procedure SetLowBytes(Buffer: PChar; EndByte: Word);
         procedure SetHighBytes(Buffer: PChar; EndByte: Word);
         procedure FillAllLowBytes(Buffer: PChar);
         procedure FillAllHighBytes(Buffer: PChar);
         procedure IncKeyBuffer(KeyBuffer: PChar; OriginalBuffer: PChar;
                                DataType: Byte; DataSize: Word);
         procedure DecKeyBuffer(KeyBuffer: PChar; OriginalBuffer: PChar;
                                DataType: Byte; DataSize: Word);
         procedure IncLastByte(Buffer: PChar; var LastByte: Word;
                               TotalSize: Word);
         procedure DecLastByte(Buffer: PChar; var LastByte: Word;
                               TotalSize: Word);
         function GetIndexFieldDataType(SearchOffset: Word): Byte;
         function GetIndexFieldDescending(SearchOffset: Word): Boolean;
         function EqualToFirstChar(SourceChar: Char): Boolean;
         function EqualToLastChar(SourceChar: Char): Boolean;
         function GetPriorChar(SourceChar: Char): Char;
         function GetNextChar(SourceChar: Char): Char;
         function GetCharMapPos(SourceChar: Char): Byte;
         function GotoRightPage(var CurPage: TPage; var FoundChanges: Boolean;
                                var KeyCounter: Integer): Boolean;
         function GotoLeftPage(var CurPage: TPage; var FoundChanges: Boolean;
                               var KeyCounter: Integer): Boolean;
         procedure InsertScan(Page: TPage; KeyBuffer: PChar;
                               var KeyCounter: Integer);
         procedure BeginIndexKeyInsert(NewBuffer: PChar; NewRecord: Integer);
         procedure InsertIndexKey(InsertPage: TPage;
                                  NewBuffer: PChar; NewRecord: Integer;
                                  NewCount: Integer);
         procedure SplitPage(InsertPage: TPage; SplitPage: TPage);
         procedure UpdateUpperIndexKeys(UpdatePage: TPage; NewBuffer: PChar);
         procedure DeleteScan(Page: TPage; KeyBuffer: PChar;
                              var KeyCounter: Integer);
         procedure BeginIndexKeyDelete(OldBuffer: PChar);
         procedure DeleteIndexKey(DeletePage: TPage);
         procedure BalanceLeftPage(DeletePage: TPage; LeftPage: TPage);
         procedure BalanceRightPage(DeletePage: TPage; RightPage: TPage);
         procedure MergeLeftPage(DeletePage: TPage; LeftPage: TPage);
         procedure MergeRightPage(DeletePage: TPage; RightPage: TPage);
         function SearchScan(Page: TPage; KeyBuffer: PChar;
                             var KeyCounter: Integer;
                             CompareLength: Word): Boolean;
         function FindScan(Page: TPage; KeyBuffer: PChar;
                            var SeqNumber: Integer; var KeyCounter: Integer;
                           IsSoftSeek: Boolean): Boolean;
         function FindRangeScan(Page: TPage; KeyBuffer: PChar;
                                EndBuffer: PChar; var SeqNumber: Integer;
                                var KeyCounter: Integer; IsSoftSeek: Boolean): Boolean;
         function GotoRecordScan(Page: TPage; Value: Integer;
                                        var SeqNumber: Integer;
                                        var KeyCounter: Integer): Boolean;
         procedure FirstScan(Page: TPage; var SeqNumber: Integer; var KeyCounter: Integer);
         procedure LastScan(Page: TPage; var SeqNumber: Integer; var KeyCounter: Integer);
         procedure FirstRangeScan(Page: TPage; var SeqNumber: Integer;
                                  var KeyCounter: Integer; BeginBuffer: PChar);
         procedure LastRangeScan(Page: TPage; var SeqNumber: Integer;
                                 var KeyCounter: Integer; EndBuffer: PChar);
         procedure BeginScan(Page: TPage; var KeyCounter: Integer; BeginBuffer: PChar);
         procedure EndScan(Page: TPage; var KeyCounter: Integer; EndBuffer: PChar);
         procedure BeginRangeScan(Page: TPage; var BeginSeqNumber: Integer;
                                  var KeyCounter: Integer; BeginBuffer: PChar);
         procedure EndRangeScan(Page: TPage; var EndSeqNumber: Integer;
                                var KeyCounter: Integer; EndBuffer: PChar);
         procedure FilterSetIndexedBits(var Page: TPage;
                                        Bitmap: TRecordsBitmap;
                                        EndBuffer: PChar;
                                        var KeyCounter: Integer;
                                        var RetryFilter: Boolean);
         function CountSequentialRecords(Page: TPage; MaxNumRecords: Integer;
                                         Direction: Byte; KeyCounter: Integer): Integer;
         procedure InternalUpdateKeyInformation;
         function GetIsPhysicalNavigation: Boolean;
         procedure DeleteNextIndexPage(NextPageNum: Integer);
         procedure RepairHeaders(VerifyOnly: Boolean; var DataValid: Boolean;
                                 var IndexValid: Boolean; var BlobValid: Boolean);
         procedure UpdateDataHeader(NewLocaleID: Integer;
                                    NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                    NewEncrypted: Boolean; const NewPassword: string;
                                    const NewDescription: string;
                                    NewIndexPageSize: Integer;
                                    NewBlobBlockSize: Integer;
                                    NewLastAutoIncID: Integer);
         procedure SetIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
         procedure UpdateIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
         function CompareKeys(FirstKeyBuffer: PChar;
                              SecondKeyBuffer: PChar;
                              CompareLength: Word): Integer;
         function CompareNumbers(FirstNumber: Integer;
                                 SecondNumber: Integer): Integer;
         procedure CalculateExpressionFields(RecordBuffer: PChar);
         function EvaluateCalculatedFieldData(RecordBuffer: PChar;
                                              FieldToken: TExpToken): Boolean;
         procedure FreeFieldDefinitions;
         procedure FreeFilterKeys;
         function SearchFilterKeys(KeyBuffer: PChar; var BufferIndex: Integer): Boolean;
         procedure VerifyStructureInformation(NewLocaleID: Integer;
                                              NewEncrypted: Boolean;
                                              NewPassword: string;
                                              NewIndexPageSize: Integer;
                                              NewBlobBlockSize: Integer;
                                              NewLastAutoIncID: Integer;
                                              NumberOfFields: Word;
                                              const FieldDefinitions: array of pFieldDefinition;
                                              NumberOfIndexes: Byte;
                                              const IndexDefinitions: array of pIndexDefinition;
                                              AllowExpressionFields: Boolean);
         procedure VerifyFieldInformation(UpdateOffsets: Boolean;
                                          NumberOfFields: Word;
                                          const FieldDefinitions: array of pFieldDefinition;
                                          AllowExpressionFields: Boolean);
         procedure VerifyIndexInformation(NewLocaleID: Integer;
                                          NewIndexPageSize: Integer;
                                          NumberOfFields: Word;
                                          const FieldDefinitions: array of pFieldDefinition;
                                          NumberOfIndexes: Byte;
                                          const IndexDefinitions: array of pIndexDefinition);
         function FieldDefinitionHasChanged(OldFieldDefinition: pFieldDefinition;
                                            NewFieldDefinition: pFieldDefinition): Boolean;
         function IndexDefinitionHasChanged(OldIndexDefinition: pIndexDefinition;
                                            NewIndexDefinition: pIndexDefinition;
                                            NewNumberOfFields: Word;
                                            const NewFieldDefinitions: array of pFieldDefinition): Boolean;
         procedure ResetFieldNumbers;
         procedure ResetIndexFieldNumbers(IndexDefinition: pIndexDefinition);
         function CheckField(FieldExpression: string;
                             FieldExpressionType: TFieldExpressionType;
                             FieldBuffer: PChar; FieldType: Byte): Boolean;
         procedure InternalGetField(FieldDefinition: pFieldDefinition;
                                    RecordBuffer: PChar; FieldBuffer: PChar;
                                    var IsBlank: Boolean);
         procedure InternalPutField(FieldDefinition: pFieldDefinition;
                                    RecordBuffer: PChar; FieldBuffer: PChar;
                                    WriteToExpressions: Boolean; BlobEmpty: Boolean);
         function GetPhysicalRecordSize: Word;
         function GetPhysicalFieldCount: Word;
         function GetBlobFieldCount: Word;
         function GetTableSize: Int64;
         function GetDataFileSize: Int64;
         function GetIndexFileSize: Int64;
         function GetBlobFileSize: Int64;
         function HasCallbackFilters: Boolean;
         function ParseFilter(FilterExpr: PChar): TExpToken;
         procedure VerifyFilter(FilterTokens: TExpToken);
         procedure NormalizeFilter(NextToken: TExpToken);
         function VerifyFilterFieldData(FieldToken: TExpToken): Boolean;
         procedure RebuildMissingIndex;
         procedure AddAutoPrimaryIndex;
         procedure CheckForCursorChanges;
         procedure CheckForChangeDetection;
         function GetLastRequestCode: Word;
         procedure SetRequestCode(Value: Word);
         function GetResultCode: Word;
         procedure Send;
         procedure SendReceive;
         procedure Receive;
         procedure SaveReceiveBuffer;
         procedure StartRemoteRequest;
         procedure EndRemoteRequest;
         procedure BeginPack;
         procedure Pack(const Buffer; BufferSize: Integer);
         procedure EndPack;
         function Unpack(var Buffer): Integer;
         function LocalUnpack(var Buffer): Integer;
         function SkipLocalUnpack: Integer;
         function RemainingLocalReplySize: Integer;
         function GetIsRemote: Boolean;
         function GetIsEncrypted: Boolean;
         function GetConnected: Boolean;
         procedure UnpackException;
         procedure CheckForException;
         procedure CheckForConnection;
         procedure UnpackStaticTableInfo;
         procedure UnpackVariableTableInfo;
         procedure LocalUnpackVariableTableInfo;
         procedure PackTextIndexParams(StopWords: TStrings;
                                       SpaceChars: TCharSet; IncludeChars: TCharSet);
         procedure UnpackTextIndexParams;
         procedure LocalUnpackCursorInfo;
         procedure GetPhysicalFields;
         function GetProgressPercent: Word;
         function GetProperDataDirectoryName: string;
         procedure ResizeLocalReceiveBuffer(Value: Integer);
         function GetRemoteEngineVersion: Currency;
         { Version 5 }
         function GetRemoteEngineBuildNumber: Integer;
         { Version 5 }
         procedure AddTextIndexes(NewRecord: TRecord);
         function VerifyTextIndexes(CurRecord: TRecord): Boolean;
         procedure CreateTextIndexes(CurRecord: TRecord);
         function ModifyTextIndexes(CurRecord: TRecord; OldRecord: TRecord): Boolean;
         procedure RemoveTextIndexes(CurRecord: TRecord);
         function IsTextIndexed(FieldNumber: Word): Boolean;
         procedure CreateWordsList(const TableName: string; const FieldName: string;
                                   WordBuffer: PChar; WordBufferSize: Integer;
                                   WordsList: TLocaleStringList; AllowPartialWords: Boolean);
         procedure AddTextKeyValues(FieldNum: Word; const FieldName: string;
                                    WordBuffer: PChar; WordBufferSize: Integer;
                                    RecordID: Integer; RecordNum: Integer);
         function ModifyTextKeyValues(FieldNum: Word; const FieldName: string;
                                      WordBuffer: PChar; WordBufferSize: Integer;
                                      OldWordBuffer: PChar; OldWordBufferSize: Integer;
                                      RecordID: Integer; OldRecordID: Integer;
                                      RecordNum: Integer): Boolean;
         procedure RemoveTextKeyValues(FieldNum: Word; const FieldName: string;
                                       WordBuffer: PChar; WordBufferSize: Integer;
                                       RecordID: Integer);
         function VerifyTextKeyValues(FieldNum: Word; const FieldName: string;
                                      WordBuffer: PChar; WordBufferSize: Integer;
                                      RecordID: Integer; RecordNum: Integer): Boolean;
         procedure ReadTextIndexParams;
         procedure CheckForNextDataPage(SizeToRead: Integer; var CurPos: Integer;
                                        var CurPage: TPage);
         procedure SetTextIndexParams(StopWords: TStrings; SpaceChars: TCharSet;
                                      IncludeChars: TCharSet);
         procedure WriteTextIndexParams;
         procedure CheckForNewDataPage(SizeToWrite: Integer; var CurPos: Integer;
                                       var CurPage: TPage);
         function GetTextStopWords: TLocaleStringList;
         function GetTextSpaceChars: TCharSet;
         function GetTextIncludeChars: TCharSet;
         function ReadMoreRecords(CurRequestCode: Word): Boolean;
         function PopulateRecordBlockForward(StartRow: Integer; var NumRecords: Integer;
                                             RecordsBuffer: PChar; BookmarksBuffer: PChar): Word;
         function PopulateRecordBlockBackward(var NumRecords: Integer; RecordsBuffer: PChar;
                                               BookmarksBuffer: PChar; ShiftBuffers: Boolean): Word;
         function IndexLocate(NewIndexPos: Byte; Buffer: PChar;
                              SearchFieldCount: Integer;
                                IsSoftSeek: Boolean; PartialLength: Word;
                              NewRecordBuffer: PChar): Boolean;
         function FilterLocate(NumberOfFields: Word; Fields: TKeyFields;
                                 RecordBuffer: PChar; IsCaseInsensitive: Boolean;
                                 LastPartialLength: Word; NewRecordBuffer: PChar): Boolean;
         procedure GetNextIndexPageFreeSpaceStats(NextPageNum: Integer;
                                                  var InternalCount: Integer;
                                                  var InternalSpace: Integer;
                                                  var ExternalCount: Integer;
                                                  var ExternalSpace: Integer);
         procedure GetNextIndexPageSpaceStats(NextPageNum: Integer;
                                              var InternalCount: Integer;
                                              var InternalSpace: Integer;
                                              var ExternalCount: Integer;
                                              var ExternalSpace: Integer;
                                              var KeyCount: Integer);
         procedure VerifyBlobHandle(var BlobHandle: Integer;
                                    var BlobBufferPos: Integer);
         { Version 5 }
         procedure ReadBlob(BlobBuffer: TBlobBuffer; var RetryBlob: Boolean);
         { Version 5 }
         procedure WriteBlob(BlobBuffer: TBlobBuffer);
         procedure RemoveBlob(BlobBuffer: TBlobBuffer);
         procedure FreeNextBlocks(BlobBuffer: TBlobBuffer;
                                  StartFromBlock: TBlock;
                                  NumBlocks: Integer);
         function RepairBlob(VerifyOnly: Boolean;
                             var BlobBlock: Integer;
                             BlobSignature: Integer;
                             RecordNum: Integer;
                             RecordID: Integer;
                             FixBlobSignatures: Boolean): Boolean;
         function FlushBlobBuffers: Boolean;
         procedure FreeBlobCopies(RecordBuffer: PChar;
                                  UsePhysicalFields: Boolean);
         function FindRecordID(RecordID: Integer; var RecordIDIndex: Integer): Boolean;
         function ConvertExpressionToAnsi(const ExprStr: string;
                                          FieldType: Word): string;
         procedure FreeCachedUpdates;
         { Version 5 }
         function InternalReadLockTable: Boolean;
         { Version 5 }
      public
         constructor Create(Owner: TDataDirectory;
                            NoRemoteCall: Boolean); reintroduce; overload; virtual;
         destructor Destroy; override;
         property DataSession: TDataSession read GetDataSession;
         property DataDirectory: TDataDirectory read FDataDirectory;
         property ProperDataDirectoryName: string read GetProperDataDirectoryName;
         property Exclusive: Boolean read FExclusive write FExclusive;
         property ReadOnly: Boolean read FReadOnly write FReadOnly;
         property MarkedReadOnly: Boolean read FMarkedReadOnly;
         property TableName: string read FTableName write SetTableName;
         property ErrorTableName: string read FErrorTableName write SetErrorTableName;
         property ProperTableName: string read GetProperTableName;
         property IsOpen: Boolean read FIsOpen;
         property DataTable: TDataTable read FDataTable;
         property CurrentRecord: TRecord read FCurrentRecord;
         property LastRecord: TRecord read FLastRecord;
         property CurrentPage: TPage read FCurrentPage;
         property BlobBuffers: TList read FBlobBuffers;
         property IsRemote: Boolean read GetIsRemote;
         property IsEncrypted: Boolean read GetIsEncrypted;
         property RemoteID: Integer read FRemoteID write FRemoteID;
         property Connected: Boolean read GetConnected;
         property Temporary: Boolean read FTemporary write FTemporary;
         { Version 5 }
         property SystemOpen: Boolean read FSystemOpen write FSystemOpen;
         { Version 5 }
         property CachedUpdates: Boolean read FCachedUpdates write FCachedUpdates;
         property ResultSet: Boolean read FResultSet write FResultSet;
         property SourceTable: Boolean read FSourceTable write FSourceTable;
         property HasValidityChecks: Boolean read FHasValidityChecks;
         property HasDefaultValues: Boolean read FHasDefaultValues;
         property HasExpressionFields: Boolean read FHasExpressionFields;
         property HasAutoIncFields: Boolean read FHasAutoIncFields;
         property Description: string read GetDescription;
         property LastUpdated: TDateTime read GetLastUpdated;
         property Encrypted: Boolean read GetEncrypted;
         property Password: string read GetPassword;
         property InTransaction: Boolean read GetInTransaction;
         property Repairing: Boolean read FRepairing;
         property AlteringStructure: Boolean read FAlteringStructure
                                             write FAlteringStructure;
         property SuppressRecordIDs: Boolean read FSuppressRecordIDs
                                             write FSuppressRecordIDs;
         property SuppressTriggers: Boolean read FSuppressTriggers
                                            write FSuppressTriggers;
         property RecordNumber: Integer read GetRecordNumber;
         property PhysicalRecordNumber: Integer read GetPhysicalRecordNumber;
         property CurrentRecordBuffer: PChar read GetCurrentRecordBuffer;
         property RecordSize: Word read FRecordSize;
         property PhysicalRecordSize: Word read GetPhysicalRecordSize;
         property BookmarkSize: Word read GetBookmarkSize;
         property RecordCount: Integer read GetRecordCount;
         property TotalRecordCount: Integer read GetTotalRecordCount
                                            write SetTotalRecordCount;
         property PhysicalRecordsUsed: Integer read GetPhysicalRecordsUsed;
         property PhysicalPagesUsed: Integer read GetPhysicalPagesUsed;
         property PhysicalBlocksUsed: Integer read GetPhysicalBlocksUsed;
         property LastRecordID: Integer read GetLastRecordID
                                        write SetLastRecordID;
         property NextRecordID: Integer read GetNextRecordID;
         property LastAutoIncID: Integer read GetLastAutoIncID
                                        write SetLastAutoIncID;
         property LastBlobSignature: Integer read GetLastBlobSignature
                                             write SetLastBlobSignature;
         property NextBlobSignature: Integer read GetNextBlobSignature;
         property NextFreeRecordNumber: Integer read GetNextFreeRecordNumber
                                            write SetNextFreeRecordNumber;
         property FieldCount: Word read FFieldCount;
         property PhysicalFieldCount: Word read GetPhysicalFieldCount;
         property BlobFieldCount: Word read GetBlobFieldCount;
         property BlobBlockSize: Integer read GetBlobBlockSize;
         property BlobBlockBufferSize: Integer read GetBlobBlockBufferSize;
         property IndexPageSize: Integer read GetIndexPageSize;
         property IndexPageBufferSize: Integer read GetIndexPageBufferSize;
         property LocaleID: Integer read GetLocaleID;
         property UserMajorVersion: Word read GetUserMajorVersion;
         property UserMinorVersion: Word read GetUserMinorVersion;
         property VersionNum: string read GetVersionNum;
         property IndexCount: Byte read GetIndexCount write SetIndexCount;
         property AutoPrimaryIndex: Boolean read GetAutoPrimaryIndex;
         property IndexPos: Byte read FIndexPos write SetIndexPos;
         property IndexName: string read FIndexName write SetIndexName;
         property KeySize: Word read FKeySize;
         property KeyUnique: Boolean read FKeyUnique;
         property KeyFieldCount: Byte read FKeyFieldCount;
         property KeyDescending: Boolean read FKeyDescending;
         property KeyCaseInsensitive: Boolean read FKeyCaseInsensitive;
         property NoKeyStatistics: Boolean read FNoKeyStatistics;
         property CompressionType: Byte read FKeyCompressionType;
         property RangeInEffect: Boolean read FRangeInEffect write FRangeInEffect;
         property Filters: TList read FFilters;
         property FiltersInEffect: Boolean read FFiltersInEffect write FFiltersInEffect;
         property FilterOptimizeLevel: TOptimizeLevel read GetFilterOptimizeLevel;
         property FilterExecutionTime: double read FFilterExecutionTime;
         property IsEOF: Boolean read FEOF write FEOF;
         property IsBOF: Boolean read FBOF write FBOF;
         property IsPhysicalNavigation: Boolean read GetIsPhysicalNavigation;
         property TableSize: Int64 read GetTableSize;
         property DataFileSize: Int64 read GetDataFileSize;
         property IndexFileSize: Int64 read GetIndexFileSize;
         property BlobFileSize: Int64 read GetBlobFileSize;
         property CurIndexLevel: Byte read FCurIndexLevel write FCurIndexLevel;
         property ProgressPercent: Word read GetProgressPercent;
         property ServerSynched: Boolean read FServerSynched write FServerSynched;
         property RemoteEngineVersion: Currency read GetRemoteEngineVersion;
         { Version 5 }
         property RemoteEngineBuildNumber: Integer read GetRemoteEngineBuildNumber;
         { Version 5 }
         property TextStopWords: TLocaleStringList read GetTextStopWords;
         property TextSpaceChars: TCharSet read GetTextSpaceChars;
         property TextIncludeChars: TCharSet read GetTextIncludeChars;
         property RecordsToRead: Integer read FRecordsToRead write FRecordsToRead;
         property CallbackRecordObject: TObject read FCallbackRecordObject
                                                write FCallbackRecordObject;
         property CacheCallbackRecordObject: TObject read FCacheCallbackRecordObject
                                                     write FCacheCallbackRecordObject;
         property NoCursorChangeDetection: Boolean read FNoCursorChangeDetection
                                                   write FNoCursorChangeDetection;
         procedure CheckCallbacks(NewClientData: Integer);
         procedure DoSteppedProgress(const Step: string; PercentDone: Word);
         procedure DoLog(const LogMessage: string);
         procedure DoProgress(PercentDone: Word);
         procedure DoDataLost(Cause: Byte; const ContextInfo: string;
                              var Continue: Boolean;
                              var StopAsking: Boolean);
         procedure UnpackCursorInfo;
         procedure UnpackResultSetInfo;
         procedure UnpackResultSetFields;
         procedure UnpackResultSetCursorInfo;
         procedure SetDefaultFieldMapping;
         procedure OpenCursor(NoRemoteCall: Boolean);
         procedure CloseCursor(FreeIfTemporary: Boolean);
         function PerformChangeDetection: Boolean;
         procedure RefreshCurrentRecord(Direction: Byte);
         procedure SetCurrentRecord(RecNumber: Integer);
         procedure ReadLockTable;
         procedure ReadUnlockTable;
         procedure WriteLockTable;
         procedure WriteUnlockTable;
         function RecordIsLocked: Boolean;
         function TableIsLocked: Boolean;
         procedure LockRecord(RecordToLock: Integer);
         procedure UnlockRecord(RecordToUnlock: Integer;
                                NoRemoteCall: Boolean);
         procedure LockTable;
         procedure UnlockTable;
         function LockSemaphore(SemaphoreToLock: Integer): Boolean;
         function UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
         procedure CreateTable(NewLocaleID: Integer;
                               NewUserMajorVersion: Word;
                               NewUserMinorVersion: Word;
                               NewEncrypted: Boolean;
                               NewPassword: string;
                               NewDescription: string;
                               NewIndexPageSize: Integer;
                               NewBlobBlockSize: Integer;
                               NewLastAutoIncID: Integer;
                               NewTextIndexStopWords: TStrings;
                               const NewTextIndexSpaceChars: TCharSet;
                               const NewTextIndexIncludeChars: TCharSet;
                               OverwriteExisting: Boolean;
                               NumberOfFields: Word;
                               const FieldDefinitions: array of pFieldDefinition;
                               NumberOfIndexes: Byte;
                               const IndexDefinitions: array of pIndexDefinition);
         function ImportTable(const FileToImport: string;
                              Delimiter: Char;
                              NumberOfFields: Word;
                              var FieldDefinitions: array of pFieldDefinition;
                              const DateFormat: string;
                              const TimeFormat: string;
                              DecSeparator: Char;
                              ReadHeaders: Boolean;
                              SendProgress: Boolean): Integer;
         function ExportTable(const ExportToFile: string;
                              Delimiter: Char;
                              NumberOfFields: Word;
                              const FieldDefinitions: array of pFieldDefinition;
                              const DateFormat: string;
                              const TimeFormat: string;
                              DecSeparator: Char;
                              WriteHeaders: Boolean;
                              SendProgress: Boolean): Integer;
         procedure LoadFromStream(SourceBuffer: PChar;
                                  SourceBufferSize: Integer;
                                  Mode: Byte;
                                  SendProgress: Boolean;
                                  SendErrors: Boolean);
         procedure SaveToStream(var DestBuffer: PChar;
                                var DestBufferSize: Integer;
                                Mode: Byte;
                                SendProgress: Boolean);
         procedure AlterTable(NewLocaleID: Integer;
                              NewUserMajorVersion: Word;
                              NewUserMinorVersion: Word;
                              NewEncrypted: Boolean;
                              NewPassword: string;
                              NewDescription: string;
                              NewIndexPageSize: Integer;
                              NewBlobBlockSize: Integer;
                              NewLastAutoIncID: Integer;
                              NewTextIndexStopWords: TStrings;
                              const NewTextIndexSpaceChars: TCharSet;
                              const NewTextIndexIncludeChars: TCharSet;
                              SuppressBackups: Boolean;
                              SendProgress: Boolean; SendDataLost: Boolean;
                              NumberOfFields: Word;
                              const FieldDefinitions: array of pFieldDefinition;
                              NumberOfIndexes: Byte;
                              const IndexDefinitions: array of pIndexDefinition);
         function RepairTable(VerifyOnly: Boolean; FixBlobSignatures: Boolean;
                              SendProgress: Boolean; SendLog: Boolean;
                              ForceIndexRebuild: Boolean): Boolean;
         procedure UpgradeTable(SendProgress: Boolean; SendLog: Boolean);
         procedure EmptyTable;
         procedure EmptyIndex;
         procedure DeleteTable;
         procedure RenameTable(const NewTableName: string);
         procedure InternalBackupTable;
         procedure InternalRestoreTable(ActualDataDirectory: TDataDirectory;
                                        const ActualTableName: string);
         procedure InternalBackupIndex(TempDataDirectory: TDataDirectory);
         procedure InternalRestoreIndex(TempDataDirectory: TDataDirectory;
                                        RemoveOnly: Boolean; RemoveBackup: Boolean);
         function OptimizeTable(const OptimizeIndexName: string;
                                SuppressBackups: Boolean;
                                SendProgress: Boolean): Integer;
         procedure CopyTable(const NewDataDirectoryName: string;
                             const NewTableName: string; CopyIndexes: Boolean;
                             SendProgress: Boolean);
         procedure CheckError(ErrorCode: Word; const ErrorMsg: string);
         procedure SetToBegin;
         procedure SetToEnd;
         function SetToRecordNumber(Value: Integer): Boolean;
         function GetRecordStatus(RecordBuffer: PChar): Byte;
         procedure PutRecordStatus(RecordStatus: Byte; RecordBuffer: PChar);
         function GetRecordNo(RecordBuffer: PChar): Integer;
         procedure PutRecordNo(Value: Integer; RecordBuffer: PChar);
         function GetRecordID(RecordBuffer: PChar): Integer;
         procedure PutRecordID(Value: Integer; RecordBuffer: PChar);
         function GetRecordHash(RecordBuffer: PChar): TMD5Digest;
         procedure PutRecordHash(Value: TMD5Digest; RecordBuffer: PChar);
         procedure InitRecord(RecordBuffer: PChar);
         procedure ClearRecord(RecordBuffer: PChar);
         procedure CheckRecordValidity(RecordBuffer: PChar);
         procedure SetAutoIncFields(RecordBuffer: PChar; Increment: Boolean);
         procedure SetRecordID(RecordBuffer: PChar; Increment: Boolean);
         function CalcRecordHash(RecordBuffer: PChar): TMD5Digest;
         function GetCurrentRecord(RecordBuffer: PChar; LockIt: Boolean): Word;
         function CloneCurrentRecord(RecordBuffer: PChar): Word;
         function GetNextRecord(RecordBuffer: PChar): Word;
         function GetPriorRecord(RecordBuffer: PChar): Word;
         function ReadNextRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                      BookmarksBuffer: PChar): Word;
         function ReadPriorRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                       BookmarksBuffer: PChar): Word;
         function ReadFirstRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                       BookmarksBuffer: PChar): Word;
         function ReadLastRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                      BookmarksBuffer: PChar): Word;
         function ReadAbsoluteRecordBlock(ReadOffset: Integer;
                                          var NumRecords: Integer; RecordsBuffer: PChar;
                                           BookmarksBuffer: PChar): Word;
         function ReadBookmarkRecordBlock(ReadOffset: Integer; BookmarkBuffer: PChar;
                                          ResetPosition: Boolean;
                                          var NumRecords: Integer; RecordsBuffer: PChar;
                                          BookmarksBuffer: PChar): Word;
         procedure RefreshRecordBlock(NumRecords: Integer;
                                      RecordsBuffer: PChar; BookmarksBuffer: PChar);
         procedure AddRecordBlock(var RecordsAdded: Integer; ParamRecordBuffer: PChar;
                                  RecordBuffer: PChar; BookmarkBuffer: PChar);
         procedure UpdateRecordBlock(var RecordsUpdated: Integer; ParamRecordBuffer: PChar;
                                     RecordBuffer: PChar; BookmarkBuffer: PChar);
         procedure DeleteRecordBlock(NumRecords: Integer; var RecordsDeleted: Integer;
                                     RecordsBuffer: PChar; BookmarksBuffer: PChar);
         procedure ModifyRecord(RecordBuffer: PChar; UnlockIt: Boolean;
                                RefreshFilter: Boolean;
                                SkipKeyChecks: Boolean=False);
         procedure CancelRecord;
         procedure AppendRecord(RecordBuffer: PChar; RefreshFilter: Boolean;
                                SetRecordHash: Boolean=True;
                                SkipKeyChecks: Boolean=False;
                                SkipAutoInc: Boolean=False;
                                CopyRecordNo: Boolean=False);
         procedure DeleteRecord(RecordBuffer: PChar; RefreshFilter: Boolean);
         function GetFieldDefinition(FieldNum: Word): pFieldDefinition;
         function GetPhysicalFieldDefinition(FieldNum: Word): pFieldDefinition;
         function GetPhysicalFieldDefinitionForFieldName(const NameOfField: string): pFieldDefinition;
         function FieldExists(NameOfField: string): Boolean;

         function GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
         function GetPhysicalFieldDefinitionByName(NameOfField: string): pFieldDefinition;
         function GetPhysicalFieldNumber(NameOfField: string): Word;
         function GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
         function GetPhysicalFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
         function GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
         function GetPhysicalFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
         procedure UpdateFieldDefinitionByPos(FieldIndex: Word;
                                              Buffer: pFieldDefinition);
         procedure UpdatePhysicalFieldDefinitionByPos(FieldIndex: Word;
                                                       Buffer: pFieldDefinition);
         procedure GetField(FieldNum: Word; RecordBuffer: PChar;
                            FieldBuffer: PChar; var IsBlank: Boolean);
         procedure PutField(FieldNum: Word; RecordBuffer: PChar;
                            FieldBuffer: PChar; WriteToExpressions: Boolean;
                            BlobEmpty: Boolean);
         procedure GetPhysicalField(FieldNum: Word;
                                    RecordBuffer: PChar; FieldBuffer: PChar;
                                    var IsBlank: Boolean);
         procedure PutPhysicalField(FieldNum: Word; RecordBuffer: PChar;
                                    FieldBuffer: PChar; BlobEmpty: Boolean);
         function GetIndexDefinition(CurIndexPos: Byte): pIndexDefinition;
         function IndexExists(const NewName: string): Boolean;
         procedure ForceRefresh;
         procedure Refresh;
         procedure VerifyBookmarkPosition(BookmarkBuffer: PChar;
                                          WasBOF: Boolean; WasEOF: Boolean);
         procedure GetBookmark(BookmarkBuffer: PChar);
         procedure ClearBookmark(BookmarkBuffer: PChar);
         function SetToBookmark(BookmarkBuffer: PChar; NearSet: Boolean;
                                SuppressChangeDetection: Boolean): Boolean;
         function CompareBookmarks(FirstBuffer: PChar; SecondBuffer: PChar): Integer;
         procedure GetKeyValues(RecordBuffer: PChar;
                                KeyBuffer: PChar);
         function ChangeToIndexForFields(FieldNum: Word;
                                        IsCaseInsensitive: Boolean;
                                        AnyIndex: Boolean): Boolean;
         function GetOptimizationCount(Operator: TExpOperator;
                                       FieldToken: TExpToken;
                                       ConstantToken: TExpToken;
                                       PartialLength: Word): Integer;
         function GetTextSearchOptimizationCount(FieldNum: Word;
                                                 const FieldName: string;
                                                 WordBuffer: PChar;
                                                 WordBufferSize: Integer): Integer;
         { Version 5 }
         function CompareCurrentRecordToKey(KeyBuffer: PChar;
                                            CompareLength: Word): Boolean;
         { Version 5 }
         function Find(KeyProvided: Boolean; Buffer: PChar;
                       SearchFieldCount: Integer;
                       IsSoftSeek: Boolean; PartialLength: Word;
                       NewRecordBuffer: PChar): Boolean;
         function ExactFind(Buffer: PChar; NewRecordBuffer: PChar): Boolean;
         function CompareFind(Buffer: PChar; SearchFieldCount: Integer): Boolean;
         function Locate(NumberOfFields: Word; Fields: TKeyFields;
                         RecordBuffer: PChar; IsCaseInsensitive: Boolean;
                         LastPartialLength: Word; NewRecordBuffer: PChar): Boolean;
         function IndexAvailableForFields(NumberOfFields: Word; Fields: TKeyFields;
                                          IsCaseInsensitive: Boolean;
                                          MatchDescending: Boolean;                                          
                                          var AvailableIndexPos: Byte): Boolean;
         function CompareIndexDefinitions(FirstIndexDefinition: pIndexDefinition;
                                          SecondIndexDefinition: pIndexDefinition;
                                          PartialFieldsMatch: Boolean;
                                          DescendingFieldsMatch: Boolean): Boolean;
         procedure SetRange(KeysProvided: Boolean;
                            BeginBuffer: PChar; BeginFieldCount: Integer;
                            EndBuffer: PChar; EndFieldCount: Integer);
         procedure ResetRange;
         procedure AddFilter(ClientData: Integer;
                             FilterExpr: PChar;
                             NextToken: TExpToken;
                             FreeTokens: Boolean;
                             FilterCallBack: pFilterFunction;
                             UseExisting: Boolean;
                             CalculateCosts: Boolean;
                             CaseInsensitive: Boolean;
                             NoPartialMatch: Boolean;
                             var FilterHandle: Pointer);
         procedure DropFilter(FilterHandle: Pointer; NoRemoteCall: Boolean);
         procedure ActivateFilter(FilterHandle: Pointer);
         procedure ResetFilter(FilterHandle: Pointer;
                               RecordBuffer: PChar;
                               ClientData: Integer;
                               FieldCallback: pEvaluateFieldCallback;
                               LocaleID: Integer);
         procedure DeactivateFilter(FilterHandle: Pointer);
         function EvaluateAndOptimizeLevels(LeftLevel: TOptimizeLevel;
                                            RightLevel: TOptimizeLevel): TOptimizeLevel;
         function EvaluateOrOptimizeLevels(LeftLevel: TOptimizeLevel;
                                           RightLevel: TOptimizeLevel): TOptimizeLevel;
         function GetExpressionOptimizeLevel(NextToken: TExpToken;
                                             CalculateCosts: Boolean): TOptimizeLevel;
         function RewriteExpression(NextToken: TExpToken;
                                    UseCosts: Boolean): Boolean;
         function GetSmallestCost(UpperToken: TExpToken;
                                  NextToken: TExpToken;
                                  UseCosts: Boolean): TExpToken;
         function CompareCosts(LeftToken: TExpToken;
                               RightToken: TExpToken;
                               UseCosts: Boolean): TExpToken;
         procedure RepositionCurrentRecord;
         procedure RefreshRangeAndFilters;
         procedure RefreshRangeAndFilterUpdate(RecordUpdated: Integer;
                                               RecordBuffer: PChar;
                                               OldRecordBuffer: PChar);
         procedure RefreshRangeAndFilterDelete(RecordDeleted: Integer;
                                               RecordBuffer: PChar);
         { Version 5 }
         procedure VerifyCurrentRecord(Direction: Byte);
         { Version 5 }
         procedure AddPrimaryIndex(NewIndexDefinition: pIndexDefinition;
                                   SuppressKeyViolation: Boolean;
                                   SendProgress: Boolean);
         procedure AddSecondaryIndex(NewIndexDefinition: pIndexDefinition;
                                     SuppressKeyViolation: Boolean;
                                     SendProgress: Boolean);
         procedure DeleteIndex(const DeleteIndexName: string);
         procedure DeleteIndexByPos(CurIndexPos: Byte;
                                    AddPrimaryIfNeeded: Boolean;
                                    AdjustIndexDefinitions: Boolean);
         procedure DeleteAllIndexes;
         procedure GetIndexFreeSpaceStats(IndexPosToCheck: Byte;
                                          var InternalCount: Integer;
                                          var InternalSpace: Integer;
                                          var ExternalCount: Integer;
                                          var ExternalSpace: Integer);
         procedure GetIndexSpaceStats(IndexPosToCheck: Byte;
                                      var InternalCount: Integer;
                                      var InternalSpace: Integer;
                                      var ExternalCount: Integer;
                                      var ExternalSpace: Integer;
                                      var KeyCount: Integer);
         procedure OpenBlob(FieldNum: Word; RecordBuffer: PChar;
                            Mode: Byte; UsePhysicalFields: Boolean;
                            SystemBlob: Boolean; var NewSize: Integer;
                            NoRemoteCall: Boolean);
         procedure FreeBlob(FieldNum: Word; RecordBuffer: PChar;
                            UsePhysicalFields: Boolean; SystemBlob: Boolean);
         procedure GetBlob(FieldNum: Word; RecordBuffer: PChar;
                           Offset: Integer; Buffer: PChar;
                           ReadBytes: Integer; var ActualBytes: Integer;
                           UsePhysicalFields: Boolean);
         procedure PutBlob(FieldNum: Word; RecordBuffer: PChar;
                           Offset: Integer; Buffer: PChar;
                           WriteBytes: Integer;
                           UsePhysicalFields: Boolean);
         procedure TruncateBlob(FieldNum: Word; RecordBuffer: PChar;
                                NewBytes: Integer; UsePhysicalFields: Boolean);
         procedure GetBlobSize(FieldNum: Word; RecordBuffer: PChar;
                               var Size: Integer; UsePhysicalFields: Boolean);
         function ValidBlobHandle(FieldNum: Word; RecordBuffer: PChar;
                                  UsePhysicalFields: Boolean): Boolean;
         function ValidBlobBufferHandle(BlobHandle: Integer;
                                        var BlobBufferPos: Integer): Boolean;
         procedure CancelAllBlobs(RecordBuffer: PChar);
         procedure FreeAllBlobs(ForceFree: Boolean; NoRemoteCall: Boolean);
         procedure DeleteAllBlobs(RecordBuffer: PChar);
         procedure UpdateBlobBlocks(RecordBuffer: PChar; UsePhysicalFields: Boolean);
         procedure UpdateBlobSignatures(RecordBuffer: PChar; UsePhysicalFields: Boolean);
         function GetBlobSignature(FieldNum: Word; RecordBuffer: PChar;
                                   UsePhysicalFields: Boolean): Integer;
         procedure PutBlobSignature(FieldNum: Word; RecordBuffer: PChar;
                                    BlobSignature: Integer; UsePhysicalFields: Boolean);
         procedure SetToDataCursor(SourceDataCursor: TDataCursor);
         procedure SetSteppedProgressCallback(ClientData: Integer;
                                             SteppedProgressCallback: pSteppedProgressCallback);
         procedure SetLogCallback(ClientData: Integer;
                                        LogCallback: pLogCallback);
         procedure SetProgressCallback(ClientData: Integer;
                                            ProgressCallback: pProgressCallback);
         procedure SetDataLostCallback(ClientData: Integer;
                                       DataLostCallback: pDataLostCallback);
         procedure FreeBuffers(AdjustBuffers: Boolean; ReadHeaders: Boolean;
                               ReadIndexes: Boolean);
         procedure FlushBuffers(ForceFlush: Boolean;
                                AdjustBuffers: Boolean;
                                ForceDataHeader: Boolean;
                                ForceIndexHeader: Boolean;
                                ForceBlobHeader: Boolean);
         procedure FlushOSBuffers;
         procedure SetFieldMapping(NewNumberOfFields: Word;
                                   const NewFieldDefinitions: array of pFieldDefinition);
         procedure CheckExclusive;
         procedure CheckNotReadOnly;
         procedure CheckNotOpen;
         procedure CheckTransaction;
         procedure SynchLastUpdateStamps;
         procedure GetDataHeader(var Header: TDataHeader;
                                 var Password: string);
         procedure GetIndexHeader(var Header: TIndexHeader);
         procedure GetBlobHeader(var Header: TBlobHeader);
         function TextOccurs(FieldNum: Word; const FieldName: string;
                             SearchWordBuffer: PChar;
                             SearchWordBufferSize: Integer;
                             ValueWordBuffer: PChar;
                             ValueWordBufferSize: Integer): Integer;
         function TextSearch(FieldNum: Word; const FieldName: string;
                             SearchWordBuffer: PChar;
                             SearchWordBufferSize: Integer;
                             ValueWordBuffer: PChar;
                             ValueWordBufferSize: Integer): Boolean;
         procedure GetTextIndexParams;
         function GetMaxPageSize(NumberOfFields: Word;
                                 const FieldDefinitions: array of pFieldDefinition;
                                 NumberOfIndexes: Byte;
                                 const IndexDefinitions: array of pIndexDefinition): Integer;
         function GetCachedUpdatesCursor: TDataCursor;
         procedure PopulateCachedUpdates;
         procedure ApplyCachedUpdatesToCursor(DestCursor: TDataCursor;
                                              SendErrors: Boolean);
         procedure SetCacheErrorCallback(ClientData: Integer;
                                         CacheErrorCallback: pCacheErrorCallback);
         procedure CacheError(RecordNumber: Integer;
                              RecordBuffer: PChar;
                              OldRecordBuffer: PChar;
                              E: Exception;
                              OperationType: Byte;
                              Retrying: Boolean;
                              var Response: Byte);
         procedure CreateBlobCopies(RecordBuffer: PChar;
                                    UsePhysicalFields: Boolean);
      end;

function CompareLocaleChars(Item1: Pointer; Item2: Pointer): Integer;
function CompareLocales(Item1: Pointer; Item2: Pointer): Integer;
function CompareFileNames(FileToCompare: TBaseFile; const FileName: string): Integer;
function CompareLocks(LockToCompare: pLockRecord; Offset: Int64): Integer;
function CompareBufferNumbers(BufferToCompare: TBuffer; BufferNum: Integer): Integer;
function CompareRecordIDs(RecordID1: Integer; RecordID2: Integer): Integer;
function CompareDataTables(DataTable: TDataTable; const TableName: string): Integer;
function CompareFilterKeys(Item1,Item2: Pointer): Integer;
function CompareDataTableIDs(Item1,Item2: Pointer): Integer;

procedure UpdateFieldSize(FieldDefinition: pFieldDefinition);
procedure UpdateFieldDecimals(FieldDefinition: pFieldDefinition);
function GetDefaultDataSize(DataType: Byte; SubType: Byte): Word;
function GetIndexedSize(FieldDefinition: pFieldDefinition): Word;
procedure PrepareDataForIndex(SourceFieldDefinition: pFieldDefinition;
                              SourceFieldBuffer: PChar;
                              DestKeyBuffer: PChar;
                              IsCaseInsensitive: Boolean;
                              LocaleID: Integer);
function VerifyBasicExpression(const ExprStr: string;
                               FieldType: Word): Boolean;

function GetLocaleDataW(ID: LCID; Flag: DWORD): AnsiString;
function GetLocaleDataA(ID: LCID; Flag: DWORD): AnsiString;
function LocalesCallback(LocaleID: PChar): Integer; stdcall;

function DataEngine: TDataEngine;

implementation

uses DB,



FMTBcd,

dbisamtb, dbisamsv, dbisamsq, dbisamst, zlibcomp, zlibpas;

function DataEngine: TDataEngine;
begin
   Result:=Engine.Handle;
end;

{ Comparison functions }

function CompareLocaleChars(Item1,Item2: Pointer): Integer;
begin
   Result:=OSCompareCharNoAccent(pLocaleChar(Item1)^.LocaleID,
                                 pLocaleChar(Item1)^.LocaleChar,
                                 pLocaleChar(Item2)^.LocaleChar);
end;

function CompareLocales(Item1: Pointer; Item2: Pointer): Integer;
begin
   Result:=VerifyCompareResult(AnsiCompareStr(TDataLocale(Item1).Name,TDataLocale(Item2).Name));
end;

function CompareFileNames(FileToCompare: TBaseFile; const FileName: string): Integer;
begin
   Result:=OSCompareFileNames(Trim(FileToCompare.FileName),Trim(FileName));
end;

function CompareLocks(LockToCompare: pLockRecord; Offset: Int64): Integer;
begin
   Result:=CMP_EQUAL;
   with LockToCompare^ do
      begin
      if (BeginOffset < Offset) then
         Result:=CMP_LESS
      else if (BeginOffset > Offset) then
         Result:=CMP_GREATER;
      end;
end;

function CompareBufferNumbers(BufferToCompare: TBuffer; BufferNum: Integer): Integer;
begin
   Result:=CMP_EQUAL;
   with BufferToCompare do
      begin
      if (Number < BufferNum) then
         Result:=CMP_LESS
      else if (Number > BufferNum) then
         Result:=CMP_GREATER;
      end;
end;

function CompareRecordIDs(RecordID1: Integer; RecordID2: Integer): Integer;
begin
   Result:=CMP_EQUAL;
   if (RecordID1 < RecordID2) then
      Result:=CMP_LESS
   else if (RecordID1 > RecordID2) then
      Result:=CMP_GREATER;
end;

function CompareDataTables(DataTable: TDataTable; const TableName: string): Integer;
begin
   Result:=OSCompareFileNames(Trim(DataTable.TableName),Trim(TableName));
end;

function CompareFilterKeys(Item1,Item2: Pointer): Integer;
begin
   with TDataCursor(pFilterKeyBuffer(Item1)^.Cursor) do
      Result:=CompareKeys(@pFilterKeyBuffer(Item1)^.KeyBuffer,
                          @pFilterKeyBuffer(Item2)^.KeyBuffer,KeySize);
end;

function CompareDataTableIDs(Item1,Item2: Pointer): Integer;
begin
   Result:=CMP_EQUAL;
   if (TDataTable(Item1).DataTableLocks=nil) and
      (TDataTable(Item2).DataTableLocks=nil) then
      Result:=CMP_EQUAL
   else if (TDataTable(Item1).DataTableLocks=nil) and
           (TDataTable(Item2).DataTableLocks <> nil) then
      Result:=CMP_LESS
   else if (TDataTable(Item1).DataTableLocks <> nil) and
           (TDataTable(Item2).DataTableLocks=nil) then
      Result:=CMP_GREATER
   else if (TDataTable(Item1).DataTableLocks.TableID <
            TDataTable(Item2).DataTableLocks.TableID) then
      Result:=CMP_LESS
   else if (TDataTable(Item1).DataTableLocks.TableID >
            TDataTable(Item2).DataTableLocks.TableID) then
      Result:=CMP_GREATER;
end;

{ Field definition functions }

procedure UpdateFieldSize(FieldDefinition: pFieldDefinition);
begin
   with FieldDefinition^ do
      begin
      DataSize:=Length;
      case DataType of
         TYPE_ZSTRING:
            begin
            if (SubType=SUBTYPE_UNICODE) then
               DataSize:=(DataSize*2);
            Inc(DataSize);
            end;
         TYPE_BOOL:
            DataSize:=TYPE_BOOL_SIZE;
         TYPE_INT16:
            DataSize:=TYPE_INT16_SIZE;
         TYPE_UINT16:
            DataSize:=TYPE_UINT16_SIZE;
         TYPE_INT32:
            DataSize:=TYPE_INT32_SIZE;
         TYPE_INT64:
            DataSize:=TYPE_INT64_SIZE;
         TYPE_FLOAT:
            DataSize:=TYPE_FLOAT_SIZE;
         TYPE_BCD:
            DataSize:=TYPE_BCD_SIZE;
         TYPE_DATE:
            DataSize:=TYPE_DATE_SIZE;
         TYPE_TIME:
            DataSize:=TYPE_TIME_SIZE;
         TYPE_TIMESTAMP:
            DataSize:=TYPE_TIMESTAMP_SIZE;
         TYPE_BLOB:
            DataSize:=TYPE_BLOB_SIZE;
         end;
      end;
end;

procedure UpdateFieldDecimals(FieldDefinition: pFieldDefinition);
begin
   with FieldDefinition^ do
      DataDecimals:=Decimals;
end;

function GetDefaultDataSize(DataType: Byte; SubType: Byte): Word;
begin
   Result:=0;
   if (not (DataType in [TYPE_ZSTRING,TYPE_BLOB,TYPE_BYTES,TYPE_VARBYTES])) then
      begin
      case DataType of
         TYPE_BOOL:
            Result:=TYPE_BOOL_SIZE;
         TYPE_INT16:
            Result:=TYPE_INT16_SIZE;
         TYPE_UINT16:
            Result:=TYPE_UINT16_SIZE;
         TYPE_INT32:
            Result:=TYPE_INT32_SIZE;
         TYPE_INT64:
            Result:=TYPE_INT64_SIZE;
         TYPE_FLOAT:
            Result:=TYPE_FLOAT_SIZE;
         TYPE_BCD:
            Result:=TYPE_BCD_SIZE;
         TYPE_DATE:
            Result:=TYPE_DATE_SIZE;
         TYPE_TIME:
            Result:=TYPE_TIME_SIZE;
         TYPE_TIMESTAMP:
            Result:=TYPE_TIMESTAMP_SIZE;
         end;
      end
   else
      begin
      if (DataType=TYPE_ZSTRING) then
         begin
         case SubType of
            SUBTYPE_GUID:
               Result:=TYPE_GUID_SIZE;
            SUBTYPE_UNICODE:
               Result:=((MAX_FIELD_SIZE+1) div 2);
            else
               Result:=(MAX_FIELD_SIZE+1);
            end;
         end
      else
         Result:=(MAX_FIELD_SIZE+1);
      end;
end;

function GetIndexedSize(FieldDefinition: pFieldDefinition): Word;
begin
   with FieldDefinition^ do
      begin
      if (DataType=TYPE_BCD) then
         Result:=8
      else
         Result:=DataSize;
      end;
end;

procedure PrepareDataForIndex(SourceFieldDefinition: pFieldDefinition;
                              SourceFieldBuffer: PChar;
                              DestKeyBuffer: PChar;
                              IsCaseInsensitive: Boolean;
                              LocaleID: Integer);
begin
   with SourceFieldDefinition^ do
      begin
      case DataType of
         TYPE_ZSTRING:
            begin
            if IsCaseInsensitive then
               OSUpperString(LocaleID,SourceFieldBuffer);
            StrCopy((DestKeyBuffer+FLDCHG_DATA),SourceFieldBuffer);
            end;
         TYPE_FLOAT:
            FlipFloatBits(pDouble(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         TYPE_TIMESTAMP:
            FlipFloatBits(pDouble(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         TYPE_INT32,TYPE_DATE,TYPE_TIME:
            FlipIntegerBits(pInteger(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         TYPE_INT16:
            FlipSmallIntBits(pSmallInt(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         TYPE_UINT16,TYPE_BOOL:
            FlipWordBits(pWord(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         TYPE_BCD:
            FlipCurrencyBits(TBCDToCurr(pBCD(SourceFieldBuffer)^),(DestKeyBuffer+FLDCHG_DATA));
         TYPE_INT64:
            FlipLargeIntBits(pInt64(SourceFieldBuffer)^,(DestKeyBuffer+FLDCHG_DATA));
         else
            Move(SourceFieldBuffer^,(DestKeyBuffer+FLDCHG_DATA)^,DataSize);
         end;
      end;
end;

function VerifyBasicExpression(const ExprStr: string;
                                  FieldType: Word): Boolean;
begin
   Result:=True;
   if (not (FieldType in [TYPE_ZSTRING,TYPE_BYTES,TYPE_VARBYTES])) and
      (ExprStr <> '') then
      begin
      case FieldType of
         TYPE_BLOB:
            Result:=False;
         TYPE_BOOL:
            Result:=IsABoolean(ExprStr);
         TYPE_UINT16:
            Result:=IsAWord(ExprStr);
         TYPE_INT16:
            Result:=IsASmallInt(ExprStr);
         TYPE_INT32:
            Result:=IsAnInteger(ExprStr);
         TYPE_INT64:
            Result:=IsALargeInt(ExprStr);
         TYPE_FLOAT:
            Result:=IsAFloat(ExprStr);
         TYPE_BCD:
            Result:=IsABCD(ExprStr);
         TYPE_TIMESTAMP:
            begin
            if ((AnsiCompareText(ExprStr,PARSE_CURDATETIME) <> 0) and
                (AnsiCompareText(ExprStr,PARSE_CURDATE) <> 0) and
                (AnsiCompareText(ExprStr,PARSE_CURTIME) <> 0)) and
               ((not IsADate(ExprStr)) and
                (not IsADateTime(ExprStr)) and
                (not IsATime(ExprStr))) then
               Result:=False;
            end;
         TYPE_TIME:
            begin
            if (AnsiCompareText(ExprStr,PARSE_CURTIME) <> 0) and
               (not IsATime(ExprStr)) then
               Result:=False;
            end;
         TYPE_DATE:
            begin
            if (AnsiCompareText(ExprStr,PARSE_CURDATE) <> 0) and
               (not IsADate(ExprStr)) then
               Result:=False;
            end;
         end;
      end;
end;

{ TDataLocale }

constructor TDataLocale.Create(Owner: TDataEngine);
begin
   FDataEngine:=Owner;
end;

function TDataLocale.GetCharMap: TLocaleCharMap;
var
   I: Byte;
   TempCharList: TList;
   TempPtr: Pointer;
begin
   if (not FCharMapBuilt) then
      begin
      TempCharList:=TList.Create;
      try
         with TempCharList do
            begin
            Capacity:=High(Byte);
            for I:=NON_PRINTABLE_OFFSET to High(Byte) do
               begin
               Add(AllocMem(SizeOf(TLocaleChar)));
               with pLocaleChar(Last)^ do
                  begin
                  LocaleChar:=AnsiChar(I);
                  LocaleID:=FID;
                  end;
               end;
            if (FID <> LOCALE_ANSI_STD) then
               Sort(@CompareLocaleChars);
            for I:=0 TO NON_PRINTABLE_OFFSET do
               FCharMap[I]:=AnsiChar(I);
            for I:=NON_PRINTABLE_OFFSET to High(Byte) do
               begin
               FCharMap[I]:=pLocaleChar(Items[I-NON_PRINTABLE_OFFSET])^.LocaleChar;
               TempPtr:=Items[I-NON_PRINTABLE_OFFSET];
               DeAllocMem(TempPtr);
               end;
            end;
         FCharMapBuilt:=True;
      finally
         TempCharList.Free;
      end;
      end;
   Result:=FCharMap;
end;

{ TBaseFile }

constructor TBaseFile.Create(Owner: TDataEngine);
begin
   FDataEngine:=Owner;
   FFileSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FFileSection);
   FLocksList:=TList.Create;
   FLocksList.Capacity:=DEFAULT_LOCK_COUNT;
   FHandlesList:=TList.Create;
   FHandlesList.Capacity:=DEFAULT_HANDLE_COUNT;
end;

destructor TBaseFile.Destroy;
begin
   FreeLocks;
   FreeHandles;
   OSDeleteCriticalSection(FFileSection);
   OSDeAllocCriticalSection(FFileSection);
   inherited Destroy;
end;

procedure TBaseFile.LockFileSection;
begin
   OSEnterCriticalSection(FFileSection);
end;

procedure TBaseFile.UnlockFileSection;
begin
   OSLeaveCriticalSection(FFileSection);
end;

procedure TBaseFile.FreeLocks;
var
   I: Integer;
   TempPtr: Pointer;
begin
   for I:=FLocksList.Count-1 downto 0 do
      begin
      TempPtr:=FLocksList[I];
      DeAllocMem(TempPtr);
      FLocksList.Delete(I);
      end;
   FLocksList.Free;
end;

procedure TBaseFile.FreeHandles;
var
   I: Integer;
   TempPtr: Pointer;
begin
   for I:=FHandlesList.Count-1 downto 0 do
      begin
      TempPtr:=FHandlesList[I];
      DeAllocMem(TempPtr);
      FHandlesList.Delete(I);
      end;
   FHandlesList.Free;
end;

function TBaseFile.GetHandlePos(FileHandle: Integer): Integer;
var
   I: Integer;
begin
   Result:=-1;
   if (FUseCount > 0) then
      begin
      for I:=0 to FHandlesList.Count-1 do
         begin
         if (pFileHandleRecord(FHandlesList[I])^.Handle=FileHandle) then
            begin
            Result:=I;
            Break;
            end;
         end;
      end;
end;

function TBaseFile.GetFileSize: Int64;
begin
   Result:=FFileSize;
end;

function TBaseFile.Open: Integer;
var
   NewFileHandle: pFileHandleRecord;
begin
   LockFileSection;
   try
      Inc(FUseCount);
      NewFileHandle:=AllocMem(SizeOf(TFileHandleRecord));
      FHandlesList.Add(NewFileHandle);
      with NewFileHandle^ do
         begin
         Inc(FLastHandle);
         Handle:=FLastHandle;
         FilePos:=0;
         end;
      Result:=NewFileHandle^.Handle;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.CreateNew: Integer;
var
   NewFileHandle: pFileHandleRecord;
begin
   LockFileSection;
   try
      Inc(FUseCount);
      NewFileHandle:=AllocMem(SizeOf(TFileHandleRecord));
      FHandlesList.Add(NewFileHandle);
      with NewFileHandle^ do
         begin
         Inc(FLastHandle);
         Handle:=FLastHandle;
         FilePos:=0;
         end;
      FFileSize:=0;
      Result:=NewFileHandle^.Handle;
   finally
      UnlockFileSection;
   end;
end;

procedure TBaseFile.Close(FileHandle: Integer);
var
   HandlePos: Integer;
   TempPtr: Pointer;
begin
   LockFileSection;
   try
      HandlePos:=GetHandlePos(FileHandle);
      if (HandlePos <> -1) then
         begin
         TempPtr:=FHandlesList[HandlePos];
         DeAllocMem(TempPtr);
         FHandlesList.Delete(HandlePos);
         Dec(FUseCount);
         end;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.Rename(const NewName: string): Integer;
begin
   FFileName:=NewName;
   Result:=DBISAM_NONE;
end;

function TBaseFile.Delete: Integer;
begin
   Result:=DBISAM_NONE;
end;

function TBaseFile.Read(FileHandle: Integer; var Buffer;
                        NumBytes: Integer): Integer;
var
   HandlePos: Integer;
begin
   LockFileSection;
   try
      Result:=0;
      HandlePos:=GetHandlePos(FileHandle);
      if (HandlePos <> -1) then
         begin
         with pFileHandleRecord(FHandlesList[HandlePos])^ do
            begin
            if (FilePos < 0) or (FilePos > FFileSize) then
               Result:=0
            else if ((FilePos+NumBytes) > FFileSize) then
               begin
               Result:=(FFileSize-FilePos);
               FilePos:=FFileSize;
               end
            else
               begin
               Result:=NumBytes;
               Inc(FilePos,NumBytes);
               end;
            end;
         end;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.Write(FileHandle: Integer; const Buffer;
                         NumBytes: Integer): Integer;
var
   HandlePos: Integer;
begin
   LockFileSection;
   try
      Result:=0;
      HandlePos:=GetHandlePos(FileHandle);
      if (HandlePos <> -1) then
         begin
         with pFileHandleRecord(FHandlesList[HandlePos])^ do
            begin
            if (NumBytes=0) then
               FFileSize:=FilePos
            else
               begin
               if ((FilePos+NumBytes) > FFileSize) then
                  FFileSize:=(FilePos+NumBytes);
               Inc(FilePos,NumBytes);
               Result:=NumBytes;
               end;
            end;
         end;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.Flush(FileHandle: Integer): Boolean;
begin
   Result:=True;
end;

function TBaseFile.Seek(FileHandle: Integer; Position: Int64;
                        From: Word): Int64;
var
   HandlePos: Integer;
begin
   LockFileSection;
   try
      Result:=0;
      HandlePos:=GetHandlePos(FileHandle);
      if (HandlePos <> -1) then
         begin
         with pFileHandleRecord(FHandlesList[HandlePos])^ do
            begin
            case From of
               FROM_BOF:
                  begin
                  FilePos:=0;
                  Inc(FilePos,Position);
                  end;
               FROM_CURRENT:
                  Inc(FilePos,Position);
               FROM_EOF:
                  begin
                  FilePos:=FFileSize;
                  Dec(FilePos,Position);
                  end;
               end;
            Result:=FilePos;
            end;
         end;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.FindLock(Value: Int64; var IndexPos: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   IndexPos:=0;
   if (FLocksList.Count=0) then
      Exit;
   CompareResult:=CMP_EQUAL;
   Low:=0;
   High:=(FLocksList.Count-1);
   while (Low <= High) do
      begin
      IndexPos:=((Low+High) div 2);
      CompareResult:=CompareLocks(FLocksList[IndexPos],Value);
      case CompareResult of
         CMP_GREATER: High:=(IndexPos-1);
         CMP_LESS: Low:=(IndexPos+1);
         CMP_EQUAL:
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
   { Adjust the buffer index for proper insertion }
   if (CompareResult=CMP_LESS) then
      begin
      if (IndexPos < FLocksList.Count) then
         Inc(IndexPos);
      end;
end;

function TBaseFile.Lock(Offset: Int64; LockLength: Int64): Boolean;
var
   TempPos: Integer;
   NewLockRecord: pLockRecord;
begin
   LockFileSection;
   try
      Result:=True;
      if FindLock(Offset,TempPos) then
         Result:=False
      else
         begin
         { Check boundaries of lock range }
         if (TempPos > 0) then
            begin
            if (Offset <= pLockRecord(FLocksList[TempPos-1])^.EndOffset) then
               begin
               Result:=False;
               Exit;
               end;
            end;
         if (TempPos < (FLocksList.Count-1)) then
            begin
            if (((Offset-1)+LockLength) >= pLockRecord(FLocksList[TempPos+1])^.BeginOffset) then
               begin
               Result:=False;
               Exit;
               end;
            end;
         end;
      if Result then
         begin
         NewLockRecord:=AllocMem(SizeOf(TLockRecord));
         with NewLockRecord^ do
            begin
            BeginOffset:=Offset;
            EndOffset:=((Offset-1)+LockLength);
            ByteLength:=LockLength;
            end;
         if (FLocksList.Count=FLocksList.Capacity) then
            FLocksList.Capacity:=FLocksList.Capacity+LOCK_EXPAND;
         FLocksList.Insert(TempPos,NewLockRecord);
         end;
   finally
      UnlockFileSection;
   end;
end;

function TBaseFile.Unlock(Offset: Int64; LockLength: Int64): Boolean;
var
   TempPos: Integer;
   TempLockRecord: pLockRecord;
begin
   LockFileSection;
   try
      Result:=False;
      if FindLock(Offset,TempPos) then
         begin
         Result:=True;
         TempLockRecord:=pLockRecord(FLocksList[TempPos]);
         DeAllocMem(TempLockRecord);
         FLocksList.Delete(TempPos);
         end;
   finally
      UnlockFileSection;
   end;
end;

{ TMemoryFile }

constructor TMemoryFile.Create(Owner: TDataEngine);
begin
   inherited Create(Owner);
   FFileBuffers:=TList.Create;
end;

destructor TMemoryFile.Destroy;
begin
   ResizeFileBuffer(0);
   FFileBuffers.Free;
   inherited Destroy;
end;

procedure TMemoryFile.ResizeFileBuffer(NewSize: Integer);
var
   AllocationSize: Integer;
   I: Integer;
   TempBuffer: PChar;
   BlocksToAllocate: Integer;
begin
   AllocationSize:=NewSize;
   if (AllocationSize > 0) then
      begin
      if ((AllocationSize mod INMEMORY_ALLOCATION_SIZE) <> 0) then
         AllocationSize:=((INMEMORY_ALLOCATION_SIZE*
                          (AllocationSize div INMEMORY_ALLOCATION_SIZE))+
                           INMEMORY_ALLOCATION_SIZE);
      if (AllocationSize > FFileBufferSize) then
         begin
         BlocksToAllocate:=((AllocationSize-FFileBufferSize) div INMEMORY_ALLOCATION_SIZE);
         for I:=1 to BlocksToAllocate do
            FFileBuffers.Add(AllocMem(INMEMORY_ALLOCATION_SIZE));
         FFileBufferSize:=AllocationSize;
         end;
      end
   else
      begin
      if (FFileBufferSize > 0) then
         begin
         for I:=FFileBuffers.Count-1 downto 0 do
            begin
            TempBuffer:=FFileBuffers[I];
            DeAllocMem(TempBuffer);
            FFileBuffers.Delete(I);
            end;
         FFileBufferSize:=0;
         end;
      end;
end;

function TMemoryFile.CreateNew: Integer;
begin
   ResizeFileBuffer(0);
   Result:=inherited CreateNew;
end;

function TMemoryFile.Read(FileHandle: Integer; var Buffer;
                          NumBytes: Integer): Integer;
var
   FilePos: Integer;
   BlockNumber: Integer;
   BlockPos: Integer;
   BufferLeft: Integer;
   BufferPtr: PChar;
   BytesToMove: Integer;
begin
   LockFileSection;
   try
      Result:=inherited Read(FileHandle,Buffer,NumBytes);
      FilePos:=Seek(FileHandle,0,FROM_CURRENT);
      BlockNumber:=((FilePos-Result) div INMEMORY_ALLOCATION_SIZE);
      BlockPos:=((FilePos-Result) mod INMEMORY_ALLOCATION_SIZE);
      BufferLeft:=Result;
      BufferPtr:=@Buffer;
      while (BufferLeft > 0) do
         begin
         if (BufferLeft > (INMEMORY_ALLOCATION_SIZE-BlockPos)) then
            BytesToMove:=(INMEMORY_ALLOCATION_SIZE-BlockPos)
         else
            BytesToMove:=BufferLeft;
         Move((PChar(FFileBuffers[BlockNumber])+BlockPos)^,BufferPtr^,BytesToMove);
         Dec(BufferLeft,BytesToMove);
         Inc(BufferPtr,BytesToMove);
         Inc(BlockNumber);
         BlockPos:=0;
         end;
   finally
      UnlockFileSection;
   end;
end;

function TMemoryFile.Write(FileHandle: Integer; const Buffer;
                           NumBytes: Integer): Integer;
var
   FilePos: Integer;
   OldSize: Integer;
   BlockNumber: Integer;
   BlockPos: Integer;
   BufferLeft: Integer;
   BufferPtr: PChar;
   BytesToMove: Integer;
begin
   LockFileSection;
   try
      OldSize:=FFileSize;
      Result:=inherited Write(FileHandle,Buffer,NumBytes);
      FilePos:=Seek(FileHandle,0,FROM_CURRENT);
      if (NumBytes=0) then
         ResizeFileBuffer(FilePos)
      else
         begin
         if (FilePos > OldSize) then
            ResizeFileBuffer(FilePos);
         BlockNumber:=((FilePos-Result) div INMEMORY_ALLOCATION_SIZE);
         BlockPos:=((FilePos-Result) mod INMEMORY_ALLOCATION_SIZE);
         BufferLeft:=Result;
         BufferPtr:=@Buffer;
         while (BufferLeft > 0) do
            begin
            if (BufferLeft > (INMEMORY_ALLOCATION_SIZE-BlockPos)) then
               BytesToMove:=(INMEMORY_ALLOCATION_SIZE-BlockPos)
            else
               BytesToMove:=BufferLeft;
            Move(BufferPtr^,(PChar(FFileBuffers[BlockNumber])+BlockPos)^,BytesToMove);
            Dec(BufferLeft,BytesToMove);
            Inc(BufferPtr,BytesToMove);
            Inc(BlockNumber);
            BlockPos:=0;
            end;
         end;
   finally
      UnlockFileSection;
   end;
end;

{ TPhysicalFile }

constructor TPhysicalFile.Create(Owner: TDataEngine);
begin
   inherited Create(Owner);
end;

destructor TPhysicalFile.Destroy;
begin
   inherited Destroy;
end;

function TPhysicalFile.GetFileSize: Int64;
begin
   LockFileSection;
   try
      Result:=OSFileSeek(FPhysicalHandle,0,FROM_EOF);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Open: Integer;
var
   TempAttr: Integer;
   ForceExclusive: Boolean;
begin
   LockFileSection;
   try
      if (FUseCount=0) then
         begin
         FMarkedReadOnly:=False;
         TempAttr:=OSFileAttr(FFileName,FHidden);
         if (TempAttr < 0) then
            begin
            Result:=-(DataEngine.OSError);
            Exit;
            end;
         if (TempAttr=ATTR_READONLY) then
            begin
            FReadOnly:=True;
            FMarkedReadOnly:=True;
            end;
         ForceExclusive:=False;
         FPhysicalHandle:=OSFileOpen(FFileName,FReadOnly,
                                     (FExclusive or ForceExclusive),
                                     FTemporary,FHidden);
         if (FPhysicalHandle < 0) then
            begin
            if (not FReadOnly) then
               begin
               { Try again with read-only mode in case OS permissions are
                 preventing read-write open }
               FPhysicalHandle:=OSFileOpen(FFileName,True,
                                           (FExclusive or ForceExclusive),
                                           FTemporary,FHidden);
               if (FPhysicalHandle < 0) then
                  begin
                  Result:=-(DataEngine.OSError);
                  Exit;
                  end
               else
                  FReadOnly:=True;
               end
            else
               begin
               Result:=-(DataEngine.OSError);
               Exit;
               end;
            end;
         end;
      Result:=inherited Open;
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.CreateNew: Integer;
begin
   LockFileSection;
   try
      FPhysicalHandle:=OSFileCreate(FFileName,FTemporary,FHidden);
      if (FPhysicalHandle < 0) then
         begin
         Result:=-(DataEngine.OSError);
         Exit;
         end;
      Result:=inherited CreateNew;
   finally
      UnlockFileSection;
   end;
end;

procedure TPhysicalFile.Close(FileHandle: Integer);
begin
   LockFileSection;
   try
      inherited Close(FileHandle);
      if (FUseCount=0) then
         begin
         if (FPhysicalHandle > 0) then
            OSFileClose(FPhysicalHandle);
         FPhysicalHandle:=0;
         end;
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Rename(const NewName: string): Integer;
begin
   LockFileSection;
   try
      if not OSFileRename(FFileName,NewName) then
         begin
         Result:=-(DataEngine.OSError);
         Exit;
         end;
      Result:=inherited Rename(NewName);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Delete: Integer;
begin
   LockFileSection;
   try
      if (not OSFileDelete(FFileName)) then
         begin
         Result:=-(DataEngine.OSError);
         Exit;
         end;
      Result:=inherited Delete;
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Read(FileHandle: Integer; var Buffer;
                            NumBytes: Integer): Integer;
begin
   LockFileSection;
   try
      Result:=OSFileRead(FPhysicalHandle,Buffer,NumBytes);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Write(FileHandle: Integer; const Buffer;
                             NumBytes: Integer): Integer;
begin
   LockFileSection;
   try
      Result:=0;
      if (NumBytes=0) then
         OSSetEndOfFile(FPhysicalHandle)
      else
         Result:=OSFileWrite(FPhysicalHandle,Buffer,NumBytes);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Flush(FileHandle: Integer): Boolean;
begin
   LockFileSection;
   try
      Result:=OSFileFlush(FPhysicalHandle);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Seek(FileHandle: Integer; Position: Int64;
                            From: Word): Int64;
begin
   LockFileSection;
   try
      Result:=OSFileSeek(FPhysicalHandle,Position,From);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Lock(Offset: Int64; LockLength: Int64): Boolean;
begin
   LockFileSection;
   try
      Result:=OSFileLock(FPhysicalHandle,Offset,LockLength);
   finally
      UnlockFileSection;
   end;
end;

function TPhysicalFile.Unlock(Offset: Int64; LockLength: Int64): Boolean;
begin
   LockFileSection;
   try
      Result:=OSFileUnlock(FPhysicalHandle,Offset,LockLength);
   finally
      UnlockFileSection;
   end;
end;

{ Version 5 }

{ Copied from SysUtils.pas and modified to no longer be a class method in
  order to avoid Data Execution Protection issues on newer Intel and
  AMD64 processors }


{ Query the OS for information for a specified locale. Unicode version. Works correctly on Asian WinNT. }
function GetLocaleDataW(ID: LCID; Flag: DWORD): AnsiString;
var
   Buffer: array[0..1023] of WideChar;
begin
   Buffer[0]:=#0;
   GetLocaleInfoW(ID,Flag,Buffer,SizeOf(Buffer) div 2);
   Result:=Buffer;
end;

{ Query the OS for information for a specified locale. ANSI Version. Works correctly on Asian Win95. }
function GetLocaleDataA(ID: LCID; Flag: DWORD): AnsiString;
var
   Buffer: array[0..1023] of Char;
begin
   Buffer[0]:=#0;
   SetString(Result,Buffer,GetLocaleInfoA(ID,Flag,Buffer,SizeOf(Buffer))-1);
end;

function LocalesCallback(LocaleID: PChar): Integer; stdcall;
var
   TempLCID: LCID;
   TempShortLangName: AnsiString;
   GetLocaleDataProc: function (ID: LCID; Flag: DWORD): AnsiString;
   TempDataLocale: TDataLocale;
begin
   if (Win32Platform=VER_PLATFORM_WIN32_NT) then
      GetLocaleDataProc:=@GetLocaleDataW
   else
      GetLocaleDataProc:=@GetLocaleDataA;
   TempLCID:=StrToInt('$'+System.Copy(LocaleID,5,4));
   TempShortLangName:=GetLocaleDataProc(TempLCID,LOCALE_SABBREVLANGNAME);
   if (TempShortLangName <> '') then
      begin
      TempDataLocale:=TDataLocale.Create(DataEngine);
      with TempDataLocale do
         begin
         ID:=TempLCID;
         Name:=GetLocaleDataProc(TempLCID,LOCALE_SLANGUAGE);
         ShortName:=TempShortLangName;
         end;
      DataEngine.LocaleList.Add(TempDataLocale);
      if (OSPrimaryLanguageID(TempDataLocale.ID)=LANG_GERMAN) and
         (OSSubLanguageID(TempDataLocale.ID)=SUBLANG_GERMAN) then
         begin
         TempDataLocale:=TDataLocale.Create(DataEngine);
         with TempDataLocale do
            begin
            ID:=OSLocaleID(OSLanguageID(LANG_GERMAN,SUBLANG_GERMAN),SORT_GERMAN_PHONE_BOOK);
            Name:='German (German Phone Book)';
            ShortName:='DEP';
            end;
         DataEngine.LocaleList.Add(TempDataLocale);
         end;
      end;
   Result:=1;
end;

{ Version 5 }

{ TDataEngine }

constructor TDataEngine.Create;
begin
   FInitialized:=False;
   FLocaleSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FLocaleSection);
   FErrorSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FErrorSection);
   FPhysicalFileList:=TList.Create;
   FPhysicalFileListSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FPhysicalFileListSection);
   FMemoryFileList:=TList.Create;
   FMemoryFileListSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FMemoryFileListSection);
   FLocaleList:=TList.Create;
   { Version 5 }
   { Removed PopulateLocales }
   { Version 5 }
   FDataSessionList:=TList.Create;
   FDataSessionSection:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FDataSessionSection);
   FSignature:=DBISAM_SIGNATURE;
   FSignatureDigest:=MD5String(FSignature);
   FDataExtension:=DATA_FILE_EXT;
   FIndexExtension:=INDEX_FILE_EXT;
   FBlobExtension:=BLOB_FILE_EXT;
   FDataBackupExtension:=DATA_BACKUP_FILE_EXT;
   FIndexBackupExtension:=INDEX_BACKUP_FILE_EXT;
   FBlobBackupExtension:=BLOB_BACKUP_FILE_EXT;
   FDataUpgradeExtension:=DATA_UPGRADE_FILE_EXT;
   FIndexUpgradeExtension:=INDEX_UPGRADE_FILE_EXT;
   FBlobUpgradeExtension:=BLOB_UPGRADE_FILE_EXT;
   FDataTempExtension:=DATA_TEMP_FILE_EXT;
   FIndexTempExtension:=INDEX_TEMP_FILE_EXT;
   FBlobTempExtension:=BLOB_TEMP_FILE_EXT;
   FMaxDataBufferSize:=DEFAULT_RECORD_BUFFER_SIZE;
   FMaxDataBufferCount:=DEFAULT_RECORD_BUFFER_COUNT;
   FMaxIndexBufferSize:=DEFAULT_PAGE_BUFFER_SIZE;
   FMaxIndexBufferCount:=DEFAULT_PAGE_BUFFER_COUNT;
   FMaxBlobBufferSize:=DEFAULT_BLOCK_BUFFER_SIZE;
   FMaxBlobBufferCount:=DEFAULT_BLOCK_BUFFER_COUNT;
   FFilterIndexThreshhold:=DEFAULT_FILTER_INDEX_THRESHHOLD;
   FLockFileName:=DEFAULT_LOCK_FILE_NAME;
   FReadLockWaitTime:=READ_LOCK_WAIT;
   FReadLockRetries:=READ_LOCK_RETRIES;
   FWriteLockWaitTime:=WRITE_LOCK_WAIT;
   FWriteLockRetries:=WRITE_LOCK_RETRIES;
   FTransLockWaitTime:=TRANS_LOCK_WAIT;
   FTransLockRetries:=TRANS_LOCK_RETRIES;
   { Version 5 }
   FMaxReadLockCount:=MAX_READ_LOCK_COUNT;
   { Version 5 }
end;

destructor TDataEngine.Destroy;
begin
   Reset;
   if (FDataSessionList <> nil) then
      begin
      FreeDataSessions;
      FDataSessionList.Free;
      FDataSessionList:=nil;
      end;
   OSDeleteCriticalSection(FDataSessionSection);
   OSDeAllocCriticalSection(FDataSessionSection);
   if (FLocaleList <> nil) then
      begin
      FreeLocales;
      FLocaleList.Free;
      FLocaleList:=nil;
      end;
   if (FPhysicalFileList <> nil) then
      begin
      FreePhysicalFiles;
      FPhysicalFileList.Free;
      FPhysicalFileList:=nil;
      end;
   if (FMemoryFileList <> nil) then
      begin
      FreeMemoryFiles;
      FMemoryFileList.Free;
      FMemoryFileList:=nil;
      end;
   OSDeleteCriticalSection(FPhysicalFileListSection);
   OSDeAllocCriticalSection(FPhysicalFileListSection);
   OSDeleteCriticalSection(FMemoryFileListSection);
   OSDeAllocCriticalSection(FMemoryFileListSection);
   OSDeleteCriticalSection(FErrorSection);
   OSDeAllocCriticalSection(FErrorSection);
   OSDeleteCriticalSection(FLocaleSection);
   OSDeAllocCriticalSection(FLocaleSection);
   inherited;
end;


procedure TDataEngine.SetSignature(const Value: string);
begin
   FSignature:=Value;
   FSignatureDigest:=MD5String(Value);
end;

{ Version 5 }
{$WARNINGS OFF}
procedure TDataEngine.PopulateLocales;
var
   TempDataLocale: TDataLocale;
begin
   EnumSystemLocales(@LocalesCallback,LCID_SUPPORTED);
   FLocaleList.Sort(CompareLocales);
   TempDataLocale:=TDataLocale.Create(Self);
   with TempDataLocale do
      begin
      ID:=LOCALE_ANSI_STD;
      Name:=ANSI_STD_LONG_NAME;
      ShortName:=ANSI_STD_SHORT_NAME;
      end;
   FLocaleList.Insert(0,TempDataLocale);
end;
{$WARNINGS ON}
{ Version 5 }

procedure TDataEngine.FreeLocales;
var
   I: Integer;
begin
   for I:=FLocaleList.Count-1 downto 0 do
      begin
      TDataLocale(FLocaleList[I]).Free;
      FLocaleList.Delete(I);
      end;
end;

function TDataEngine.IsValidLocale(LocaleID: Integer): Boolean;
begin
   Result:=(LocaleID=LOCALE_ANSI_STD) or
           ((LocaleID <> LOCALE_ANSI_STD) and OSValidLocale(LocaleID));
end;

function TDataEngine.IsValidLocaleConstant(const LocaleConstant: string): Boolean;
var
   I: Integer;
begin
   Result:=False;
   for I:=0 to FLocaleList.Count-1 do
      begin
      if (AnsiCompareText(TDataLocale(FLocaleList[I]).Name,LocaleConstant)=0) then
         begin
         Result:=True;
         Break;
         end;
      end;
end;

function TDataEngine.ConvertLocaleConstantToID(const LocaleConstant: string): Integer;
var
   I: Integer;
begin
   Result:=LOCALE_ANSI_STD;
   for I:=0 to FLocaleList.Count-1 do
      begin
      if (AnsiCompareText(TDataLocale(FLocaleList[I]).Name,LocaleConstant)=0) then
         begin
         Result:=TDataLocale(FLocaleList[I]).ID;
         Break;
         end;
      end;
end;

function TDataEngine.ConvertIDToLocaleConstant(LocaleID: Integer): string;
var
   I: Integer;
begin
   Result:='';
   for I:=0 to FLocaleList.Count-1 do
      begin
      if (TDataLocale(FLocaleList[I]).ID=LocaleID) then
         begin
         Result:=TDataLocale(FLocaleList[I]).Name;
         Break;
         end;
      end;
end;

function TDataEngine.GetLocaleCharMap(LocaleID: Integer): TLocaleCharMap;
var
   I: Integer;
begin
   Result:=TDataLocale(FLocaleList[0]).GetCharMap;  { Always ANSI Standard at position 0 }
   for I:=0 to FLocaleList.Count-1 do
      begin
      if (TDataLocale(FLocaleList[I]).ID=LocaleID) then
         begin
         Result:=TDataLocale(FLocaleList[I]).GetCharMap;
         Break;
         end;
      end;
end;

procedure TDataEngine.GetLocaleNames(List: TStrings);
var
   I: Integer;
begin
   List.Clear;
   for I:=0 to FLocaleList.Count-1 do
      List.AddObject(TDataLocale(FLocaleList[I]).Name,
                     TObject(TDataLocale(FLocaleList[I]).ID));
end;

{ Language support functions (obsolete but used with upgrade) }

procedure TDataEngine.LockLocaleSettings;
begin
   OSEnterCriticalSection(FLocaleSection);
end;

procedure TDataEngine.UnlockLocaleSettings;
begin
   OSLeaveCriticalSection(FLocaleSection);
end;

{$WARNINGS OFF}
procedure TDataEngine.GetDefaultLocaleSettings(LocaleID: Integer;
                                               var LocaleSettings: TLocaleSettings);
var
   HourFormat: string;
   TimePostfix: string;
begin
   if (LocaleID=LOCALE_ANSI_STD) then
      begin
      with LocaleSettings do
         begin
         CurrencyString:='';
         CurrencyFormat:=0;
         NegCurrFormat:=0;
         ThousandSeparator:=',';
         DecimalSeparator:='.';
         CurrencyDecimals:=2;
         DateSeparator:='-';
         ShortDateFormat:='yyyy-mm-dd';
         LongDateFormat:='dddd, mmmm dd, yyyy';
         TimeSeparator:=':';
         TimeAMString:='AM';
         TimePMString:='PM';
         HourFormat:='hh';
         TimePostfix:=' AMPM';
         ShortTimeFormat:=HourFormat+':mm';
         LongTimeFormat:=HourFormat+':mm:ss';
         ShortMonthNames[1]:='Jan';
         LongMonthNames[1]:='January';
         ShortMonthNames[2]:='Feb';
         LongMonthNames[2]:='February';
         ShortMonthNames[3]:='Mar';
         LongMonthNames[3]:='March';
         ShortMonthNames[4]:='Apr';
         LongMonthNames[4]:='April';
         ShortMonthNames[5]:='May';
         LongMonthNames[5]:='May';
         ShortMonthNames[6]:='Jun';
         LongMonthNames[6]:='June';
         ShortMonthNames[7]:='Jul';
         LongMonthNames[7]:='July';
         ShortMonthNames[8]:='Aug';
         LongMonthNames[8]:='August';
         ShortMonthNames[9]:='Sep';
         LongMonthNames[9]:='September';
         ShortMonthNames[10]:='Oct';
         LongMonthNames[10]:='October';
         ShortMonthNames[11]:='Nov';
         LongMonthNames[11]:='November';
         ShortMonthNames[12]:='Dec';
         LongMonthNames[12]:='December';
         ShortDayNames[1]:='Sun';
         LongDayNames[1]:='Sunday';
         ShortDayNames[2]:='Mon';
         LongDayNames[2]:='Monday';
         ShortDayNames[3]:='Tue';
         LongDayNames[3]:='Tuesday';
         ShortDayNames[4]:='Wed';
         LongDayNames[4]:='Wednesday';
         ShortDayNames[5]:='Thu';
         LongDayNames[5]:='Thursday';
         ShortDayNames[6]:='Fri';
         LongDayNames[6]:='Friday';
         ShortDayNames[7]:='Sat';
         LongDayNames[7]:='Saturday';
         end;
      end
   else
      begin
      with LocaleSettings do
         begin
         CurrencyString:=GetLocaleStr(LocaleID,LOCALE_SCURRENCY or LOCALE_NOUSEROVERRIDE,'$');
         CurrencyFormat:=StrToIntDef(GetLocaleStr(LocaleID,LOCALE_ICURRENCY or LOCALE_NOUSEROVERRIDE,'0'),0);
         NegCurrFormat:=StrToIntDef(GetLocaleStr(LocaleID,LOCALE_INEGCURR or LOCALE_NOUSEROVERRIDE,'0'),0);
         ThousandSeparator:=GetLocaleChar(LocaleID,LOCALE_STHOUSAND or LOCALE_NOUSEROVERRIDE,',');
         DecimalSeparator:=GetLocaleChar(LocaleID,LOCALE_SDECIMAL or LOCALE_NOUSEROVERRIDE,'.');
         CurrencyDecimals:=StrToIntDef(GetLocaleStr(LocaleID,LOCALE_ICURRDIGITS or LOCALE_NOUSEROVERRIDE,'0'),2);
         DateSeparator:=GetLocaleChar(LocaleID,LOCALE_SDATE or LOCALE_NOUSEROVERRIDE,'/');
         ShortDateFormat:=GetLocaleStr(LocaleID,LOCALE_SSHORTDATE or LOCALE_NOUSEROVERRIDE,'M/d/yyyy');
         LongDateFormat:=GetLocaleStr(LocaleID,LOCALE_SLONGDATE or LOCALE_NOUSEROVERRIDE,'dddd, MMMM dd, yyyy');
         TimeSeparator:=GetLocaleChar(LocaleID,LOCALE_STIME or LOCALE_NOUSEROVERRIDE,':');
         TimeAMString:=GetLocaleStr(LocaleID,LOCALE_S1159 or LOCALE_NOUSEROVERRIDE,'AM');
         TimePMString:=GetLocaleStr(LocaleID,LOCALE_S2359 or LOCALE_NOUSEROVERRIDE,'PM');
         if StrToIntDef(GetLocaleStr(LocaleID,LOCALE_ITLZERO or LOCALE_NOUSEROVERRIDE,'0'),0) = 0 then
            HourFormat:='h'
         else
            HourFormat:='hh';
         if StrToIntDef(GetLocaleStr(LocaleID,LOCALE_ITIME or LOCALE_NOUSEROVERRIDE,'0'),0) = 0 then
            TimePostfix:=' AMPM'
         else
            TimePostfix:='';
         ShortTimeFormat:=HourFormat+':mm'+TimePostfix;
         LongTimeFormat:=HourFormat+':mm:ss'+TimePostfix;
         ShortMonthNames[1]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME1 or LOCALE_NOUSEROVERRIDE,'Jan');
         LongMonthNames[1]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME1 or LOCALE_NOUSEROVERRIDE,'January');
         ShortMonthNames[2]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME2 or LOCALE_NOUSEROVERRIDE,'Feb');
         LongMonthNames[2]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME2 or LOCALE_NOUSEROVERRIDE,'February');
         ShortMonthNames[3]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME3 or LOCALE_NOUSEROVERRIDE,'Mar');
         LongMonthNames[3]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME3 or LOCALE_NOUSEROVERRIDE,'March');
         ShortMonthNames[4]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME4 or LOCALE_NOUSEROVERRIDE,'Apr');
         LongMonthNames[4]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME4 or LOCALE_NOUSEROVERRIDE,'April');
         ShortMonthNames[5]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME5 or LOCALE_NOUSEROVERRIDE,'May');
         LongMonthNames[5]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME5 or LOCALE_NOUSEROVERRIDE,'May');
         ShortMonthNames[6]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME6 or LOCALE_NOUSEROVERRIDE,'Jun');
         LongMonthNames[6]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME6 or LOCALE_NOUSEROVERRIDE,'June');
         ShortMonthNames[7]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME7 or LOCALE_NOUSEROVERRIDE,'Jul');
         LongMonthNames[7]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME7 or LOCALE_NOUSEROVERRIDE,'July');
         ShortMonthNames[8]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME8 or LOCALE_NOUSEROVERRIDE,'Aug');
         LongMonthNames[8]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME8 or LOCALE_NOUSEROVERRIDE,'August');
         ShortMonthNames[9]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME9 or LOCALE_NOUSEROVERRIDE,'Sep');
         LongMonthNames[9]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME9 or LOCALE_NOUSEROVERRIDE,'September');
         ShortMonthNames[10]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME10 or LOCALE_NOUSEROVERRIDE,'Oct');
         LongMonthNames[10]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME10 or LOCALE_NOUSEROVERRIDE,'October');
         ShortMonthNames[11]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME11 or LOCALE_NOUSEROVERRIDE,'Nov');
         LongMonthNames[11]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME11 or LOCALE_NOUSEROVERRIDE,'November');
         ShortMonthNames[12]:=GetLocaleStr(LocaleID,LOCALE_SABBREVMONTHNAME12 or LOCALE_NOUSEROVERRIDE,'Dec');
         LongMonthNames[12]:=GetLocaleStr(LocaleID,LOCALE_SMONTHNAME12 or LOCALE_NOUSEROVERRIDE,'December');
         ShortDayNames[1]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME7 or LOCALE_NOUSEROVERRIDE,'Sun');
         LongDayNames[1]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME7 or LOCALE_NOUSEROVERRIDE,'Sunday');
         ShortDayNames[2]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME1 or LOCALE_NOUSEROVERRIDE,'Mon');
         LongDayNames[2]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME1 or LOCALE_NOUSEROVERRIDE,'Monday');
         ShortDayNames[3]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME2 or LOCALE_NOUSEROVERRIDE,'Tue');
         LongDayNames[3]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME2 or LOCALE_NOUSEROVERRIDE,'Tuesday');
         ShortDayNames[4]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME3 or LOCALE_NOUSEROVERRIDE,'Wed');
         LongDayNames[4]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME3 or LOCALE_NOUSEROVERRIDE,'Wednesday');
         ShortDayNames[5]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME4 or LOCALE_NOUSEROVERRIDE,'Thu');
         LongDayNames[5]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME4 or LOCALE_NOUSEROVERRIDE,'Thursday');
         ShortDayNames[6]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME5 or LOCALE_NOUSEROVERRIDE,'Fri');
         LongDayNames[6]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME5 or LOCALE_NOUSEROVERRIDE,'Friday');
         ShortDayNames[7]:=GetLocaleStr(LocaleID,LOCALE_SABBREVDAYNAME6 or LOCALE_NOUSEROVERRIDE,'Sat');
         LongDayNames[7]:=GetLocaleStr(LocaleID,LOCALE_SDAYNAME6 or LOCALE_NOUSEROVERRIDE,'Saturday');
         end;
      end;
end;
{$WARNINGS ON}

procedure TDataEngine.GetLocaleSettings(var LocaleSettings: TLocaleSettings);
var
   I: Byte;
begin
   LocaleSettings.CurrencyString:=CurrencyString;
   LocaleSettings.CurrencyFormat:=CurrencyFormat;
   LocaleSettings.NegCurrFormat:=NegCurrFormat;
   LocaleSettings.ThousandSeparator:=ThousandSeparator;
   LocaleSettings.DecimalSeparator:=DecimalSeparator;
   LocaleSettings.CurrencyDecimals:=CurrencyDecimals;
   LocaleSettings.DateSeparator:=DateSeparator;
   LocaleSettings.ShortDateFormat:=ShortDateFormat;
   LocaleSettings.LongDateFormat:=LongDateFormat;
   LocaleSettings.TimeSeparator:=TimeSeparator;
   LocaleSettings.TimeAMString:=TimeAMString;
   LocaleSettings.TimePMString:=TimePMString;
   LocaleSettings.ShortTimeFormat:=ShortTimeFormat;
   LocaleSettings.LongTimeFormat:=LongTimeFormat;
   for I:=1 to 12 do
      begin
      LocaleSettings.ShortMonthNames[I]:=ShortMonthNames[I];
      LocaleSettings.LongMonthNames[I]:=LongMonthNames[I];
      end;
   for I:=1 to 7 do
      begin
      LocaleSettings.ShortDayNames[I]:=ShortDayNames[I];
      LocaleSettings.LongDayNames[I]:=LongDayNames[I];
      end;
end;

procedure TDataEngine.SetLocaleSettings(var NewLocaleSettings: TLocaleSettings);
var
   I: Byte;
begin
   CurrencyString:=NewLocaleSettings.CurrencyString;
   CurrencyFormat:=NewLocaleSettings.CurrencyFormat;
   NegCurrFormat:=NewLocaleSettings.NegCurrFormat;
   ThousandSeparator:=NewLocaleSettings.ThousandSeparator;
   DecimalSeparator:=NewLocaleSettings.DecimalSeparator;
   CurrencyDecimals:=NewLocaleSettings.CurrencyDecimals;
   DateSeparator:=NewLocaleSettings.DateSeparator;
   ShortDateFormat:=NewLocaleSettings.ShortDateFormat;
   LongDateFormat:=NewLocaleSettings.LongDateFormat;
   TimeSeparator:=NewLocaleSettings.TimeSeparator;
   TimeAMString:=NewLocaleSettings.TimeAMString;
   TimePMString:=NewLocaleSettings.TimePMString;
   ShortTimeFormat:=NewLocaleSettings.ShortTimeFormat;
   LongTimeFormat:=NewLocaleSettings.LongTimeFormat;
   for I:=1 to 12 do
      begin
      ShortMonthNames[I]:=NewLocaleSettings.ShortMonthNames[I];
      LongMonthNames[I]:=NewLocaleSettings.LongMonthNames[I];
      end;
   for I:=1 to 7 do
      begin
      ShortDayNames[I]:=NewLocaleSettings.ShortDayNames[I];
      LongDayNames[I]:=NewLocaleSettings.LongDayNames[I];
      end;
end;

procedure TDataEngine.FreePhysicalFiles;
var
   I: Integer;
begin
   for I:=FPhysicalFileList.Count-1 downto 0 do
      begin
      TPhysicalFile(FPhysicalFileList[I]).Free;
      FPhysicalFileList.Delete(I);
      end;
end;

procedure TDataEngine.FreeMemoryFiles;
var
   I: Integer;
begin
   for I:=FMemoryFileList.Count-1 downto 0 do
      begin
      TMemoryFile(FMemoryFileList[I]).Free;
      FMemoryFileList.Delete(I);
      end;
end;

procedure TDataEngine.LockPhysicalFileList;
begin
   OSEnterCriticalSection(FPhysicalFileListSection);
end;

procedure TDataEngine.UnlockPhysicalFileList;
begin
   OSLeaveCriticalSection(FPhysicalFileListSection);
end;

procedure TDataEngine.LockMemoryFileList;
begin
   OSEnterCriticalSection(FMemoryFileListSection);
end;

procedure TDataEngine.UnlockMemoryFileList;
begin
   OSLeaveCriticalSection(FMemoryFileListSection);
end;

procedure TDataEngine.LockErrorInformation;
begin
   OSEnterCriticalSection(FErrorSection);
end;

procedure TDataEngine.UnlockErrorInformation;
begin
   OSLeaveCriticalSection(FErrorSection);
end;

procedure TDataEngine.AssignErrorContexts(ErrorCode: Word;
                                          OSErrorCode: Integer;
                                          SocketErrorCode: Integer;
                                          const ErrorRemoteName: string;
                                          const ErrorUserName: string;
                                          const ErrorDatabaseName: string;
                                          const ErrorTableName: string;
                                          const ErrorFieldName: string;
                                          const ErrorIndexName: string;
                                          const ErrorMessage: string;
                                          const ErrorProcedureName: string;
                                          const ErrorEventName: string;
                                          ErrorLine: Integer; ErrorColumn: Integer);
begin
   FLastErrorNumber:=ErrorCode;
   FLastOSErrorNumber:=OSErrorCode;
   FLastSocketErrorNumber:=SocketErrorCode;
   FLastErrorRemoteName:=ErrorRemoteName;
   FLastErrorUserName:=ErrorUserName;
   FLastErrorDatabaseName:=ErrorDatabaseName;
   FLastErrorTableName:=ErrorTableName;
   FLastErrorFieldName:=ErrorFieldName;
   FLastErrorIndexName:=ErrorIndexName;
   FLastErrorMessage:=ErrorMessage;
   FLastErrorProcedureName:=ErrorProcedureName;
   FLastErrorEventName:=ErrorEventName;
   FLastErrorLine:=ErrorLine;
   FLastErrorColumn:=ErrorColumn;
end;

procedure TDataEngine.ClearErrorContexts;
begin
   FLastErrorNumber:=0;
   FLastOSErrorNumber:=0;
   FLastSocketErrorNumber:=0;
   FLastErrorRemoteName:='';
   FLastErrorUserName:='';
   FLastErrorDatabaseName:='';
   FLastErrorTableName:='';
   FLastErrorFieldName:='';
   FLastErrorIndexName:='';
   FLastErrorMessage:='';
   FLastErrorProcedureName:='';
   FLastErrorEventName:='';
   FLastErrorLine:=0;
   FLastErrorColumn:=0;
end;

procedure TDataEngine.GetErrorString(ErrorCode: Word; Msg: PChar);
var
   TempMsg: string;
begin
   case ErrorCode of
      DBISAM_OSUNKNOWN:
         TempMsg:=Format(DBISAM_ERRSTR_OSUNKNOWN,[FLastOSErrorNumber,
                                                  FLastErrorTableName]);
      DBISAM_OSENOMEM:
         TempMsg:=DBISAM_ERRSTR_OSENOMEM;
      DBISAM_OSENOENT:
         TempMsg:=Format(DBISAM_ERRSTR_OSENOENT,[FLastErrorTableName]);
      DBISAM_OSEACCES:
         TempMsg:=Format(DBISAM_ERRSTR_OSEACCES,[FLastErrorTableName]);
      DBISAM_OSENODEV:
         TempMsg:=Format(DBISAM_ERRSTR_OSENODEV,[FLastErrorTableName]);
      DBISAM_LOCKREADLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_LOCKREADLOCK,[FLastErrorDatabaseName]);
      DBISAM_LOCKREADUNLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_LOCKREADUNLOCK,[FLastErrorDatabaseName]);
      DBISAM_LOCKWRITELOCK:
         TempMsg:=Format(DBISAM_ERRSTR_LOCKWRITELOCK,[FLastErrorDatabaseName]);
      DBISAM_LOCKWRITEUNLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_LOCKWRITEUNLOCK,[FLastErrorDatabaseName]);
      DBISAM_READLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_READLOCK,[FLastErrorTableName]);
      DBISAM_READUNLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_READUNLOCK,[FLastErrorTableName]);
      DBISAM_WRITELOCK:
         TempMsg:=Format(DBISAM_ERRSTR_WRITELOCK,[FLastErrorTableName]);
      DBISAM_WRITEUNLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_WRITEUNLOCK,[FLastErrorTableName]);
      DBISAM_TRANSLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_TRANSLOCK,[FLastErrorDatabaseName]);
      DBISAM_TRANSUNLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_TRANSUNLOCK,[FLastErrorDatabaseName]);
      DBISAM_LOCKED:
         TempMsg:=Format(DBISAM_ERRSTR_LOCKED,[FLastErrorTableName]);
      DBISAM_UNLOCKFAILED:
         TempMsg:=Format(DBISAM_ERRSTR_UNLOCKFAILED,[FLastErrorTableName]);
      DBISAM_TABLEOPEN:
         TempMsg:=Format(DBISAM_ERRSTR_TABLEOPEN,[FLastErrorTableName]);
      DBISAM_READERR:
         TempMsg:=Format(DBISAM_ERRSTR_READERR,[FLastErrorTableName]);
      DBISAM_WRITEERR:
         TempMsg:=Format(DBISAM_ERRSTR_WRITEERR,[FLastErrorTableName]);
      DBISAM_RECLOCKFAILED:
         TempMsg:=Format(DBISAM_ERRSTR_RECLOCKFAILED,[FLastErrorTableName]);
      DBISAM_OSEMFILE:
         TempMsg:=Format(DBISAM_ERRSTR_OSEMFILE,[FLastErrorTableName]);
      DBISAM_OSEBADF:
         TempMsg:=Format(DBISAM_ERRSTR_OSEBADF,[FLastErrorTableName]);
      DBISAM_OSENOTSAM:
         TempMsg:=Format(DBISAM_ERRSTR_OSENOTSAM,[FLastErrorTableName]);
      DBISAM_OLDVERSION:
         TempMsg:=Format(DBISAM_ERRSTR_OLDVERSION,[FLastErrorTableName]);
      DBISAM_BADSIGNATURE:
         TempMsg:=Format(DBISAM_ERRSTR_BADSIGNATURE,[FLastErrorTableName]);
      DBISAM_KEYVIOL:
         TempMsg:=Format(DBISAM_ERRSTR_KEYVIOL,[FLastErrorIndexName,
                                                FLastErrorTableName]);
      DBISAM_KEYORRECDELETED:
         TempMsg:=Format(DBISAM_ERRSTR_KEYORRECDELETED,[FLastErrorTableName]);
      DBISAM_RECTOOBIG:
         TempMsg:=Format(DBISAM_ERRSTR_RECTOOBIG,[FLastErrorTableName]);
      DBISAM_FLDLIMIT:
         TempMsg:=Format(DBISAM_ERRSTR_FLDLIMIT,[FLastErrorTableName]);
      DBISAM_INDEXLIMIT:
         TempMsg:=Format(DBISAM_ERRSTR_INDEXLIMIT,[FLastErrorTableName]);
      DBISAM_RECNOTFOUND:
         TempMsg:=Format(DBISAM_ERRSTR_RECNOTFOUND,[FLastErrorTableName]);
      DBISAM_NEEDEXCLACCESS:
         TempMsg:=Format(DBISAM_ERRSTR_NEEDEXCLACCESS,[FLastErrorTableName]);
      DBISAM_HEADERCORRUPT:
         TempMsg:=Format(DBISAM_ERRSTR_HEADERCORRUPT,[FLastErrorTableName]);
      DBISAM_FILECORRUPT:
         TempMsg:=Format(DBISAM_ERRSTR_FILECORRUPT,[FLastErrorTableName]);
      DBISAM_INDEXCORRUPT:
         TempMsg:=Format(DBISAM_ERRSTR_INDEXCORRUPT,[FLastErrorTableName]);
      DBISAM_MEMOCORRUPT:
         TempMsg:=Format(DBISAM_ERRSTR_MEMOCORRUPT,[FLastErrorTableName]);
      DBISAM_OUTOFRANGE:
         TempMsg:=Format(DBISAM_ERRSTR_OUTOFRANGE,[FLastErrorFieldName,
                                                   FLastErrorTableName]);
      DBISAM_INVALIDKEY:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDKEY,[FLastErrorIndexName,
                                                   FLastErrorTableName]);
      DBISAM_REQDERR:
         TempMsg:=Format(DBISAM_ERRSTR_REQDERR,[FLastErrorFieldName,
                                                FLastErrorTableName]);
      DBISAM_MINVALERR:
         TempMsg:=Format(DBISAM_ERRSTR_MINVALERR,[FLastErrorFieldName,
                                                  FLastErrorTableName]);
      DBISAM_MAXVALERR:
         TempMsg:=Format(DBISAM_ERRSTR_MAXVALERR,[FLastErrorFieldName,
                                                  FLastErrorTableName]);
      DBISAM_INVALIDFLDTYPE:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDFLDTYPE,[FLastErrorFieldName,
                                                       FLastErrorTableName]);
      DBISAM_SEARCHCOLREQD:
         TempMsg:=Format(DBISAM_ERRSTR_SEARCHCOLREQD,[FLastErrorFieldName,
                                                      FLastErrorIndexName,
                                                      FLastErrorTableName]);
      DBISAM_INVALIDBLOBLEN:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDBLOBLEN,[FLastErrorTableName]);
      DBISAM_NOTABLOB:
         TempMsg:=Format(DBISAM_ERRSTR_NOTABLOB,[FLastErrorFieldName,
                                                 FLastErrorTableName]);
      DBISAM_ENDOFBLOB:
         TempMsg:=Format(DBISAM_ERRSTR_ENDOFBLOB,[FLastErrorTableName]);
      DBISAM_INVALIDBLOBOFFSET:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDBLOBOFFSET,[FLastErrorTableName]);
      DBISAM_INVALIDBLOBHANDLE:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDBLOBHANDLE,[FLastErrorTableName]);
      DBISAM_OPENBLOBLIMIT:
         TempMsg:=Format(DBISAM_ERRSTR_OPENBLOBLIMIT,[FLastErrorTableName]);
      DBISAM_BLOBLIMIT:
         TempMsg:=Format(DBISAM_ERRSTR_BLOBLIMIT,[FLastErrorTableName]);
      DBISAM_BOF:
         TempMsg:=Format(DBISAM_ERRSTR_BOF,[FLastErrorTableName]);
      DBISAM_EOF:
         TempMsg:=Format(DBISAM_ERRSTR_EOF,[FLastErrorTableName]);
      DBISAM_PRIMARYKEYREDEFINE:
         TempMsg:=Format(DBISAM_ERRSTR_PRIMARYKEYREDEFINE,[FLastErrorTableName]);
      DBISAM_INDEXNAMEREQUIRED:
         TempMsg:=Format(DBISAM_ERRSTR_INDEXNAMEREQUIRED,[FLastErrorTableName]);
      DBISAM_INDEXEXISTS:
         TempMsg:=Format(DBISAM_ERRSTR_INDEXEXISTS,[FLastErrorIndexName,
                                                    FLastErrorTableName]);
      DBISAM_INVALIDINDEXNAME:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDINDEXNAME,[FLastErrorIndexName,
                                                         FLastErrorTableName]);
      DBISAM_INVALIDIDXDESC:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDIDXDESC,[FLastErrorFieldName,
                                                       FLastErrorIndexName,
                                                       FLastErrorTableName]);
      DBISAM_INVALIDFILTER:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDFILTER,[FLastErrorTableName,
                                                      FLastErrorMessage,
                                                      FLastErrorLine,
                                                      FLastErrorColumn]);
      DBISAM_NOSUCHFILTER:
         TempMsg:=Format(DBISAM_ERRSTR_NOSUCHFILTER,[FLastErrorTableName]);
      DBISAM_INTERNALLIMIT:
         TempMsg:=Format(DBISAM_ERRSTR_INTERNALLIMIT,[FLastErrorTableName]);
      DBISAM_INVALIDFIELDNAME:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDFIELDNAME,[FLastErrorFieldName,
                                                         FLastErrorTableName]);
      DBISAM_INVALIDVCHKSTRUCT:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDVCHKSTRUCT,[FLastErrorFieldName,
                                                          FLastErrorTableName]);
      DBISAM_NOTSUFFTABLERIGHTS:
         TempMsg:=Format(DBISAM_ERRSTR_NOTSUFFTABLERIGHTS,[FLastErrorTableName]);
      DBISAM_INVALIDPASSWORD:
         TempMsg:=Format(DBISAM_ERRSTR_INVALIDPASSWORD,[FLastErrorTableName]);
      DBISAM_CANNOTLOADLDDRV:
         TempMsg:=Format(DBISAM_ERRSTR_CANNOTLOADLDDRV,[FLastErrorTableName]);
      DBISAM_SQLPARSE:
         TempMsg:=Format(DBISAM_ERRSTR_SQLPARSE,[FLastErrorMessage,FLastErrorLine,
                                                 FLastErrorColumn]);
      DBISAM_SQLEXEC:
         TempMsg:=Format(DBISAM_ERRSTR_SQLEXEC,[FLastErrorMessage]);
      DBISAM_TABLEFULL:
         TempMsg:=Format(DBISAM_ERRSTR_TABLEFULL,[FLastErrorTableName]);
      DBISAM_DATABASEFULL:
         TempMsg:=Format(DBISAM_ERRSTR_DATABASEFULL,[FLastErrorDatabaseName]);
      DBISAM_NOCURRREC:
         TempMsg:=Format(DBISAM_ERRSTR_NOCURRREC,[FLastErrorTableName]);
      DBISAM_TABLEEXISTS:
         TempMsg:=Format(DBISAM_ERRSTR_TABLEEXISTS,[FLastErrorTableName]);
      DBISAM_COMPRESS:
         TempMsg:=DBISAM_ERRSTR_COMPRESS;
      DBISAM_UNCOMPRESS:
         TempMsg:=DBISAM_ERRSTR_UNCOMPRESS;
      DBISAM_REMOTECOMMLOST:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTECOMMLOST,[FLastErrorRemoteName]);
      DBISAM_REMOTEENCRYPTREQ:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEENCRYPTREQ,[FLastErrorRemoteName]);
      DBISAM_REMOTEUNKNOWN:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEUNKNOWN,[FLastErrorMessage,
                                                      FLastErrorRemoteName]);
      DBISAM_REMOTECONNECT:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTECONNECT,[FLastErrorRemoteName]);
      DBISAM_REMOTENOLOGIN:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOLOGIN,[FLastErrorRemoteName]);
      DBISAM_REMOTEMAXCONNECT:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEMAXCONNECT,[FLastErrorRemoteName]);
      DBISAM_REMOTEADDRESSBLOCK:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEADDRESSBLOCK,[FLastErrorRemoteName]);
      DBISAM_REMOTECALLBACKERR:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTECALLBACKERR,[FLastErrorRemoteName]);
      DBISAM_REMOTEVERSION:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEVERSION,[FLastErrorRemoteName]);
      DBISAM_REMOTEINVLOGIN:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVLOGIN,[FLastErrorRemoteName]);
      DBISAM_REMOTENOTAUTH:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOTAUTH,[FLastErrorUserName,
                                                      FLastErrorDatabaseName,
                                                      FLastErrorRemoteName]);
      DBISAM_REMOTENOTADMIN:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOTADMIN,[FLastErrorUserName,
                                                       FLastErrorRemoteName]);
      DBISAM_REMOTEINVUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVUSER,[FLastErrorRemoteName]);
      DBISAM_REMOTENOUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOUSER,[FLastErrorUserName,
                                                     FLastErrorRemoteName]);
      DBISAM_REMOTEDUPUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPUSER,[FLastErrorUserName,
                                                      FLastErrorRemoteName]);
      DBISAM_REMOTEINVDB:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVDB,[FLastErrorRemoteName]);
      DBISAM_REMOTENODB:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENODB,[FLastErrorDatabaseName,
                                                   FLastErrorRemoteName]);
      DBISAM_REMOTEDUPDB:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPDB,[FLastErrorDatabaseName,
                                                    FLastErrorRemoteName]);
      DBISAM_REMOTEINVDBUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVDBUSER,[FLastErrorRemoteName]);
      DBISAM_REMOTENODBUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENODBUSER,[FLastErrorUserName,
                                                       FLastErrorDatabaseName,
                                                       FLastErrorRemoteName]);
      DBISAM_REMOTEDUPDBUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPDBUSER,[FLastErrorUserName,
                                                        FLastErrorDatabaseName,
                                                        FLastErrorRemoteName]);
      DBISAM_REMOTEINVPROC:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVPROC,[FLastErrorRemoteName]);
      DBISAM_REMOTENOPROC:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOPROC,[FLastErrorProcedureName,
                                                     FLastErrorRemoteName]);
      DBISAM_REMOTEDUPPROC:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPPROC,[FLastErrorProcedureName,
                                                       FLastErrorRemoteName]);
      DBISAM_REMOTEINVPROCUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVPROCUSER,[FLastErrorRemoteName]);
      DBISAM_REMOTENOPROCUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOPROCUSER,[FLastErrorUserName,
                                                          FLastErrorProcedureName,
                                                          FLastErrorRemoteName]);
      DBISAM_REMOTEDUPPROCUSER:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPPROCUSER,[FLastErrorUserName,
                                                           FLastErrorProcedureName,
                                                           FLastErrorRemoteName]);
      DBISAM_REMOTEINVEVENT:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVEVENT,[FLastErrorRemoteName]);
      DBISAM_REMOTENOEVENT:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTENOEVENT,[FLastErrorEventName,
                                                     FLastErrorRemoteName]);
      DBISAM_REMOTEDUPEVENT:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEDUPEVENT,[FLastErrorEventName,
                                                      FLastErrorRemoteName]);
      DBISAM_REMOTEINVREQUEST:
         TempMsg:=Format(DBISAM_ERRSTR_REMOTEINVREQUEST,[FLastErrorRemoteName]);
      DBISAM_IMPORTERROR:
         TempMsg:=Format(DBISAM_ERRSTR_IMPORTERROR,[FLastErrorTableName,
                                                    FLastErrorMessage,
                                                    FLastErrorLine,
                                                    FLastErrorColumn]);
      DBISAM_EXPORTERROR:
         TempMsg:=Format(DBISAM_ERRSTR_EXPORTERROR,[FLastErrorTableName,
                                                    FLastErrorMessage]);
      DBISAM_LOADSTREAMERROR:
         TempMsg:=Format(DBISAM_ERRSTR_LOADSTREAMERROR,[FLastErrorTableName,
                                                        FLastErrorMessage]);
      DBISAM_SAVESTREAMERROR:
         TempMsg:=Format(DBISAM_ERRSTR_SAVESTREAMERROR,[FLastErrorTableName,
                                                        FLastErrorMessage]);
      DBISAM_TRIGGERERROR:
         TempMsg:=Format(DBISAM_ERRSTR_TRIGGERERROR,[FLastErrorTableName,
                                                     FLastErrorMessage]);
      else
         TempMsg:='An unknown error occurred';
      end;
   StrPLCopy(Msg,TempMsg,MAX_ERRORMSGLEN);
end;

function TDataEngine.OSError: Integer;
begin
   FOSErrorNumber:=OSLastNativeError;
   Result:=FOSErrorNumber;
end;

procedure TDataEngine.RaiseError(ErrorCode: Word;
                                 const ErrorRemoteName: string='';
                                 const ErrorUserName: string='';
                                 const ErrorDatabaseName: string='';
                                 const ErrorTableName: string='';
                                 const ErrorFieldName: string='';
                                 const ErrorIndexName: string='';
                                 const ErrorMessage: string='';
                                 const ErrorProcedureName: string='';
                                 const ErrorEventName: string='';
                                 ErrorLine: Integer=0; ErrorColumn: Integer=0);
begin
   LockErrorInformation;
   try
      ClearErrorContexts;
      AssignErrorContexts(ErrorCode,
                          FOSErrorNumber,
                          FSocketErrorNumber,
                          ErrorRemoteName,
                          ErrorUserName,
                          ErrorDatabaseName,
                          ErrorTableName,
                          ErrorFieldName,
                          ErrorIndexName,
                          ErrorMessage,
                          ErrorProcedureName,
                          ErrorEventName,
                          ErrorLine,ErrorColumn);
      FOSErrorNumber:=0;
      FSocketErrorNumber:=0;
      DBISAMError(ErrorCode);
   finally
      UnlockErrorInformation;
   end;
end;

function TDataEngine.ConvertExceptionToCode(E: Exception): Word;
begin
   if (E is EDBISAMEngineError) then
      Result:=EDBISAMEngineError(E).ErrorCode
   else
      Result:=DBISAM_OSUNKNOWN;
end;

function TDataEngine.TranslateRequestConstant(Value: Word): string;
begin
   Result:='';
   case Value of
      REQUEST_PING: Result:='REQUEST_PING';
      REQUEST_RECONNECT: Result:='REQUEST_RECONNECT';
      REQUEST_LOGIN: Result:='REQUEST_LOGIN';
      REQUEST_LOGOUT: Result:='REQUEST_LOGOUT';
      REQUEST_SESSIONPARAMS: Result:='REQUEST_SESSIONPARAMS';
      REQUEST_DELALLMEMTABLES: Result:='REQUEST_DELALLMEMTABLES';
      REQUEST_GETTABLENAMES: Result:='REQUEST_GETTABLENAMES';
      REQUEST_OPENDATADIR: Result:='REQUEST_OPENDATADIR';
      REQUEST_CLOSEDATADIR: Result:='REQUEST_CLOSEDATADIR';
      REQUEST_ADDPASSWORD: Result:='REQUEST_ADDPASSWORD';
      REQUEST_DELPASSWORD: Result:='REQUEST_DELPASSWORD';
      REQUEST_DELALLPASSWORDS: Result:='REQUEST_DELALLPASSWORDS';
      REQUEST_GETDBNAMES: Result:='REQUEST_GETDBNAMES';
      REQUEST_STARTTRANS: Result:='REQUEST_STARTTRANS';
      REQUEST_COMMITTRANS: Result:='REQUEST_COMMITTRANS';
      REQUEST_ROLLBACKTRANS: Result:='REQUEST_ROLLBACKTRANS';
      REQUEST_CREATECURSOR: Result:='REQUEST_CREATECURSOR';
      REQUEST_OPENCURSOR: Result:='REQUEST_OPENCURSOR';
      REQUEST_CLOSECURSOR: Result:='REQUEST_CLOSECURSOR';
      REQUEST_FREECURSOR: Result:='REQUEST_FREECURSOR';
      REQUEST_SETINDEXNAME: Result:='REQUEST_SETINDEXNAME';
      REQUEST_SETTOBEGIN: Result:='REQUEST_SETTOBEGIN';
      REQUEST_SETTOEND: Result:='REQUEST_SETTOEND';
      REQUEST_SETTORECNO: Result:='REQUEST_SETTORECNO';
      REQUEST_SETTOCURSOR: Result:='REQUEST_SETTOCURSOR';
      REQUEST_GETCURRECORD: Result:='REQUEST_GETCURRECORD';
      REQUEST_CLONECURRECORD: Result:='REQUEST_CLONECURRECORD';
      REQUEST_GETNEXTRECORD: Result:='REQUEST_GETNEXTRECORD';
      REQUEST_GETPRIORRECORD: Result:='REQUEST_GETPRIORRECORD';
      REQUEST_APPENDRECORD: Result:='REQUEST_APPENDRECORD';
      REQUEST_MODIFYRECORD: Result:='REQUEST_MODIFYRECORD';
      REQUEST_DELETERECORD: Result:='REQUEST_DELETERECORD';
      REQUEST_CANCELRECORD: Result:='REQUEST_CANCELRECORD';
      REQUEST_FLUSHBUFFERS: Result:='REQUEST_FLUSHBUFFERS';
      REQUEST_FLUSHOSBUFFERS: Result:='REQUEST_FLUSHOSBUFFERS';
      REQUEST_REFRESH: Result:='REQUEST_REFRESH';
      REQUEST_SETTOBOOKMARK: Result:='REQUEST_SETTOBOOKMARK';
      REQUEST_FIND: Result:='REQUEST_FIND';
      REQUEST_SETRANGE: Result:='REQUEST_SETRANGE';
      REQUEST_RESETRANGE: Result:='REQUEST_RESETRANGE';
      REQUEST_LOCKTABLE: Result:='REQUEST_LOCKTABLE';
      REQUEST_UNLOCKTABLE: Result:='REQUEST_UNLOCKTABLE';
      REQUEST_UNLOCKRECORD: Result:='REQUEST_UNLOCKRECORD';
      REQUEST_LOCKSEMAPHORE: Result:='REQUEST_LOCKSEMAPHORE';
      REQUEST_UNLOCKSEMAPHORE: Result:='REQUEST_UNLOCKSEMAPHORE';
      REQUEST_GETDATAHEADER: Result:='REQUEST_GETDATAHEADER';
      REQUEST_TABLEEXISTS: Result:='REQUEST_TABLEEXISTS';
      REQUEST_TABLESIZE: Result:='REQUEST_TABLESIZE';
      REQUEST_CREATETABLE: Result:='REQUEST_CREATETABLE';
      REQUEST_ALTERTABLE: Result:='REQUEST_ALTERTABLE';
      REQUEST_REPAIRTABLE: Result:='REQUEST_REPAIRTABLE';
      REQUEST_UPGRADETABLE: Result:='REQUEST_UPGRADETABLE';
      REQUEST_EMPTYTABLE: Result:='REQUEST_EMPTYTABLE';
      REQUEST_DELETETABLE: Result:='REQUEST_DELETETABLE';
      REQUEST_RENAMETABLE: Result:='REQUEST_RENAMETABLE';
      REQUEST_OPTIMIZETABLE: Result:='REQUEST_OPTIMIZETABLE';
      REQUEST_COPYTABLE: Result:='REQUEST_COPYTABLE';
      REQUEST_ADDPRIMARYINDEX: Result:='REQUEST_ADDPRIMARYINDEX';
      REQUEST_ADDSECONDARYINDEX: Result:='REQUEST_ADDSECONDARYINDEX';
      REQUEST_DELETEINDEX: Result:='REQUEST_DELETEINDEX';
      REQUEST_DELETEALLINDEXES: Result:='REQUEST_DELETEALLINDEXES';
      REQUEST_LOCATE: Result:='REQUEST_LOCATE';
      REQUEST_OPENBLOB: Result:='REQUEST_OPENBLOB';
      REQUEST_FREEBLOB: Result:='REQUEST_FREEBLOB';
      REQUEST_FREEALLBLOBS: Result:='REQUEST_FREEALLBLOBS';
      REQUEST_GETBLOB: Result:='REQUEST_GETBLOB';
      REQUEST_PUTBLOB: Result:='REQUEST_PUTBLOB';
      REQUEST_TRUNCATEBLOB: Result:='REQUEST_TRUNCATEBLOB';
      REQUEST_GETBLOBSIZE: Result:='REQUEST_GETBLOBSIZE';
      REQUEST_ADDEXPRFILTER: Result:='REQUEST_ADDEXPRFILTER';
      REQUEST_ADDCALLBACKFILTER: Result:='REQUEST_ADDCALLBACKFILTER';
      REQUEST_DROPFILTER: Result:='REQUEST_DROPFILTER';
      REQUEST_ACTIVATEFILTER: Result:='REQUEST_ACTIVATEFILTER';
      REQUEST_DEACTIVATEFILTER: Result:='REQUEST_DEACTIVATEFILTER';
      REQUEST_GETFILTEROPTIMIZELEVEL: Result:='REQUEST_GETFILTEROPTIMIZELEVEL';
      REQUEST_CALLBACKRESPONSE: Result:='REQUEST_CALLBACKRESPONSE';
      REQUEST_CREATESTMT: Result:='REQUEST_CREATESTMT';
      REQUEST_PREPARESTMT: Result:='REQUEST_PREPARESTMT';
      REQUEST_EXECUTESTMT: Result:='REQUEST_EXECUTESTMT';
      REQUEST_FREESTMT: Result:='REQUEST_FREESTMT';
      REQUEST_SAVERESULT: Result:='REQUEST_SAVERESULT';
      REQUEST_CONNECTPARAMS: Result:='REQUEST_CONNECTPARAMS';
      REQUEST_LOADFROMSTREAM: Result:='REQUEST_LOADFROMSTREAM';
      REQUEST_SAVETOSTREAM: Result:='REQUEST_SAVETOSTREAM';
      REQUEST_GETUSERNAMES: Result:='REQUEST_GETUSERNAMES';
      REQUEST_ADDUSER: Result:='REQUEST_ADDUSER';
      REQUEST_MODIFYUSER: Result:='REQUEST_MODIFYUSER';
      REQUEST_DELETEUSER: Result:='REQUEST_DELETEUSER';
      REQUEST_GETUSER: Result:='REQUEST_GETUSER';
      REQUEST_ADDDB: Result:='REQUEST_ADDDB';
      REQUEST_MODIFYDB: Result:='REQUEST_MODIFYDB';
      REQUEST_DELETEDB: Result:='REQUEST_DELETEDB';
      REQUEST_GETDB: Result:='REQUEST_GETDB';
      REQUEST_GETDBUSERNAMES: Result:='REQUEST_GETDBUSERNAMES';
      REQUEST_ADDDBUSER: Result:='REQUEST_ADDDBUSER';
      REQUEST_MODIFYDBUSER: Result:='REQUEST_MODIFYDBUSER';
      REQUEST_DELETEDBUSER: Result:='REQUEST_DELETEDBUSER';
      REQUEST_GETDBUSER: Result:='REQUEST_GETDBUSER';
      REQUEST_GETPROCNAMES: Result:='REQUEST_GETPROCNAMES';
      REQUEST_ADDPROC: Result:='REQUEST_ADDPROC';
      REQUEST_MODIFYPROC: Result:='REQUEST_MODIFYPROC';
      REQUEST_DELETEPROC: Result:='REQUEST_DELETEPROC';
      REQUEST_GETPROC: Result:='REQUEST_GETPROC';
      REQUEST_GETPROCUSERNAMES: Result:='REQUEST_GETPROCUSERNAMES';
      REQUEST_ADDPROCUSER: Result:='REQUEST_ADDPROCUSER';
      REQUEST_MODIFYPROCUSER: Result:='REQUEST_MODIFYPROCUSER';
      REQUEST_DELETEPROCUSER: Result:='REQUEST_DELETEPROCUSER';
      REQUEST_GETPROCUSER: Result:='REQUEST_GETPROCUSER';
      REQUEST_GETEVENTNAMES: Result:='REQUEST_GETEVENTNAMES';
      REQUEST_ADDEVENT: Result:='REQUEST_ADDEVENT';
      REQUEST_MODIFYEVENT: Result:='REQUEST_MODIFYEVENT';
      REQUEST_DELETEEVENT: Result:='REQUEST_DELETEEVENT';
      REQUEST_GETEVENT: Result:='REQUEST_GETEVENT';
      REQUEST_MODIFYCONFIG: Result:='REQUEST_MODIFYCONFIG';
      REQUEST_GETCONFIG: Result:='REQUEST_GETCONFIG';
      REQUEST_GETLOGCOUNT: Result:='REQUEST_GETLOGCOUNT';
      REQUEST_GETLOGRECORD: Result:='REQUEST_GETLOGRECORD';
      REQUEST_STARTSERVER: Result:='REQUEST_STARTSERVER';
      REQUEST_STOPSERVER: Result:='REQUEST_STOPSERVER';
      REQUEST_GETUPTIME: Result:='REQUEST_GETUPTIME';
      REQUEST_GETMEMORYUSAGE: Result:='REQUEST_GETMEMORYUSAGE';
      REQUEST_GETSERVERNAME: Result:='REQUEST_GETSERVERNAME';
      REQUEST_GETSERVERDESC: Result:='REQUEST_GETSERVERDESC';
      REQUEST_GETMAINADDRESS: Result:='REQUEST_GETMAINADDRESS';
      REQUEST_GETMAINPORT: Result:='REQUEST_GETMAINPORT';
      REQUEST_GETMAINTHREADCACHESIZE: Result:='REQUEST_GETMAINTHREADCACHESIZE';
      REQUEST_GETADMINADDRESS: Result:='REQUEST_GETADMINADDRESS';
      REQUEST_GETADMINPORT: Result:='REQUEST_GETADMINPORT';
      REQUEST_GETADMINTHREADCACHESIZE: Result:='REQUEST_GETADMINTHREADCACHESIZE';
      REQUEST_GETSESSIONS: Result:='REQUEST_GETSESSIONS';
      REQUEST_GETCONNECTEDSESSIONS: Result:='REQUEST_GETCONNECTEDSESSIONS';
      REQUEST_GETSESSIONINFO: Result:='REQUEST_GETSESSIONINFO';
      REQUEST_DISCONNECTSESSION: Result:='REQUEST_DISCONNECTSESSION';
      REQUEST_REMOVESESSION: Result:='REQUEST_REMOVESESSION';
      REQUEST_GETDATETIME: Result:='REQUEST_GETDATETIME';
      REQUEST_GETUTCDATETIME: Result:='REQUEST_GETUTCDATETIME';
      REQUEST_PROCEDURE: Result:='REQUEST_PROCEDURE';
      REQUEST_IMPORTTABLE: Result:='REQUEST_IMPORTTABLE';
      REQUEST_EXPORTTABLE: Result:='REQUEST_EXPORTTABLE';
      REQUEST_TEXTINDEXPARAMS: Result:='REQUEST_TEXTINDEXPARAMS';
      REQUEST_READNEXTRECORDBLOCK: Result:='REQUEST_READNEXTRECORDBLOCK';
      REQUEST_READPRIORRECORDBLOCK: Result:='REQUEST_READPRIORRECORDBLOCK';
      REQUEST_READFIRSTRECORDBLOCK: Result:='REQUEST_READFIRSTRECORDBLOCK';
      REQUEST_READLASTRECORDBLOCK: Result:='REQUEST_READLASTRECORDBLOCK';
      REQUEST_READABSOLUTERECORDBLOCK: Result:='REQUEST_READABSOLUTERECORDBLOCK';
      REQUEST_READBOOKMARKRECORDBLOCK: Result:='REQUEST_READBOOKMARKRECORDBLOCK';
      REQUEST_REFRESHRECORDBLOCK: Result:='REQUEST_REFRESHRECORDBLOCK';
      REQUEST_ADDRECORDBLOCK: Result:='REQUEST_ADDRECORDBLOCK';
      REQUEST_UPDATERECORDBLOCK: Result:='REQUEST_UPDATERECORDBLOCK';
      REQUEST_DELETERECORDBLOCK: Result:='REQUEST_DELETERECORDBLOCK';
      REQUEST_BACKUP: Result:='REQUEST_BACKUP';
      REQUEST_RESTORE: Result:='REQUEST_RESTORE';
      REQUEST_BACKUPINFO: Result:='REQUEST_BACKUPINFO';
      end;
end;

function TDataEngine.TranslateErrorConstant(Value: Word): string;
begin
   Result:='';
   case Value of
      DBISAM_NONE: Result:='DBISAM_NONE';
      DBISAM_OSUNKNOWN: Result:='DBISAM_OSUNKNOWN';
      DBISAM_OSENOMEM: Result:='DBISAM_OSENOMEM';
      DBISAM_OSENOENT: Result:='DBISAM_OSENOENT';
      DBISAM_OSEACCES: Result:='DBISAM_OSEACCES';
      DBISAM_LOCKREADLOCK: Result:='DBISAM_LOCKREADLOCK';
      DBISAM_LOCKREADUNLOCK: Result:='DBISAM_LOCKREADUNLOCK';
      DBISAM_LOCKWRITELOCK: Result:='DBISAM_LOCKWRITELOCK';
      DBISAM_LOCKWRITEUNLOCK: Result:='DBISAM_LOCKWRITEUNLOCK';
      DBISAM_READLOCK: Result:='DBISAM_READLOCK';
      DBISAM_READUNLOCK: Result:='DBISAM_READUNLOCK';
      DBISAM_WRITELOCK: Result:='DBISAM_WRITELOCK';
      DBISAM_WRITEUNLOCK: Result:='DBISAM_WRITEUNLOCK';
      DBISAM_TRANSLOCK: Result:='DBISAM_TRANSLOCK';
      DBISAM_TRANSUNLOCK: Result:='DBISAM_TRANSUNLOCK';
      DBISAM_LOCKED: Result:='DBISAM_LOCKED';
      DBISAM_UNLOCKFAILED: Result:='DBISAM_UNLOCKFAILED';
      DBISAM_TABLEOPEN: Result:='DBISAM_TABLEOPEN';
      DBISAM_READERR: Result:='DBISAM_READERR';
      DBISAM_WRITEERR: Result:='DBISAM_WRITEERR';
      DBISAM_RECLOCKFAILED: Result:='DBISAM_RECLOCKFAILED';
      DBISAM_OSEMFILE: Result:='DBISAM_OSEMFILE';
      DBISAM_OSEBADF: Result:='DBISAM_OSEBADF';
      DBISAM_OSENOTSAM: Result:='DBISAM_OSENOTSAM';
      DBISAM_OSENODEV: Result:='DBISAM_OSENODEV';
      DBISAM_OLDVERSION: Result:='DBISAM_OLDVERSION';
      DBISAM_BADSIGNATURE: Result:='DBISAM_BADSIGNATURE';
      DBISAM_KEYVIOL: Result:='DBISAM_KEYVIOL';
      DBISAM_KEYORRECDELETED: Result:='DBISAM_KEYORRECDELETED';
      DBISAM_FLDLIMIT: Result:='DBISAM_FLDLIMIT';
      DBISAM_RECTOOBIG: Result:='DBISAM_RECTOOBIG';
      DBISAM_INDEXLIMIT: Result:='DBISAM_INDEXLIMIT';
      DBISAM_NEEDEXCLACCESS: Result:='DBISAM_NEEDEXCLACCESS';
      DBISAM_HEADERCORRUPT: Result:='DBISAM_HEADERCORRUPT';
      DBISAM_INDEXCORRUPT: Result:='DBISAM_INDEXCORRUPT';
      DBISAM_FILECORRUPT: Result:='DBISAM_FILECORRUPT';
      DBISAM_MEMOCORRUPT: Result:='DBISAM_MEMOCORRUPT';
      DBISAM_OUTOFRANGE: Result:='DBISAM_OUTOFRANGE';
      DBISAM_INVALIDKEY: Result:='DBISAM_INVALIDKEY';
      DBISAM_REQDERR: Result:='DBISAM_REQDERR';
      DBISAM_MINVALERR: Result:='DBISAM_MINVALERR';
      DBISAM_MAXVALERR: Result:='DBISAM_MAXVALERR';
      DBISAM_INVALIDFLDTYPE: Result:='DBISAM_INVALIDFLDTYPE';
      DBISAM_SEARCHCOLREQD: Result:='DBISAM_SEARCHCOLREQD';
      DBISAM_INVALIDBLOBLEN: Result:='DBISAM_INVALIDBLOBLEN';
      DBISAM_NOTABLOB: Result:='DBISAM_NOTABLOB';
      DBISAM_ENDOFBLOB: Result:='DBISAM_ENDOFBLOB';
      DBISAM_INVALIDBLOBOFFSET: Result:='DBISAM_INVALIDBLOBOFFSET';
      DBISAM_INVALIDBLOBHANDLE: Result:='DBISAM_INVALIDBLOBHANDLE';
      DBISAM_OPENBLOBLIMIT: Result:='DBISAM_OPENBLOBLIMIT';
      DBISAM_BLOBLIMIT: Result:='DBISAM_BLOBLIMIT';
      DBISAM_PRIMARYKEYREDEFINE: Result:='DBISAM_PRIMARYKEYREDEFINE';
      DBISAM_INDEXNAMEREQUIRED: Result:='DBISAM_INDEXNAMEREQUIRED';
      DBISAM_INDEXEXISTS: Result:='DBISAM_INDEXEXISTS';
      DBISAM_INVALIDINDEXNAME: Result:='DBISAM_INVALIDINDEXNAME';
      DBISAM_INVALIDIDXDESC: Result:='DBISAM_INVALIDIDXDESC';
      DBISAM_BOF: Result:='DBISAM_BOF';
      DBISAM_EOF: Result:='DBISAM_EOF';
      DBISAM_RECNOTFOUND: Result:='DBISAM_RECNOTFOUND';
      DBISAM_NOSUCHFILTER: Result:='DBISAM_NOSUCHFILTER';
      DBISAM_INVALIDFILTER: Result:='DBISAM_INVALIDFILTER';
      DBISAM_INTERNALLIMIT: Result:='DBISAM_INTERNALLIMIT';
      DBISAM_INVALIDVCHKSTRUCT: Result:='DBISAM_INVALIDVCHKSTRUCT';
      DBISAM_INVALIDFIELDNAME: Result:='DBISAM_INVALIDFIELDNAME';
      DBISAM_NOTSUFFTABLERIGHTS: Result:='DBISAM_NOTSUFFTABLERIGHTS';
      DBISAM_INVALIDPASSWORD: Result:='DBISAM_INVALIDPASSWORD';
      DBISAM_CANNOTLOADLDDRV: Result:='DBISAM_CANNOTLOADLDDRV';
      DBISAM_SQLPARSE: Result:='DBISAM_SQLPARSE';
      DBISAM_SQLEXEC: Result:='DBISAM_SQLEXEC';
      DBISAM_TABLEFULL: Result:='DBISAM_TABLEFULL';
      DBISAM_DATABASEFULL: Result:='DBISAM_DATABASEFULL';
      DBISAM_NOCURRREC: Result:='DBISAM_NOCURRREC';
      DBISAM_TABLEEXISTS: Result:='DBISAM_TABLEEXISTS';
      DBISAM_COMPRESS: Result:='DBISAM_COMPRESS';
      DBISAM_UNCOMPRESS: Result:='DBISAM_UNCOMPRESS';
      DBISAM_REMOTECOMMLOST: Result:='DBISAM_REMOTECOMMLOST';
      DBISAM_REMOTEENCRYPTREQ: Result:='DBISAM_REMOTEENCRYPTREQ';
      DBISAM_REMOTEUNKNOWN: Result:='DBISAM_REMOTEUNKNOWN';
      DBISAM_REMOTECONNECT: Result:='DBISAM_REMOTECONNECT';
      DBISAM_REMOTENOLOGIN: Result:='DBISAM_REMOTENOLOGIN';
      DBISAM_REMOTEMAXCONNECT: Result:='DBISAM_REMOTEMAXCONNECT';
      DBISAM_REMOTEADDRESSBLOCK: Result:='DBISAM_REMOTEADDRESSBLOCK';
      DBISAM_REMOTECALLBACK: Result:='DBISAM_REMOTECALLBACK';
      DBISAM_REMOTECALLBACKERR: Result:='DBISAM_REMOTECALLBACKERR';
      DBISAM_REMOTEVERSION: Result:='DBISAM_REMOTEVERSION';
      DBISAM_REMOTEINVLOGIN: Result:='DBISAM_REMOTEINVLOGIN';
      DBISAM_REMOTENOTAUTH: Result:='DBISAM_REMOTENOTAUTH';
      DBISAM_REMOTENOTADMIN: Result:='DBISAM_REMOTENOTADMIN';
      DBISAM_REMOTEINVUSER: Result:='DBISAM_REMOTEINVUSER';
      DBISAM_REMOTENOUSER: Result:='DBISAM_REMOTENOUSER';
      DBISAM_REMOTEDUPUSER: Result:='DBISAM_REMOTEDUPUSER';
      DBISAM_REMOTEINVDB: Result:='DBISAM_REMOTEINVDB';
      DBISAM_REMOTENODB: Result:='DBISAM_REMOTENODB';
      DBISAM_REMOTEDUPDB: Result:='DBISAM_REMOTEDUPDB';
      DBISAM_REMOTEINVDBUSER: Result:='DBISAM_REMOTEINVDBUSER';
      DBISAM_REMOTENODBUSER: Result:='DBISAM_REMOTENODBUSER';
      DBISAM_REMOTEDUPDBUSER: Result:='DBISAM_REMOTEDUPDBUSER';
      DBISAM_REMOTEINVREQUEST: Result:='DBISAM_REMOTEINVREQUEST';
      DBISAM_IMPORTERROR: Result:='DBISAM_IMPORTERROR';
      DBISAM_EXPORTERROR: Result:='DBISAM_EXPORTERROR';
      DBISAM_LOADSTREAMERROR: Result:='DBISAM_LOADSTREAMERROR';
      DBISAM_SAVESTREAMERROR: Result:='DBISAM_SAVESTREAMERROR';
      DBISAM_TRIGGERERROR: Result:='DBISAM_TRIGGERERROR';
      end;
end;

function TDataEngine.ValidVersion(VersionByte: Byte): Boolean;
begin
   Result:=False;
   if (VersionByte <= 6) then
      Result:=True;
end;

function TDataEngine.VersionToStr(VersionByte: Byte): string;
begin
   case VersionByte of
      0: Result:='1.00';
      1: Result:='1.02';
      2: Result:='1.04';
      3: Result:='1.08';
      4: Result:='2.00';
      5: Result:='3.00';
      6: Result:='4.00';
      else
         Result:='';
      end;
end;

procedure TDataEngine.SetCryptoInitCallback(ClientData: Integer;
                                            CryptoInitCallback: pCryptoInitCallback);
begin
   FCryptoInitClientData:=ClientData;
   FCryptoInitCallback:=pCryptoInitCallback(@CryptoInitCallback);
end;

procedure TDataEngine.SetEncryptBlockCallback(ClientData: Integer;
                                               EncryptBlockCallback: pEncryptBlockCallback);
begin
   FEncryptBlockClientData:=ClientData;
   FEncryptBlockCallback:=pEncryptBlockCallback(@EncryptBlockCallback);
end;

procedure TDataEngine.SetDecryptBlockCallback(ClientData: Integer;
                                               DecryptBlockCallback: pDecryptBlockCallback);
begin
   FDecryptBlockClientData:=ClientData;
   FDecryptBlockCallback:=pDecryptBlockCallback(@DecryptBlockCallback);
end;

procedure TDataEngine.SetCryptoResetCallback(ClientData: Integer;
                                             CryptoResetCallback: pCryptoResetCallback);
begin
   FCryptoResetClientData:=ClientData;
   FCryptoResetCallback:=pCryptoResetCallback(@CryptoResetCallback);
end;

procedure TDataEngine.CryptoInit(Key: Pointer; KeyLen: Integer;
                                 out OutData: Pointer; out OutDataBytes: Integer);
begin
   if Assigned(FCryptoInitCallback) then
      FCryptoInitCallback(FCryptoInitClientData,Key,KeyLen,OutData,OutDataBytes)
   else
      begin
      OutDataBytes:=SizeOf(TBlowfishData);
      OutData:=AllocMem(OutDataBytes);
      BFInit(pBlowfishData(OutData)^,Key,KeyLen,nil);
      end;
end;

procedure TDataEngine.EncryptBlock(Data: Pointer; BlockBuffer: Pointer);
begin
   if Assigned(FEncryptBlockCallback) then
      FEncryptBlockCallback(FEncryptBlockClientData,Data,BlockBuffer)
   else
      BFEncrypt(pBlowfishData(Data)^,BlockBuffer,BlockBuffer);
end;

procedure TDataEngine.DecryptBlock(Data: Pointer; BlockBuffer: Pointer);
begin
   if Assigned(FDecryptBlockCallback) then
      FDecryptBlockCallback(FDecryptBlockClientData,Data,BlockBuffer)
   else
      BFDecrypt(pBlowfishData(Data)^,BlockBuffer,BlockBuffer);
end;

procedure TDataEngine.CryptoReset(Data: Pointer);
begin
   if Assigned(FCryptoResetCallback) then
      FCryptoResetCallback(FCryptoResetClientData,Data)
   else
      BFReset(pBlowfishData(Data)^);
end;

procedure TDataEngine.Encrypt(Data: Pointer; Buffer: PChar; BufferSize: Integer);
var
   NumBlocks: Integer;
   I: Integer;
begin
   try
      NumBlocks:=(BufferSize div CRYPTO_BLOCK_SIZE);
      for I:=0 to (NumBlocks-1) do
         EncryptBlock(Data,(Buffer+(I*CRYPTO_BLOCK_SIZE)));
   finally
      CryptoReset(Data);
   end;
end;

procedure TDataEngine.Decrypt(Data: Pointer; Buffer: PChar; BufferSize: Integer);
var
   NumBlocks: Integer;
   I: Integer;
begin
   try
      NumBlocks:=(BufferSize div CRYPTO_BLOCK_SIZE);
      for I:=0 to (NumBlocks-1) do
         DecryptBlock(Data,(Buffer+(I*CRYPTO_BLOCK_SIZE)));
   finally
      CryptoReset(Data);
   end;
end;

procedure TDataEngine.SetCompressCallback(ClientData: Integer;
                                          CompressCallback: pCompressCallback);
begin
   FCompressClientData:=ClientData;
   FCompressCallback:=pCompressCallback(@CompressCallback);
end;

procedure TDataEngine.SetDecompressCallback(ClientData: Integer;
                                            DecompressCallback: pDecompressCallback);
begin
   FDecompressClientData:=ClientData;
   FDecompressCallback:=pDecompressCallback(@DecompressCallback);
end;

procedure TDataEngine.Compress(const InBuffer: Pointer; InBytes: Integer; Level: Byte;
                               out OutBuffer: Pointer; out OutBytes: Integer);
begin
   try
      if Assigned(FCompressCallback) then
         FCompressCallback(FCompressClientData,InBuffer,InBytes,Level,
                           OutBuffer,OutBytes)
      else
         CompressBuf(InBuffer,InBytes,Level,OutBuffer,OutBytes);
   except
      RaiseError(DBISAM_COMPRESS);
   end;
end;

procedure TDataEngine.Decompress(const InBuffer: Pointer; InBytes: Integer;
                                 out OutBuffer: Pointer; out OutBytes: Integer);
begin
   try
      if Assigned(FDecompressCallback) then
         FDecompressCallback(FDecompressClientData,InBuffer,InBytes,
                             OutBuffer,OutBytes)
      else
         DecompressBuf(InBuffer,InBytes,OutBuffer,OutBytes);
   except
      RaiseError(DBISAM_UNCOMPRESS);
   end;
end;

procedure TDataEngine.BuildWordList(const TableName: string; const FieldName: string;
                                    WordBuffer: PChar; WordBufferSize: Integer;
                                    WordList: TLocaleStringList; const SpaceChars: TCharSet;
                                    const IncludeChars: TCharSet; Occurrences: Boolean;
                                    PartialWords: Boolean);
var
   I: Integer;
   CurWord: array [0..TEXT_WORD_SIZE-1] of Char;
   CurWordSize: Byte;
   WordStart: Integer;
   CurWordPos: Integer;
   Include: Boolean;
begin
   WordList.Clear;
   CurWordSize:=0;
   FillChar(CurWord,SizeOf(CurWord),#0);
   WordStart:=-1;
   CurWordPos:=-1;
   if Occurrences then
      begin
      for I:=0 to (WordBufferSize-1) do
         begin
         if (WordBuffer[I] in SpaceChars) and
            (not ((WordBuffer[I]=PARSE_ASTERISK) and PartialWords)) then
            begin
            if (CurWord[0] <> #0) then
               begin
               TextIndexTokenFilter(TableName,FieldName,StrPas(@CurWord),Include);
               if Include then
                  begin
                  if WordList.Find(StrPas(@CurWord),CurWordPos) then
                     WordList.Objects[CurWordPos]:=
                           TObject(MinimumInteger(High(Word),(Integer(WordList.Objects[CurWordPos])+1)))
                  else
                     WordList.AddObject(StrPas(@CurWord),TObject(1));
                  end;
               CurWordSize:=0;
               FillChar(CurWord,SizeOf(CurWord),#0);
               end;
            end
         else if (WordBuffer[I] in IncludeChars) or
                 ((WordBuffer[I]=PARSE_ASTERISK) and PartialWords) then
            begin
            if (CurWordSize <= (TEXT_WORD_SIZE-1)) then
               begin
               CurWord[CurWordSize]:=WordBuffer[I];
               Inc(CurWordSize);
               end;
            end;
         end;
      { Be sure to catch the last word }
      if (CurWord[0] <> #0) then
         begin
         TextIndexTokenFilter(TableName,FieldName,StrPas(@CurWord),Include);
         if Include then
            begin
            if WordList.Find(StrPas(@CurWord),CurWordPos) then
               WordList.Objects[CurWordPos]:=
                     TObject(MinimumInteger(High(Word),(Integer(WordList.Objects[CurWordPos])+1)))
            else
               WordList.AddObject(StrPas(@CurWord),TObject(1));
            end;
         end;
      end
   else
      begin
      for I:=0 to (WordBufferSize-1) do
         begin
         if (WordBuffer[I] in SpaceChars) and
            (not ((WordBuffer[I]=PARSE_ASTERISK) and PartialWords)) then
            begin
            if (CurWord[0] <> #0) then
               begin
               TextIndexTokenFilter(TableName,FieldName,StrPas(@CurWord),Include);
               if Include then
                  WordList.AddObject(StrPas(@CurWord),TObject(WordStart));
               CurWordSize:=0;
               FillChar(CurWord,SizeOf(CurWord),#0);
               WordStart:=-1;
               end;
            end
         else if (WordBuffer[I] in IncludeChars) or
                 ((WordBuffer[I]=PARSE_ASTERISK) and PartialWords) then
            begin
            if (WordStart = -1) then
               WordStart:=I;
            if (CurWordSize <= (TEXT_WORD_SIZE-1)) then
               begin
               CurWord[CurWordSize]:=WordBuffer[I];
               Inc(CurWordSize);
               end;
            end;
         end;
      { Be sure to catch the last word }
      if (CurWord[0] <> #0) then
         begin
         TextIndexTokenFilter(TableName,FieldName,StrPas(@CurWord),Include);
         if Include then
            WordList.AddObject(StrPas(@CurWord),TObject(WordStart));
         end;
      end;
end;

procedure TDataEngine.GetDefaultTextIndexParams(StopWordsList: TStrings;
                                                var TextSpaceChars: TCharSet;
                                                var TextIncludeChars: TCharSet);
var
   I: Integer;
begin
   with StopWordsList do
      begin
      Capacity:=TOTAL_STOP_WORDS;
      for I:=1 to TOTAL_STOP_WORDS do
         Add(StopWordsArray[I]);
      end;
   TextSpaceChars:=GetDefaultTextIndexSpaceChars;
   TextIncludeChars:=GetDefaultTextIndexIncludeChars;
end;

function TDataEngine.GetDefaultTextIndexSpaceChars: TCharSet;
var
   I: Byte;
begin
   Result:=[];
   for I:=1 to 32 do
      Include(Result,AnsiChar(I));
   for I:=33 to High(Byte) do
      begin
      if IsSpace(AnsiChar(I)) then
         Include(Result,AnsiChar(I));
      end;
end;

function TDataEngine.GetDefaultTextIndexIncludeChars: TCharSet;
var
   I: Byte;
begin
   Result:=[];
   for I:=33 to High(Byte) do
      begin
      if IsAlphaNumeric(AnsiChar(I)) then
         Include(Result,AnsiChar(I));
      end;
end;

procedure TDataEngine.SetTextIndexFilterCallback(ClientData: Integer;
                                                 TextIndexFilterCallback: pTextIndexFilterCallback);
begin
   FTextIndexFilterClientData:=ClientData;
   FTextIndexFilterCallback:=pTextIndexFilterCallback(@TextIndexFilterCallback);
end;

procedure TDataEngine.TextIndexFilter(const TableName: string; const FieldName: string;
                                      const InBuffer: Pointer; InBytes: Integer;
                                      out OutBuffer: Pointer; out OutBytes: Integer);
var
   TempString: AnsiString;
begin
   try
      if Assigned(FTextIndexFilterCallback) then
         begin
         SetLength(TempString,InBytes);
         Move(InBuffer^,PChar(TempString)^,InBytes);
         FTextIndexFilterCallback(FTextIndexFilterClientData,
                                  TableName,FieldName,TempString);
         OutBytes:=Length(TempString);
         OutBuffer:=AllocMem(OutBytes);
         Move(PChar(TempString)^,OutBuffer^,OutBytes);
         end
      else
         begin
         OutBytes:=InBytes;
         OutBuffer:=InBuffer;
         end;
   except
      OutBytes:=InBytes;
      OutBuffer:=InBuffer;
   end;
end;

procedure TDataEngine.SetTextIndexTokenFilterCallback(ClientData: Integer;
                                                      TextIndexTokenFilterCallback: pTextIndexTokenFilterCallback);
begin
   FTextIndexTokenFilterClientData:=ClientData;
   FTextIndexTokenFilterCallback:=pTextIndexTokenFilterCallback(@TextIndexTokenFilterCallback);
end;

procedure TDataEngine.TextIndexTokenFilter(const TableName: string;
                                           const FieldName: string;
                                           const TextIndexToken: string;
                                           var Include: Boolean);
begin
   try
      if Assigned(FTextIndexTokenFilterCallback) then
         FTextIndexTokenFilterCallback(FTextIndexTokenFilterClientData,
                                       TableName,FieldName,
                                       TextIndexToken,Include)
      else
         Include:=True;
   except
      Include:=True;
   end;
end;

procedure TDataEngine.SetCustomFunctionCallback(ClientData: Integer;
                                                FunctionCallback: pFunctionCallback);
begin
   FFunctionClientData:=ClientData;
   FFunctionCallback:=pFunctionCallback(@FunctionCallback);
end;

procedure TDataEngine.SetGetCustomFunctionsCallback(ClientData: Integer;
                                                    GetFunctionsCallback: pGetFunctionsCallback);
begin
   FGetFunctionsClientData:=ClientData;
   FGetFunctionsCallback:=pGetFunctionsCallback(@GetFunctionsCallback);
end;

procedure TDataEngine.CustomFunction(const FunctionName: string;
                                     InParamCount: Word;
                                     const InParamDefinitions: array of pFieldDefinition;
                                     InRecordBuffer: PChar;
                                     ResultDataType: Byte;
                                     out ResultSize: Integer;
                                     out ResultBuffer: PChar);
begin
   ResultBuffer:=nil;
   if Assigned(FFunctionCallback) then
      FFunctionCallback(FFunctionClientData,FunctionName,
                        InParamCount,InParamDefinitions,
                        InRecordBuffer,ResultDataType,
                        ResultSize,ResultBuffer);
end;

procedure TDataEngine.FreeFunctions;
var
   I: Integer;
begin
   for I:=1 to FFunctionCount do
      DeAllocMem(FFunctionDefinitions[I]);
end;

procedure TDataEngine.GetFunctions;
begin
   if Assigned(FGetFunctionsCallback) then
      FGetFunctionsCallback(FGetFunctionsClientData,
                            FFunctionCount,FFunctionDefinitions);
end;

function TDataEngine.GetFunctionDefinitionByPos(FunctionIndex: Word): pFunctionDefinition;
begin
   Result:=nil;
   if (FunctionIndex > 0) and (FunctionIndex <= FFunctionCount) then
      Result:=FFunctionDefinitions[FunctionIndex];
end;

function TDataEngine.GetFunctionDefinitionByName(const NameOfFunction: string): pFunctionDefinition;
var
   I: Word;
begin
   Result:=nil;
   for I:=1 to FFunctionCount do
      begin
      if (AnsiCompareText(FFunctionDefinitions[I]^.FunctionName,NameOfFunction)=0) then
         begin
         Result:=FFunctionDefinitions[I];
         Exit;
         end;
      end;
end;

procedure TDataEngine.SetTriggerCallback(ClientData: Integer;
                                         TriggerCallback: pTriggerCallback);
begin
   FTriggerClientData:=ClientData;
   FTriggerCallback:=pTriggerCallback(@TriggerCallback);
end;

procedure TDataEngine.Trigger(TriggerType: Byte;
                              DataSession: TDataSession;
                              DataDirectory: TDataDirectory;
                              DataCursor: TDataCursor;
                              RecordNumber: Integer;
                              RecordBuffer: PChar;
                              OldRecordBuffer: PChar);
var
   WasInsideEngine: Boolean;
begin
   if Assigned(FTriggerCallback) then
      begin
      WasInsideEngine:=DataSession.InsideEngine;
      DataSession.InsideEngine:=True;
      try
         FTriggerCallback(FTriggerClientData,TriggerType,
                          DataSession,DataDirectory,DataCursor,
                          RecordNumber,
                          RecordBuffer,
                          OldRecordBuffer);
      finally
         if (not WasInsideEngine) then
            DataSession.InsideEngine:=False;
      end;
      end;
end;

procedure TDataEngine.SetErrorCallback(ClientData: Integer;
                                       ErrorCallback: pErrorCallback);
begin
   FErrorClientData:=ClientData;
   FErrorCallback:=pErrorCallback(@ErrorCallback);
end;

procedure TDataEngine.Error(ErrorType: Byte;
                            DataSession: TDataSession;
                            DataDirectory: TDataDirectory;
                            DataCursor: TDataCursor;
                            RecordNumber: Integer;
                            RecordBuffer: PChar;
                            E: Exception; var Response: Byte);
var
   WasInsideEngine: Boolean;
begin
   if Assigned(FErrorCallback) then
      begin
      WasInsideEngine:=DataSession.InsideEngine;
      DataSession.InsideEngine:=True;
      try
         FErrorCallback(FErrorClientData,ErrorType,
                        DataSession,DataDirectory,DataCursor,
                        RecordNumber,
                        RecordBuffer,
                        E,Response);
      finally
         if (not WasInsideEngine) then
            DataSession.InsideEngine:=False;
      end;
      end;
end;

procedure TDataEngine.LockDataSessionList;
begin
   OSEnterCriticalSection(FDataSessionSection);
end;

procedure TDataEngine.UnlockDataSessionList;
begin
   OSLeaveCriticalSection(FDataSessionSection);
end;

procedure TDataEngine.FreeDataSessions;
var
   I: Integer;
begin
   LockDataSessionList;
   try
      for I:=FDataSessionList.Count-1 downto 0 do
         begin
         TDataSession(FDataSessionList[I]).Free;
         FDataSessionList.Delete(I);
         end;
   finally
      UnlockDataSessionList;
   end;
end;

procedure TDataEngine.StartDataSession(var Value: TDataSession);
begin
   LockDataSessionList;
   try
      Value:=TDataSession.Create(Self);
      FDataSessionList.Add(Value);
   finally
      UnlockDataSessionList;
   end;
end;

procedure TDataEngine.CloseDataSession(Value: TDataSession);
var
   TempPos: Integer;
begin
   LockDataSessionList;
   try
      TempPos:=FDataSessionList.IndexOf(Value);
      if (TempPos <> -1) then
         begin
         Value.Free;
         FDataSessionList.Delete(TempPos);
         end;
   finally
      UnlockDataSessionList;
   end;
end;

procedure TDataEngine.GetFileNames(IsMemory: Boolean; const DirMask: string;
                                   IncludeExtensions: Boolean;
                                   List: TStrings);
var
   I: Integer;
begin
   List.Clear;
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         for I:=0 to FMemoryFileList.Count-1 do
            begin
            with TMemoryFile(FMemoryFileList[I]) do
               begin
               if MatchString(FileName,DirMask,False,'',False) then
                  begin
                  if IncludeExtensions then
                     List.Add(ExtractFileName(FileName))
                  else
                     List.Add(ExtractFileRoot(ExtractFileName(FileName),''));
                  end;
               end;
            end;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      OSListFiles(List,DirMask,IncludeExtensions);
end;

function TDataEngine.FindFile(const Value: string; IsMemory: Boolean;
                              var IndexPos: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   IndexPos:=0;
   if IsMemory then
      begin
      if (FMemoryFileList.Count=0) then
         Exit;
      CompareResult:=CMP_EQUAL;
      Low:=0;
      High:=(FMemoryFileList.Count-1);
      while (Low <= High) do
         begin
         IndexPos:=((Low+High) div 2);
         CompareResult:=CompareFileNames(FMemoryFileList[IndexPos],Value);
         case CompareResult of
            CMP_GREATER: High:=(IndexPos-1);
            CMP_LESS: Low:=(IndexPos+1);
            CMP_EQUAL:
               begin
               Result:=True;
               Break;
               end;
            end;
         end;
      { Adjust the buffer index for proper insertion }
      if (CompareResult=CMP_LESS) then
         begin
         if (IndexPos < FMemoryFileList.Count) then
            Inc(IndexPos);
         end;
      end
   else
      begin
      if (FPhysicalFileList.Count=0) then
         Exit;
      CompareResult:=CMP_EQUAL;
      Low:=0;
      High:=(FPhysicalFileList.Count-1);
      while (Low <= High) do
         begin
         IndexPos:=((Low+High) div 2);
         CompareResult:=CompareFileNames(FPhysicalFileList[IndexPos],Value);
         case CompareResult of
            CMP_GREATER: High:=(IndexPos-1);
            CMP_LESS: Low:=(IndexPos+1);
            CMP_EQUAL:
               begin
               Result:=True;
               Break;
               end;
            end;
         end;
      { Adjust the buffer index for proper insertion }
      if (CompareResult=CMP_LESS) then
         begin
         if (IndexPos < FPhysicalFileList.Count) then
            Inc(IndexPos);
         end;
      end;
end;

function TDataEngine.FileExists(const Value: string; IsMemory: Boolean;
                                IsHidden: Boolean): Boolean;
var
   TempPos: Integer;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         Result:=FindFile(Value,IsMemory,TempPos);
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         Result:=FindFile(Value,IsMemory,TempPos);
         if (not Result) then
            Result:=OSFileExists(Value,IsHidden);
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.GetTempFileName(const TempDirectory: string; const Extension: string;
                                     IsMemory: Boolean; IsHidden: Boolean): string;
var
   I: Word;
   ThreadID: string;
begin
   Result:='';
   I:=0;
   ThreadID:=Substr(IntToStr(Abs(OSGetThreadID)),1,5);
   while FileExists(AddBS(TempDirectory)+ThreadID+IntToStr(I)+Extension,IsMemory,IsHidden) do
      Inc(I);
   Result:=AddBS(TempDirectory)+ThreadID+IntToStr(I)+Extension;
end;

function TDataEngine.CreateFile(Value: string; IsMemory: Boolean;
                                var NewFile: TBaseFile;
                                IsTemporary: Boolean; IsHidden: Boolean): Integer;
var
   TempPos: Integer;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TMemoryFile(FMemoryFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount > 0) then
                  Result:=-DBISAM_OSEACCES
               else
                  begin
                  Exclusive:=True;
                  Temporary:=IsTemporary;
                  Hidden:=IsHidden;
                  Result:=CreateNew;
                  end;
               end;
            end
         else
            begin
            NewFile:=TMemoryFile.Create(Self);
            try
               with NewFile do
                  begin
                  FileName:=Value;
                  Exclusive:=True;
                  Temporary:=IsTemporary;
                  Hidden:=IsHidden;
                  Result:=CreateNew;
                  end;
               if (Result >= 0) then
                  FMemoryFileList.Insert(TempPos,NewFile)
               else
                  NewFile.Free;
            except
               NewFile.Free;
               raise;
            end;
            end;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TPhysicalFile(FPhysicalFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount > 0) then
                  Result:=-DBISAM_OSEACCES
               else
                  begin
                  Exclusive:=True;
                  Temporary:=IsTemporary;
                  Hidden:=IsHidden;
                  Result:=CreateNew;
                  end;
               end;
            end
         else
            begin
            NewFile:=TPhysicalFile.Create(Self);
            try
               with NewFile do
                  begin
                  FileName:=Value;
                  Exclusive:=True;
                  Temporary:=IsTemporary;
                  Hidden:=IsHidden;
                  Result:=CreateNew;
                  end;
               if (Result >= 0) then
                  FPhysicalFileList.Insert(TempPos,NewFile)
               else
                  NewFile.Free;
            except
               NewFile.Free;
               raise;
            end;
            end;
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.OpenFile(Value: string; IsMemory: Boolean;
                              var NewFile: TBaseFile; var IsMarkedReadOnly: Boolean;
                              var IsReadOnly: Boolean; IsExclusive: Boolean;
                              IsTemporary: Boolean; IsHidden: Boolean): Integer;
var
   TempPos: Integer;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TMemoryFile(FMemoryFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount > 0) then
                  begin
                  if (not Exclusive) and (not IsExclusive) then
                     begin
                     ReadOnly:=IsReadOnly;
                     Result:=Open;
                     IsMarkedReadOnly:=MarkedReadOnly;
                     IsReadOnly:=ReadOnly;
                     end
                  else
                     Result:=-DBISAM_OSEACCES
                  end
               else
                  begin
                  with NewFile do
                     begin
                     Exclusive:=IsExclusive;
                     Temporary:=IsTemporary;
                     Hidden:=IsHidden;
                     ReadOnly:=IsReadOnly;
                     Result:=Open;
                     IsMarkedReadOnly:=MarkedReadOnly;
                     IsReadOnly:=ReadOnly;
                     end;
                  end;
               end
            end;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TPhysicalFile(FPhysicalFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount > 0) then
                  begin
                  if (not Exclusive) and (not IsExclusive) then
                     begin
                     ReadOnly:=IsReadOnly;
                     Result:=Open;
                     IsMarkedReadOnly:=MarkedReadOnly;
                     IsReadOnly:=ReadOnly;
                     end
                  else
                     Result:=-DBISAM_OSEACCES
                  end
               else
                  begin
                  with NewFile do
                     begin
                     Exclusive:=IsExclusive;
                     Temporary:=IsTemporary;
                     Hidden:=IsHidden;
                     ReadOnly:=IsReadOnly;
                     Result:=Open;
                     IsMarkedReadOnly:=MarkedReadOnly;
                     IsReadOnly:=ReadOnly;
                     end;
                  end;
               end
            end
         else
            begin
            NewFile:=TPhysicalFile.Create(Self);
            try
               with NewFile do
                  begin
                  FileName:=Value;
                  Exclusive:=IsExclusive;
                  Temporary:=IsTemporary;
                  Hidden:=IsHidden;
                  ReadOnly:=IsReadOnly;
                  Result:=Open;
                  IsMarkedReadOnly:=MarkedReadOnly;
                  IsReadOnly:=ReadOnly;
                  end;
               if (Result >= 0) then
                  FPhysicalFileList.Insert(TempPos,NewFile)
               else
                  NewFile.Free;
            except
               NewFile.Free;
               raise;
            end;
            end;
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.CloseFile(ExistingFile: TBaseFile;
                               IsMemory: Boolean;
                               FileHandle: Integer): Integer;
var
   TempPos: Integer;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         Result:=-DBISAM_OSENOENT;
         TempPos:=FMemoryFileList.IndexOf(ExistingFile);
         if (TempPos <> -1) then
            begin
            with ExistingFile do
               begin
               if (UseCount > 0) then
                  begin
                  Close(FileHandle);
                  if (UseCount=0) then
                     begin
                     if Temporary then
                        begin
                        Delete;
                        Free;
                        FMemoryFileList.Delete(TempPos);
                        end;
                     end;
                  Result:=DBISAM_NONE;
                  end
               else
                  Result:=-DBISAM_OSENOENT;
               end;
            end;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         Result:=-DBISAM_OSENOENT;
         TempPos:=FPhysicalFileList.IndexOf(ExistingFile);
         if (TempPos <> -1) then
            begin
            with ExistingFile do
               begin
               if (UseCount > 0) then
                  begin
                  Close(FileHandle);
                  if (UseCount=0) then
                     begin
                     if Temporary then
                        begin
                        Delete;
                        Free;
                        FPhysicalFileList.Delete(TempPos);
                        end
                     else
                        begin
                        if (not IsMemory) then
                           begin
                           Free;
                           FPhysicalFileList.Delete(TempPos);
                           end;
                        end;
                     end;
                  Result:=DBISAM_NONE;
                  end
               else
                  Result:=-DBISAM_OSENOENT;
               end;
            end;
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.RenameFile(const Value: string; IsMemory: Boolean;
                                const NewName: string): Integer;
var
   TempPos: Integer;
   NewFile: TBaseFile;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         if (not FindFile(NewName,IsMemory,TempPos)) then
            begin
            Result:=-DBISAM_OSENOENT;
            if FindFile(Value,IsMemory,TempPos) then
               begin
               NewFile:=TMemoryFile(FMemoryFileList[TempPos]);
               with NewFile do
                  begin
                  if (UseCount=0) then
                     begin
                     Result:=Rename(NewName);
                     if (Result=DBISAM_NONE) then
                        begin
                        FMemoryFileList.Delete(TempPos);
                        FindFile(NewName,IsMemory,TempPos);
                        FMemoryFileList.Insert(TempPos,NewFile);
                        end;
                     end
                  else
                     Result:=-DBISAM_OSEACCES;
                  end;
               end;
            end
         else
            Result:=-DBISAM_OSEACCES;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         if (not FindFile(NewName,IsMemory,TempPos)) then
            begin
            Result:=-DBISAM_OSENOENT;
            if FindFile(Value,IsMemory,TempPos) then
               begin
               NewFile:=TPhysicalFile(FPhysicalFileList[TempPos]);
               with NewFile do
                  begin
                  if (UseCount=0) then
                     begin
                     Result:=Rename(NewName);
                     if (Result=DBISAM_NONE) then
                        begin
                        FPhysicalFileList.Delete(TempPos);
                        FindFile(NewName,IsMemory,TempPos);
                        FPhysicalFileList.Insert(TempPos,NewFile);
                        end;
                     end
                  else
                     Result:=-DBISAM_OSEACCES;
                  end;
               end
            else
               begin
               NewFile:=TPhysicalFile.Create(Self);
               try
                  with NewFile do
                     begin
                     FileName:=Value;
                     Result:=Rename(NewName);
                     end;
               finally
                  NewFile.Free;
               end;
               end;
            end
         else
            Result:=-DBISAM_OSEACCES;
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.DeleteFile(const Value: string; IsMemory: Boolean): Integer;
var
   TempPos: Integer;
   NewFile: TBaseFile;
begin
   if IsMemory then
      begin
      LockMemoryFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TMemoryFile(FMemoryFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount=0) then
                  begin
                  Result:=Delete;
                  Free;
                  FMemoryFileList.Delete(TempPos);
                  end
               else
                  Result:=-DBISAM_OSEACCES;
               end;
            end;
      finally
         UnlockMemoryFileList;
      end;
      end
   else
      begin
      LockPhysicalFileList;
      try
         Result:=-DBISAM_OSENOENT;
         if FindFile(Value,IsMemory,TempPos) then
            begin
            NewFile:=TPhysicalFile(FPhysicalFileList[TempPos]);
            with NewFile do
               begin
               if (UseCount=0) then
                  begin
                  Result:=Delete;
                  Free;
                  FPhysicalFileList.Delete(TempPos);
                  end
               else
                  Result:=-DBISAM_OSEACCES;
               end;
            end
         else
            begin
            NewFile:=TPhysicalFile.Create(Self);
            try
               with NewFile do
                  begin
                  FileName:=Value;
                  Result:=Delete;
                  end;
            finally
               NewFile.Free;
            end;
            end;
      finally
         UnlockPhysicalFileList;
      end;
      end;
end;

function TDataEngine.CopyToFile(FromFile: TBaseFile;
                                FromHandle: Integer; ToIsMemory: Boolean;
                                const ToName: string;
                                Compression: Byte;
                                ClientData: Integer;
                                CopyFileCallback: pCopyFileCallback;
                                ProgressPercent: Word): Integer;
var
   CopyBuffer: Pointer;
   CompressedBuffer: Pointer;
   CompressedBytes: Integer;
   TotalBytes: Int64;
   BytesCopied: Integer;
   TotalBytesCopied: Int64;
   ToFile: TBaseFile;
   ToHandle: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempSignature: TMD5Digest;
begin
   FromFile.LockFileSection;
   try
      Result:=DBISAM_NONE;
      CopyBuffer:=AllocMem(COPY_BUFFER_SIZE);
      try
         ToHandle:=CreateFile(ToName,ToIsMemory,ToFile,False,False);
         if (ToHandle < 0) then
            begin
            Result:=ToHandle;
            Exit;
            end;
         ToFile.LockFileSection;
         try
            if Assigned(CopyFileCallback) then
               CopyFileCallback(ClientData,FromFile.FileName,0);
            if (Compression > NO_COMPRESSION) then
               begin
               TempSignature:=MD5String(COMPRESSION_SIGNATURE);
               ToFile.Write(ToHandle,TempSignature,SizeOf(TMD5Digest));
               ToFile.Write(ToHandle,Compression,SizeOf(Byte));
               end;
            TempLastPercentDone:=0;
            TotalBytes:=FromFile.Seek(FromHandle,0,FROM_EOF);
            TotalBytesCopied:=0;
            FromFile.Seek(FromHandle,0,FROM_BOF);
            repeat
               BytesCopied:=FromFile.Read(FromHandle,CopyBuffer^,COPY_BUFFER_SIZE);
               if (BytesCopied > 0) then
                  begin
                  if (Compression > NO_COMPRESSION) then
                     begin
                     CompressedBuffer:=nil;
                     CompressedBytes:=0;
                     Compress(CopyBuffer,BytesCopied,Compression,
                              CompressedBuffer,CompressedBytes);
                     try
                        ToFile.Write(ToHandle,CompressedBytes,SizeOf(Integer));
                        ToFile.Write(ToHandle,CompressedBuffer^,CompressedBytes);
                     finally
                        DeAllocMem(CompressedBuffer);
                     end;
                     end
                  else
                     ToFile.Write(ToHandle,CopyBuffer^,BytesCopied);
                  if Assigned(CopyFileCallback) then
                     begin
                     Inc(TotalBytesCopied,BytesCopied);
                     TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                     if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                        begin
                        CopyFileCallback(ClientData,FromFile.FileName,TempPercentDone);
                        TempLastPercentDone:=TempPercentDone;
                        end;
                     end;
                  end;
            until (BytesCopied < COPY_BUFFER_SIZE);
            if Assigned(CopyFileCallback) then
               CopyFileCallback(ClientData,FromFile.FileName,100);
         finally
            ToFile.UnlockFileSection;
            ToFile.Close(ToHandle);
         end;
      finally
         DeAllocMem(CopyBuffer);
      end;
   finally
      FromFile.UnlockFileSection;
   end;
end;

function TDataEngine.CopyFromFile(ToFile: TBaseFile; ToHandle: Integer;
                                  FromIsMemory: Boolean; const FromName: string;
                                  ClientData: Integer;
                                  CopyFileCallback: pCopyFileCallback;
                                  ProgressPercent: Word): Integer;
var
   CopyBuffer: Pointer;
   DecompressedBuffer: Pointer;
   DecompressedBytes: Integer;
   TotalBytes: Int64;
   BytesCopied: Integer;
   TotalBytesCopied: Int64;
   FromFile: TBaseFile;
   FromHandle: Integer;
   TempMarkedReadOnly: Boolean;
   TempReadOnly: Boolean;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempSignature: TMD5Digest;
   TempCompression: Byte;
begin
   ToFile.LockFileSection;
   try
      Result:=DBISAM_NONE;
      { Be sure to over-alloocate buffer for possible increase in size
        due to de-compression }
      CopyBuffer:=AllocMem(COPY_BUFFER_SIZE*2);
      try
         FromHandle:=OpenFile(FromName,FromIsMemory,FromFile,TempMarkedReadOnly,
                              TempReadOnly,True,False,False);
         if (FromHandle < 0) then
            begin
            Result:=FromHandle;
            Exit;
            end;
         FromFile.LockFileSection;
         try
            if Assigned(CopyFileCallback) then
               CopyFileCallback(ClientData,ToFile.FileName,0);
            TempLastPercentDone:=0;
            TotalBytes:=FromFile.Seek(FromHandle,0,FROM_EOF);
            TotalBytesCopied:=0;
            { First check for a compression signature }
            TempCompression:=NO_COMPRESSION;
            FromFile.Seek(FromHandle,0,FROM_BOF);
            FromFile.Read(FromHandle,TempSignature,SizeOf(TMD5Digest));
            if MD5DigestCompare(TempSignature,MD5String(COMPRESSION_SIGNATURE)) then
               begin
               FromFile.Read(FromHandle,TempCompression,SizeOf(Byte));
               Dec(TotalBytes,(SizeOf(TMD5Digest)+SizeOf(Byte)));
               end
            else
               FromFile.Seek(FromHandle,0,FROM_BOF);
            ToFile.Seek(ToHandle,0,FROM_BOF);
            if (TempCompression > NO_COMPRESSION) then
               begin
               repeat
                  BytesCopied:=0;
                  FromFile.Read(FromHandle,BytesCopied,SizeOf(Integer));
                  if (BytesCopied > 0) then
                     begin
                     FromFile.Read(FromHandle,CopyBuffer^,BytesCopied);
                     DecompressedBuffer:=nil;
                     DecompressedBytes:=0;
                     Decompress(Pointer(CopyBuffer),BytesCopied,
                                Pointer(DecompressedBuffer),DecompressedBytes);
                     try
                        ToFile.Write(ToHandle,DecompressedBuffer^,DecompressedBytes);
                     finally
                        DeAllocMem(DecompressedBuffer);
                     end;
                     if Assigned(CopyFileCallback) then
                        begin
                        Inc(TotalBytesCopied,(BytesCopied+SizeOf(Integer)));
                        TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           CopyFileCallback(ClientData,ToFile.FileName,TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     end;
               until (BytesCopied=0);
               end
            else
               begin
               repeat
                  BytesCopied:=FromFile.Read(FromHandle,CopyBuffer^,COPY_BUFFER_SIZE);
                  if (BytesCopied > 0) then
                     begin
                     ToFile.Write(ToHandle,CopyBuffer^,BytesCopied);
                     if Assigned(CopyFileCallback) then
                        begin
                        Inc(TotalBytesCopied,BytesCopied);
                        TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           CopyFileCallback(ClientData,ToFile.FileName,TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     end;
               until (BytesCopied < COPY_BUFFER_SIZE);
               end;
            if Assigned(CopyFileCallback) then
               CopyFileCallback(ClientData,ToFile.FileName,100);
         finally
            FromFile.UnlockFileSection;
            FromFile.Close(FromHandle);
         end;
      finally
         DeAllocMem(CopyBuffer);
      end;
   finally
      ToFile.UnlockFileSection;
   end;
end;

function TDataEngine.CopyToHandle(FromFile: TBaseFile; FromHandle: Integer;
                                  ToFile: TBaseFile; ToHandle: Integer;
                                  Compression: Byte;
                                  ClientData: Integer;
                                  CopyFileCallback: pCopyFileCallback;
                                  ProgressPercent: Word): Integer;
var
   CopyBuffer: Pointer;
   CompressedBuffer: Pointer;
   CompressedBytes: Integer;
   TotalBytes: Int64;
   BytesCopied: Integer;
   TotalBytesCopied: Int64;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempSignature: TMD5Digest;
begin
   FromFile.LockFileSection;
   ToFile.LockFileSection;
   try
      Result:=DBISAM_NONE;
      CopyBuffer:=AllocMem(COPY_BUFFER_SIZE);
      try
         if Assigned(CopyFileCallback) then
            CopyFileCallback(ClientData,FromFile.FileName,0);
         if (Compression > NO_COMPRESSION) then
            begin
            TempSignature:=MD5String(COMPRESSION_SIGNATURE);
            ToFile.Write(ToHandle,TempSignature,SizeOf(TMD5Digest));
            ToFile.Write(ToHandle,Compression,SizeOf(Byte));
            end;
         TempLastPercentDone:=0;
         TotalBytes:=FromFile.Seek(FromHandle,0,FROM_EOF);
         TotalBytesCopied:=0;
         FromFile.Seek(FromHandle,0,FROM_BOF);
         repeat
            BytesCopied:=FromFile.Read(FromHandle,CopyBuffer^,COPY_BUFFER_SIZE);
            if (BytesCopied > 0) then
               begin
               if (Compression > NO_COMPRESSION) then
                  begin
                  CompressedBuffer:=nil;
                  CompressedBytes:=0;
                  Compress(CopyBuffer,BytesCopied,Compression,
                           CompressedBuffer,CompressedBytes);
                  try
                     ToFile.Write(ToHandle,CompressedBytes,SizeOf(Integer));
                     ToFile.Write(ToHandle,CompressedBuffer^,CompressedBytes);
                  finally
                     DeAllocMem(CompressedBuffer);
                  end;
                  end
               else
                  ToFile.Write(ToHandle,CopyBuffer^,BytesCopied);
               if Assigned(CopyFileCallback) then
                  begin
                  Inc(TotalBytesCopied,BytesCopied);
                  TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                  if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                     begin
                     CopyFileCallback(ClientData,FromFile.FileName,TempPercentDone);
                     TempLastPercentDone:=TempPercentDone;
                     end;
                  end;
               end;
         until (BytesCopied < COPY_BUFFER_SIZE);
         if Assigned(CopyFileCallback) then
            CopyFileCallback(ClientData,FromFile.FileName,100);
      finally
         DeAllocMem(CopyBuffer);
      end;
   finally
      ToFile.UnlockFileSection;
      FromFile.UnlockFileSection;
   end;
end;

function TDataEngine.CopyFromHandle(ToFile: TBaseFile; ToHandle: Integer;
                                    FromFile: TBaseFile; FromHandle: Integer;
                                    TotalBytes: Int64;
                                    ClientData: Integer;
                                    CopyFileCallback: pCopyFileCallback;
                                    ProgressPercent: Word): Integer;
var
   CopyBuffer: Pointer;
   DecompressedBuffer: Pointer;
   DecompressedBytes: Integer;
   BytesCopied: Integer;
   TotalBytesCopied: Int64;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempSignature: TMD5Digest;
   TempCompression: Byte;
   TempFilePos: Int64;
begin
   ToFile.LockFileSection;
   FromFile.LockFileSection;
   try
      Result:=DBISAM_NONE;
      { Be sure to over-alloocate buffer for possible increase in size
        due to de-compression }
      CopyBuffer:=AllocMem(COPY_BUFFER_SIZE*2);
      try
         if Assigned(CopyFileCallback) then
            CopyFileCallback(ClientData,ToFile.FileName,0);
         TempLastPercentDone:=0;
         TotalBytesCopied:=0;
         { First check for a compression signature }
         TempCompression:=NO_COMPRESSION;
         TempFilePos:=FromFile.Seek(FromHandle,0,FROM_CURRENT);
         FromFile.Read(FromHandle,TempSignature,SizeOf(TMD5Digest));
         if MD5DigestCompare(TempSignature,MD5String(COMPRESSION_SIGNATURE)) then
            FromFile.Read(FromHandle,TempCompression,SizeOf(Byte))
         else
            FromFile.Seek(FromHandle,TempFilePos,FROM_BOF);
         ToFile.Seek(ToHandle,0,FROM_BOF);
         if (TempCompression > NO_COMPRESSION) then
            begin
            repeat
               BytesCopied:=0;
               FromFile.Read(FromHandle,BytesCopied,SizeOf(Integer));
               if (BytesCopied > 0) then
                  begin
                  FromFile.Read(FromHandle,CopyBuffer^,BytesCopied);
                  DecompressedBuffer:=nil;
                  DecompressedBytes:=0;
                  Decompress(Pointer(CopyBuffer),BytesCopied,
                             Pointer(DecompressedBuffer),DecompressedBytes);
                  try
                     ToFile.Write(ToHandle,DecompressedBuffer^,DecompressedBytes);
                  finally
                     DeAllocMem(DecompressedBuffer);
                  end;
                  Inc(TotalBytesCopied,DecompressedBytes);
                  if Assigned(CopyFileCallback) then
                     begin
                     TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                     if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                        begin
                        CopyFileCallback(ClientData,ToFile.FileName,TempPercentDone);
                        TempLastPercentDone:=TempPercentDone;
                        end;
                     end;
                  end
               else
                  Break;
            until (TotalBytesCopied >= TotalBytes);
            end
         else
            begin
            repeat
               BytesCopied:=FromFile.Read(FromHandle,CopyBuffer^,MinimumInteger((TotalBytes-TotalBytesCopied),COPY_BUFFER_SIZE));
               if (BytesCopied > 0) then
                  begin
                  ToFile.Write(ToHandle,CopyBuffer^,BytesCopied);
                  Inc(TotalBytesCopied,BytesCopied);
                  if Assigned(CopyFileCallback) then
                     begin
                     TempPercentDone:=Trunc(((TotalBytesCopied/TotalBytes)*100));
                     if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                        begin
                        CopyFileCallback(ClientData,ToFile.FileName,TempPercentDone);
                        TempLastPercentDone:=TempPercentDone;
                        end;
                     end;
                  end
               else
                  Break;
            until (TotalBytesCopied >= TotalBytes);
            end;
         if Assigned(CopyFileCallback) then
            CopyFileCallback(ClientData,ToFile.FileName,100);
      finally
         DeAllocMem(CopyBuffer);
      end;
   finally
      FromFile.UnlockFileSection;
      ToFile.UnlockFileSection;
   end;
end;

function TDataEngine.SkipFromHandle(FromFile: TBaseFile; FromHandle: Integer;
                                    TotalBytes: Int64): Integer;
var
   CopyBuffer: Pointer;
   DecompressedBuffer: Pointer;
   DecompressedBytes: Integer;
   BytesCopied: Integer;
   TotalBytesCopied: Int64;
   TempSignature: TMD5Digest;
   TempCompression: Byte;
   TempFilePos: Int64;
begin
   FromFile.LockFileSection;
   try
      Result:=DBISAM_NONE;
      { Be sure to over-alloocate buffer for possible increase in size
        due to de-compression }
      CopyBuffer:=AllocMem(COPY_BUFFER_SIZE*2);
      try
         TotalBytesCopied:=0;
         { First check for a compression signature }
         TempCompression:=NO_COMPRESSION;
         TempFilePos:=FromFile.Seek(FromHandle,0,FROM_CURRENT);
         FromFile.Read(FromHandle,TempSignature,SizeOf(TMD5Digest));
         if MD5DigestCompare(TempSignature,MD5String(COMPRESSION_SIGNATURE)) then
            FromFile.Read(FromHandle,TempCompression,SizeOf(Byte))
         else
            FromFile.Seek(FromHandle,TempFilePos,FROM_BOF);
         if (TempCompression > NO_COMPRESSION) then
            begin
            repeat
               BytesCopied:=0;
               FromFile.Read(FromHandle,BytesCopied,SizeOf(Integer));
               if (BytesCopied > 0) then
                  begin
                  FromFile.Read(FromHandle,CopyBuffer^,BytesCopied);
                  DecompressedBuffer:=nil;
                  DecompressedBytes:=0;
                  Decompress(Pointer(CopyBuffer),BytesCopied,
                             Pointer(DecompressedBuffer),DecompressedBytes);
                  DeAllocMem(DecompressedBuffer);
                  Inc(TotalBytesCopied,DecompressedBytes);
                  end
               else
                  Break;
            until (TotalBytesCopied >= TotalBytes);
            end
         else
            begin
            repeat
               BytesCopied:=FromFile.Read(FromHandle,CopyBuffer^,COPY_BUFFER_SIZE);
               if (BytesCopied > 0) then
                  Inc(TotalBytesCopied,BytesCopied)
               else
                  Break;
            until (TotalBytesCopied >= TotalBytes);
            end;
      finally
         DeAllocMem(CopyBuffer);
      end;
   finally
      FromFile.UnlockFileSection;
   end;
end;

procedure TDataEngine.Initialize(const LockFile: string;
                                 const ServerName: string;
                                 const ServerDescription: string;
                                 const ServerMainAddress: string;
                                 ServerMainPort: Integer;
                                 ServerMainThreadCacheSize: Integer;
                                 const ServerAdminAddress: string;
                                 ServerAdminPort: Integer;
                                 ServerAdminThreadCacheSize: Integer;
                                 ServerEncryptedOnly: Boolean;
                                 const ServerEncryptionPassword: string;
                                 const ServerConfigFileName: string;
                                 const ServerConfigPassword: string;
                                 ServerLicensedConnections: Word);
begin
   Randomize;
   FIsWindows95:=(OSGetVersion=4.00) and (OSGetPlatform=VER_PLATFORM_WIN32_WINDOWS);
   FLockFileName:=LockFile;
   if FLargeFileSupport then
      begin
      FMaximumFileSize:=128000000000;
      FMaximumNumRecords:=1000000000;
      FFileLockByte:=High(Int64);
      FRecordLockByte:=High(Int64);
      end
   else
      begin
      FMaximumFileSize:=4000000000;
      FMaximumNumRecords:=200000000;
      FFileLockByte:=Int64(High(LongWord));
      FRecordLockByte:=Int64(High(LongWord));
      end;
   FFileLockRange:=High(Word);
   FTransLockRange:=MAX_NUM_TABLES;
   FReadLockRange:=High(Word);
   FWriteLockRange:=High(Word);
   FTransWriteLockRange:=(MAX_NUM_TABLES*FWriteLockRange);
   FRecordLockRange:=FMaximumNumRecords;
   FTransLockByte:=(FFileLockByte-FFileLockRange);
   FReadLockByte:=(FTransLockByte-FTransLockRange);
   FWriteLockByte:=(FTransLockByte-FTransLockRange);
   FTransWriteLockByte:=(FTransLockByte-FTransLockRange);
   FSemaphoreLockByte:=(FRecordLockByte-FRecordLockRange);
   FSemaphoreLockRange:=((High(Byte)+1)*4);
   GetFunctions;
   if FIsServer and (FServer=nil) then
      FServer:=TDataServer.Create(ServerName,ServerDescription,
                                  ServerMainAddress,ServerMainPort,
                                  ServerMainThreadCacheSize,
                                  ServerAdminAddress,ServerAdminPort,
                                  ServerAdminThreadCacheSize,
                                  ServerEncryptedOnly,
                                  ServerEncryptionPassword,
                                  ServerConfigFileName,ServerConfigPassword,
                                  ServerLicensedConnections)
   else
      begin
      end;
   FInitialized:=True;
end;

procedure TDataEngine.Reset;
begin
   FreeFunctions;
   if FIsServer and (FServer <> nil) then
      begin
      TDataServer(FServer).Free;
      FServer:=nil;
      end;
   { Free all opened files, including in-memory files }
   LockPhysicalFileList;
   try
      FreePhysicalFiles;
   finally
      UnlockPhysicalFileList;
   end;
   { Free all opened files, including in-memory files }
   LockMemoryFileList;
   try
      FreeMemoryFiles;
   finally
      UnlockMemoryFileList;
   end;
   FInitialized:=False;
end;

procedure TDataEngine.GetServerUserNames(List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Configuration.GetUserList(List)
      end;
end;

procedure TDataEngine.GetServerUser(const UserName: string; var UserPassword: string;
                                    var UserDescription: string;
                                    var IsAdministrator: Boolean;
                                    var MaxConnections: Word);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetUser(UserName,UserPassword,
                                       UserDescription,IsAdministrator,
                                       MaxConnections)) then
            RaiseError(DBISAM_REMOTENOUSER,Name,UserName);
         end;
      end;
end;

procedure TDataEngine.AddServerUser(const UserName: string; const UserPassword: string;
                                    const UserDescription: string;
                                    IsAdministrator: Boolean;
                                    MaxConnections: Word);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (UserName='') then
            RaiseError(DBISAM_REMOTEINVUSER,Name,UserName);
         if (not Configuration.AddUser(UserName,UserPassword,
                                       UserDescription,IsAdministrator,
                                       MaxConnections)) then
            RaiseError(DBISAM_REMOTEDUPUSER,Name,UserName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerUser(const UserName: string; const UserPassword: string;
                                       const UserDescription: string;
                                       IsAdministrator: Boolean;
                                       MaxConnections: Word);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.ModifyUser(UserName,UserPassword,
                                          UserDescription,IsAdministrator,
                                          MaxConnections)) then
            RaiseError(DBISAM_REMOTENOUSER,Name,UserName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerUserPassword(const UserName: string;
                                                 const UserPassword: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.ModifyUserPassword(UserName,UserPassword)) then
            RaiseError(DBISAM_REMOTENOUSER,Name,UserName);
         end;
      end;
end;

procedure TDataEngine.DeleteServerUser(const UserName: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.DeleteUser(UserName)) then
            RaiseError(DBISAM_REMOTENOUSER,Name,UserName);
         end;
      end;
end;

procedure TDataEngine.GetServerDatabaseNames(List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Configuration.GetAllDatabaseList(List);
      end;
end;

procedure TDataEngine.GetServerDatabase(const DatabaseName: string;
                                         var DatabaseDescription: string;
                                          var ServerPath: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetDatabase(DatabaseName,DatabaseDescription,
                                           ServerPath)) then
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.AddServerDatabase(const DatabaseName: string;
                                        const DatabaseDescription: string;
                                        const ServerPath: string);
var
   TempError: Boolean;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (DatabaseName='') or (AnsiCompareText(DatabaseName,INMEMORY_DATABASE_NAME)=0) or
            (AnsiCompareText(DatabaseName,REMOTE_RESULTSET_NAME)=0) then
            RaiseError(DBISAM_REMOTEINVDB,Name,'',DatabaseName);
         if (not Configuration.AddDatabase(DatabaseName,DatabaseDescription,
                                           ServerPath,TempError)) then
            begin
            if TempError then
               RaiseError(DBISAM_REMOTEINVDB,Name,'',DatabaseName)
            else
               RaiseError(DBISAM_REMOTEDUPDB,Name,'',DatabaseName);
            end;
         end;
      end;
end;

procedure TDataEngine.ModifyServerDatabase(const DatabaseName: string;
                                           const DatabaseDescription: string;
                                            const ServerPath: string);
var
   TempError: Boolean;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.ModifyDatabase(DatabaseName,DatabaseDescription,
                                              ServerPath,TempError)) then
            begin
            if TempError then
               RaiseError(DBISAM_REMOTEINVDB,Name,'',DatabaseName)
            else
               RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
            end;
         end;
      end;
end;

procedure TDataEngine.DeleteServerDatabase(const DatabaseName: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.DeleteDatabase(DatabaseName)) then
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.GetServerDatabaseUserNames(const DatabaseName: string;
                                                 List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetDatabaseUserList(DatabaseName,List)) then
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.GetServerDatabaseUser(const DatabaseName: string;
                                            const AuthorizedUser: string;
                                              var UserRights: Integer);
var
   TempDescription: string;
   TempPath: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetDatabase(DatabaseName,TempDescription,
                                      TempPath) then
            begin
            if (not Configuration.GetDatabaseUser(DatabaseName,AuthorizedUser,UserRights)) then
               RaiseError(DBISAM_REMOTENODBUSER,Name,AuthorizedUser,DatabaseName);
            end
         else
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.AddServerDatabaseUser(const DatabaseName: string;
                                              const AuthorizedUser: string;
                                              RightsToAssign: Integer);
var
   TempDescription: string;
   TempPath: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetDatabase(DatabaseName,TempDescription,
                                      TempPath) then
            begin
            if (not Configuration.AddDatabaseUser(DatabaseName,AuthorizedUser,RightsToAssign)) then
               RaiseError(DBISAM_REMOTEDUPDBUSER,Name,AuthorizedUser,DatabaseName);
            end
         else
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerDatabaseUser(const DatabaseName: string;
                                               const AuthorizedUser: string;
                                                 RightsToAssign: Integer);
var
   TempDescription: string;
   TempPath: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetDatabase(DatabaseName,TempDescription,
                                      TempPath) then
            begin
            if (not Configuration.ModifyDatabaseUser(DatabaseName,AuthorizedUser,RightsToAssign)) then
               RaiseError(DBISAM_REMOTENODBUSER,Name,AuthorizedUser,DatabaseName);
            end
         else
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.DeleteServerDatabaseUser(const DatabaseName: string;
                                                 const AuthorizedUser: string);
var
   TempDescription: string;
   TempPath: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetDatabase(DatabaseName,TempDescription,
                                      TempPath) then
            begin
            if (not Configuration.DeleteDatabaseUser(DatabaseName,AuthorizedUser)) then
               RaiseError(DBISAM_REMOTENODBUSER,Name,AuthorizedUser,DatabaseName);
            end
         else
            RaiseError(DBISAM_REMOTENODB,Name,'',DatabaseName);
         end;
      end;
end;

procedure TDataEngine.GetServerProcedureNames(List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Configuration.GetAllProcedureList(List);
      end;
end;

procedure TDataEngine.GetServerProcedure(const ProcedureName: string;
                                          var ProcedureDescription: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetProcedure(ProcedureName,ProcedureDescription)) then
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.AddServerProcedure(const ProcedureName: string;
                                         const ProcedureDescription: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (ProcedureName='') then
            RaiseError(DBISAM_REMOTEINVPROC,Name,'','','','','','',ProcedureName);
         if (not Configuration.AddProcedure(ProcedureName,ProcedureDescription)) then
            RaiseError(DBISAM_REMOTEDUPPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerProcedure(const ProcedureName: string;
                                            const ProcedureDescription: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.ModifyProcedure(ProcedureName,ProcedureDescription)) then
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.DeleteServerProcedure(const ProcedureName: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.DeleteProcedure(ProcedureName)) then
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.GetServerProcedureUserNames(const ProcedureName: string;
                                                  List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetProcedureUserList(ProcedureName,List)) then
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.GetServerProcedureUser(const ProcedureName: string;
                                             const AuthorizedUser: string;
                                               var UserRights: Integer);
var
   TempDescription: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetProcedure(ProcedureName,TempDescription) then
            begin
            if (not Configuration.GetProcedureUser(ProcedureName,AuthorizedUser,UserRights)) then
               RaiseError(DBISAM_REMOTENOPROCUSER,Name,AuthorizedUser,'','','','','',ProcedureName);
            end
         else
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.AddServerProcedureUser(const ProcedureName: string;
                                               const AuthorizedUser: string;
                                               RightsToAssign: Integer);
var
   TempDescription: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetProcedure(ProcedureName,TempDescription) then
            begin
            if (not Configuration.AddProcedureUser(ProcedureName,AuthorizedUser,RightsToAssign)) then
               RaiseError(DBISAM_REMOTEDUPPROCUSER,Name,AuthorizedUser,'','','','','',ProcedureName);
            end
         else
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerProcedureUser(const ProcedureName: string;
                                               const AuthorizedUser: string;
                                                 RightsToAssign: Integer);
var
   TempDescription: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetProcedure(ProcedureName,TempDescription) then
            begin
            if (not Configuration.ModifyProcedureUser(ProcedureName,AuthorizedUser,RightsToAssign)) then
               RaiseError(DBISAM_REMOTENOPROCUSER,Name,AuthorizedUser,'','','','','',ProcedureName);
            end
         else
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.DeleteServerProcedureUser(const ProcedureName: string;
                                                 const AuthorizedUser: string);
var
   TempDescription: string;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if Configuration.GetProcedure(ProcedureName,TempDescription) then
            begin
            if (not Configuration.DeleteProcedureUser(ProcedureName,AuthorizedUser)) then
               RaiseError(DBISAM_REMOTENOPROCUSER,Name,AuthorizedUser,'','','','','',ProcedureName);
            end
         else
            RaiseError(DBISAM_REMOTENOPROC,Name,'','','','','','',ProcedureName);
         end;
      end;
end;

procedure TDataEngine.GetServerEventNames(List: TStrings);
begin
   List.Clear;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Configuration.GetEventList(List)
      end;
end;

procedure TDataEngine.GetServerEvent(const EventName: string; var EventDescription: string;
                                     var EventRunType: Byte;
                                     var EventStartDate: TDateTime;
                                     var EventEndDate: TDateTime;
                                     var EventStartTime: TDateTime;
                                     var EventEndTime: TDateTime;
                                     var EventInterval: Word;
                                     var EventDays: TConfigDays;
                                     var EventDayOfMonth: Byte;
                                     var EventDayOfWeek: Byte;
                                     var EventMonths: TConfigMonths;
                                     var EventLastRun: TDateTime);
var
   TempInProgress: Boolean;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.GetEvent(EventName,EventDescription,
                                        EventRunType,
                                        EventStartDate,EventEndDate,
                                        EventStartTime,EventEndTime,
                                        EventInterval,
                                        EventDays,
                                        EventDayOfMonth,
                                        EventDayOfWeek,
                                        EventMonths,
                                        EventLastRun,TempInProgress)) then
            RaiseError(DBISAM_REMOTENOEVENT,Name,'','','','','','','',EventName);
         end;
      end;
end;

procedure TDataEngine.AddServerEvent(const EventName: string; const EventDescription: string;
                                     EventRunType: Byte;
                                     EventStartDate: TDateTime;
                                     EventEndDate: TDateTime;
                                     EventStartTime: TDateTime;
                                     EventEndTime: TDateTime;
                                     EventInterval: Word;
                                     EventDays: TConfigDays;
                                     EventDayOfMonth: Byte;
                                     EventDayOfWeek: Byte;
                                     EventMonths: TConfigMonths);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (EventName='') then
            RaiseError(DBISAM_REMOTEINVEVENT,Name,'','','','','','',EventName);
         if (not Configuration.AddEvent(EventName,EventDescription,
                                        EventRunType,
                                        EventStartDate,EventEndDate,
                                        EventStartTime,EventEndTime,
                                        EventInterval,
                                        EventDays,
                                        EventDayOfMonth,
                                        EventDayOfWeek,
                                        EventMonths)) then
            RaiseError(DBISAM_REMOTEDUPEVENT,Name,'','','','','','','',EventName);
         end;
      end;
end;

procedure TDataEngine.ModifyServerEvent(const EventName: string; const EventDescription: string;
                                        EventRunType: Byte;
                                        EventStartDate: TDateTime;
                                        EventEndDate: TDateTime;
                                        EventStartTime: TDateTime;
                                        EventEndTime: TDateTime;
                                        EventInterval: Word;
                                        EventDays: TConfigDays;
                                        EventDayOfMonth: Byte;
                                        EventDayOfWeek: Byte;
                                        EventMonths: TConfigMonths);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.ModifyEvent(EventName,EventDescription,
                                           EventRunType,
                                           EventStartDate,EventEndDate,
                                           EventStartTime,EventEndTime,
                                           EventInterval,
                                           EventDays,
                                           EventDayOfMonth,
                                           EventDayOfWeek,
                                           EventMonths)) then
            RaiseError(DBISAM_REMOTENOEVENT,Name,'','','','','','','',EventName);
         end;
      end;
end;

procedure TDataEngine.DeleteServerEvent(const EventName: string);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         if (not Configuration.DeleteEvent(EventName)) then
            RaiseError(DBISAM_REMOTENOEVENT,Name,'','','','','','','',EventName);
         end;
      end;
end;

procedure TDataEngine.GetServerConfig(var DenyLogins: Boolean; var MaxConnections: Word;
                                      var ConnectTimeout: Word; var DeadSessionInterval: Word;
                                      var DeadSessionExpires: Word; var MaxDeadSessions: Word;
                                      var TempDirectory: string;
                                      AuthorizedAddresses: TStrings; BlockedAddresses: TStrings);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Configuration.GetServer(DenyLogins,MaxConnections,
                                 ConnectTimeout,DeadSessionInterval,
                                 DeadSessionExpires,MaxDeadSessions,
                                 TempDirectory,
                                 AuthorizedAddresses,BlockedAddresses);
      end;
end;

procedure TDataEngine.ModifyServerConfig(DenyLogins: Boolean; MaxConnections: Word;
                                           ConnectTimeout: Word; DeadSessionInterval: Word;
                                           DeadSessionExpires: Word; MaxDeadSessions: Word;
                                           const TempDirectory: string;
                                           AuthorizedAddresses: TStrings; BlockedAddresses: TStrings);
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         begin
         MaxConnections:=MinimumWord(MaxConnections,LicensedConnections);
         if (ConnectTimeout < MIN_TIMEOUT) then
            ConnectTimeout:=MIN_TIMEOUT;
         Configuration.ModifyServer(DenyLogins,MaxConnections,
                                    ConnectTimeout,DeadSessionInterval,
                                    DeadSessionExpires,MaxDeadSessions,
                                    TempDirectory,
                                    AuthorizedAddresses,BlockedAddresses);
         DeadSessionTimer.Interval:=(DeadSessionInterval*1000);
         end;
      end;
end;

procedure TDataEngine.ServerStart;
begin
   if FIsServer then
      begin
      if Assigned(FServerStartCallback) then
         FServerStartCallback(FServerStartClientData);
      end;
end;

procedure TDataEngine.ServerStop;
begin
   if FIsServer then
      begin
      if Assigned(FServerStopCallback) then
         FServerStopCallback(FServerStopClientData);
      end;
end;

procedure TDataEngine.LogServerEvent(LogRecord: TDataLogRecord);
begin
   if FIsServer then
      begin
      if Assigned(FServerLogEventCallback) then
         FServerLogEventCallback(FServerLogEventClientData,LogRecord);
      end;
end;

function TDataEngine.GetServerLogCount: Integer;
begin
   Result:=0;
   if FIsServer then
      begin
      if Assigned(FServerLogCountCallback) then
         FServerLogCountCallback(FServerLogCountClientData,Result);
      end;
end;

function TDataEngine.GetServerLogRecord(Number: Integer): TDataLogRecord;
begin
   FillChar(Result,SizeOf(TDataLogRecord),#0);
   if FIsServer then
      begin
      if Assigned(FServerLogRecordCallback) then
         FServerLogRecordCallback(FServerLogRecordClientData,Number,Result);
      end;
end;

function TDataEngine.ServerConnect(IsEncrypted: Boolean;
                                   const ConnectAddress: string): TObject;
begin
   Result:=nil;
   if FIsServer then
      begin
      if Assigned(FServerConnectCallback) then
         FServerConnectCallback(FServerConnectClientData,IsEncrypted,
                                ConnectAddress,Result);
      end;
end;

procedure TDataEngine.ServerReconnect(IsEncrypted: Boolean;
                                      const ConnectAddress: string;
                                      UserData: TObject);
begin
   if FIsServer then
      begin
      if Assigned(FServerReconnectCallback) then
         FServerReconnectCallback(FServerReconnectClientData,IsEncrypted,
                                  ConnectAddress,UserData);
      end;
end;

procedure TDataEngine.ServerLogin(const UserName: string;
                                  UserData: TObject);
begin
   if FIsServer then
      begin
      if Assigned(FServerLoginCallback) then
         FServerLoginCallback(FServerLoginClientData,UserName,UserData);
      end;
end;

procedure TDataEngine.ServerLogout(var UserData: TObject);
begin
   if FIsServer then
      begin
      if Assigned(FServerLogoutCallback) then
         FServerLogoutCallback(FServerLogoutClientData,UserData);
      end;
end;

procedure TDataEngine.ServerDisconnect(UserData: TObject;
                                        const LastConnectAddress: string);
begin
   if FIsServer then
      begin
      if Assigned(FServerDisconnectCallback) then
         FServerDisconnectCallback(FServerDisconnectClientData,UserData,
                                   LastConnectAddress);
      end;
end;

procedure TDataEngine.ServerScheduledEvent(const EventName: string;
                                           var Completed: Boolean);
begin
   if FIsServer then
      begin
      if Assigned(FServerScheduledEventCallback) then
         FServerScheduledEventCallback(FServerScheduledEventClientData,
                                       EventName,Completed);
      end;
end;

procedure TDataEngine.StartAdminServer;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         StartAdminServer;
      end;
end;

procedure TDataEngine.StopAdminServer;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         StopAdminServer;
      end;
end;

procedure TDataEngine.StartMainServer;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         StartMainServer;
      end;
end;

procedure TDataEngine.StopMainServer;
begin
   if FIsServer then
      begin
      with TDataServer(FServer) do
         StopMainServer;
      end;
end;

function TDataEngine.GetServerUTCDateTime: TDateTime;
begin
   Result:=0;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetUTCDateTime;
      end;
end;

function TDataEngine.GetServerUpTime: Int64;
begin
   Result:=0;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetUpTime;
      end;
end;

function TDataEngine.GetServerMemoryUsage: double;
begin
   Result:=0;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetMemoryUsage;
      end;
end;

function TDataEngine.GetServerSessionCount: Integer;
begin
   Result:=0;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetServerSessionCount;
      end;
end;

function TDataEngine.GetServerConnectedSessionCount: Integer;
begin
   Result:=0;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetServerConnectedSessionCount;
      end;
end;

function TDataEngine.GetServerSessionInfo(SessionNum: Integer;
                                          var SessionID: Integer;
                                          var CreatedOn: TDateTime;
                                          var LastConnectedOn: TDateTime;
                                          var UserName: string;
                                          var UserAddress: string;
                                          var IsEncryptedSession: Boolean;
                                          var LastUserAddress: string): Boolean;
begin
   Result:=False;
   if FIsServer then
      begin
      with TDataServer(FServer) do
         Result:=GetServerSessionInfo(SessionNum,SessionID,
                                      CreatedOn,LastConnectedOn,
                                      UserName,UserAddress,
                                      IsEncryptedSession,LastUserAddress);
      end;
end;

function TDataEngine.DisconnectServerSession(SessionID: Integer): Boolean;
begin
   Result:=False;
   if FIsServer then
      Result:=TDataServer(FServer).DisconnectServerSession(TServerSession(SessionID));
end;

function TDataEngine.RemoveServerSession(SessionID: Integer): Boolean;
begin
   Result:=False;
   if FIsServer then
      Result:=TDataServer(FServer).RemoveServerSession(TServerSession(SessionID));
end;

procedure TDataEngine.ServerProcedure(DataSession: TDataSession;
                                      const ProcedureName: string;
                                      InParamCount: Word;
                                      const InParamDefinitions: array of pFieldDefinition;
                                      InRecordBuffer: PChar;
                                      out OutParamCount: Word;
                                      out OutParamDefinitions: array of pFieldDefinition;
                                      out OutRecordBuffer: PChar;
                                      out OutBlobCount: Word;
                                      out OutBlobBuffers: array of PChar);
begin
   OutParamCount:=0;
   OutRecordBuffer:=nil;
   OutBlobCount:=0;
   if FIsServer then
      begin
      if Assigned(FServerProcedureCallback) then
         begin
         DataSession.InsideEngine:=True;
         try
            FServerProcedureCallback(FServerProcedureClientData,
                                     DataSession,ProcedureName,
                                     InParamCount,InParamDefinitions,
                                     InRecordBuffer,
                                     OutParamCount,OutParamDefinitions,
                                     OutRecordBuffer,
                                     OutBlobCount,OutBlobBuffers);
         finally
            DataSession.InsideEngine:=False;
         end;
         end;
      end;
end;

procedure TDataEngine.SetServerStartCallback(ClientData: Integer;
                                              StartCallback: pServerNotifyCallback);
begin
   FServerStartClientData:=ClientData;
   FServerStartCallback:=pServerNotifyCallback(@StartCallback);
end;

procedure TDataEngine.SetServerStopCallback(ClientData: Integer;
                                             StopCallback: pServerNotifyCallback);
begin
   FServerStopClientData:=ClientData;
   FServerStopCallback:=pServerNotifyCallback(@StopCallback);
end;

procedure TDataEngine.SetServerLogEventCallback(ClientData: Integer;
                                                LogEventCallback: pServerLogEventCallback);
begin
   FServerLogEventClientData:=ClientData;
   FServerLogEventCallback:=pServerLogEventCallback(@LogEventCallback);
end;

procedure TDataEngine.SetServerLogCountCallback(ClientData: Integer;
                                                LogCountCallback: pServerLogCountCallback);
begin
   FServerLogCountClientData:=ClientData;
   FServerLogCountCallback:=pServerLogCountCallback(@LogCountCallback);
end;

procedure TDataEngine.SetServerLogRecordCallback(ClientData: Integer;
                                                 LogRecordCallback: pServerLogRecordCallback);
begin
   FServerLogRecordClientData:=ClientData;
   FServerLogRecordCallback:=pServerLogRecordCallback(@LogRecordCallback);
end;

procedure TDataEngine.SetServerConnectCallback(ClientData: Integer;
                                                ConnectCallback: pServerConnectCallback);
begin
   FServerConnectClientData:=ClientData;
   FServerConnectCallback:=pServerConnectCallback(@ConnectCallback);
end;

procedure TDataEngine.SetServerReconnectCallback(ClientData: Integer;
                                                 ReconnectCallback: pServerReconnectCallback);
begin
   FServerReconnectClientData:=ClientData;
   FServerReconnectCallback:=pServerReconnectCallback(@ReconnectCallback);
end;

procedure TDataEngine.SetServerLoginCallback(ClientData: Integer;
                                              LoginCallback: pServerLoginCallback);
begin
   FServerLoginClientData:=ClientData;
   FServerLoginCallback:=pServerLoginCallback(@LoginCallback);
end;

procedure TDataEngine.SetServerLogoutCallback(ClientData: Integer;
                                               LogoutCallback: pServerLogoutCallback);
begin
   FServerLogoutClientData:=ClientData;
   FServerLogoutCallback:=pServerLogoutCallback(@LogoutCallback);
end;

procedure TDataEngine.SetServerDisconnectCallback(ClientData: Integer;
                                                   DisconnectCallback: pServerDisconnectCallback);
begin
   FServerDisconnectClientData:=ClientData;
   FServerDisconnectCallback:=pServerDisconnectCallback(@DisconnectCallback);
end;

procedure TDataEngine.SetServerScheduledEventCallback(ClientData: Integer;
                                                       ScheduledEventCallback: pServerScheduledEventCallback);
begin
   FServerScheduledEventClientData:=ClientData;
   FServerScheduledEventCallback:=pServerScheduledEventCallback(@ScheduledEventCallback);
end;

procedure TDataEngine.SetServerProcedureCallback(ClientData: Integer;
                                                   ProcedureCallback: pServerProcedureCallback);
begin
   FServerProcedureClientData:=ClientData;
   FServerProcedureCallback:=pServerProcedureCallback(@ProcedureCallback);
end;

{ TEngineFile }

constructor TEngineFile.Create(Owner: TObject);
begin
end;

destructor TEngineFile.Destroy;
begin
   if FIsOpen then
      CloseFile;
   inherited Destroy;
end;

function TEngineFile.LockRegion(Offset: Int64; LockLength: Int64;
                                LockIt: Boolean): Boolean;
begin
   Result:=False;
   if (FBaseFile <> nil) then
      begin
      if LockIt then
         Result:=FBaseFile.Lock(Offset,LockLength)
      else
         Result:=FBaseFile.Unlock(Offset,LockLength);
      end
end;

function TEngineFile.Read(var Buffer; NumBytes: Integer;
                           IgnoreLessBytes: Boolean): Integer;
begin
   Result:=0;
   if (FBaseFile <> nil) then
      begin
      Result:=FBaseFile.Read(FHandle,Buffer,NumBytes);
      if (Result <> NumBytes) and (not IgnoreLessBytes) then
         DataEngine.RaiseError(DBISAM_READERR,'','','',ProperFileName);
      end
   else
      DataEngine.RaiseError(DBISAM_READERR,'','','',ProperFileName);
end;

procedure TEngineFile.Write(const Buffer; NumBytes: Integer);
begin
   if (FBaseFile <> nil) then
      begin
      if (FBaseFile.Write(FHandle,Buffer,NumBytes) <> NumBytes) then
         DataEngine.RaiseError(DBISAM_WRITEERR,'','','',ProperFileName);
      end
   else
      DataEngine.RaiseError(DBISAM_WRITEERR,'','','',ProperFileName);
end;

procedure TEngineFile.Flush;
begin
   if (FBaseFile <> nil) then
      FBaseFile.Flush(FHandle);
end;

function TEngineFile.Seek(Position: Int64; From: Word): Int64;
begin
   Result:=0;
   if (FBaseFile <> nil) then
      Result:=FBaseFile.Seek(FHandle,Position,From);
end;

function TEngineFile.GetPos: Int64;
begin
   Result:=0;
   if (FBaseFile <> nil) then
      Result:=FBaseFile.Seek(FHandle,0,FROM_CURRENT);
end;

function TEngineFile.GetSize: Int64;
var
   CurPos: Int64;
begin
   Result:=0;
   if (FBaseFile <> nil) then
      begin
      CurPos:=FBaseFile.Seek(FHandle,0,FROM_CURRENT);
      try
         Result:=FBaseFile.Seek(FHandle,0,FROM_EOF);
      finally
         FBaseFile.Seek(FHandle,CurPos,FROM_BOF);
      end;
      end;
end;

procedure TEngineFile.OpenFile;
begin
   if (not Exists) then
      DataEngine.RaiseError(DBISAM_OSENOENT,'','','',ProperFileName);
   FMarkedReadOnly:=False;
   FHandle:=DataEngine.OpenFile(FFileName,FInMemory,FBaseFile,FMarkedReadOnly,
                                FReadOnly,FExclusive,FTemporary,FHidden);
   if (FHandle < 0) then
      DataEngine.RaiseError(Abs(FHandle),'','','',ProperFileName);
   FIsOpen:=True;
end;

procedure TEngineFile.CloseFile;
begin
   if (FHandle > 0) and (FBaseFile <> nil) then
      begin
      DataEngine.CloseFile(FBaseFile,FInMemory,FHandle);
      FBaseFile:=nil;
      FHandle:=0;
      end;
   FIsOpen:=False;
end;

procedure TEngineFile.CreateFile;
begin
   FHandle:=DataEngine.CreateFile(FFileName,FInMemory,FBaseFile,FTemporary,FHidden);
   if (FHandle < 0) then
      DataEngine.RaiseError(Abs(FHandle),'','','',ProperFileName);
   FIsOpen:=True;
end;

procedure TEngineFile.DeleteFile;
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.DeleteFile(FFileName,FInMemory);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
end;

procedure TEngineFile.RenameFile(const NewName: string);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.RenameFile(FFileName,FInMemory,NewName);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
   FFileName:=NewName;
end;

procedure TEngineFile.CopyToFile(const NewName: string;
                                 Compression: Byte;
                                 ClientData: Integer;
                                 CopyFileCallback: pCopyFileCallback;
                                 ProgressPercent: Word);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.CopyToFile(FBaseFile,FHandle,FInMemory,NewName,
                                   Compression,ClientData,CopyFileCallback,
                                   ProgressPercent);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
end;

procedure TEngineFile.CopyFromFile(const FromName: string;
                                   ClientData: Integer;
                                   CopyFileCallback: pCopyFileCallback;
                                   ProgressPercent: Word);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.CopyFromFile(FBaseFile,FHandle,FInMemory,FromName,
                                     ClientData,CopyFileCallback,
                                     ProgressPercent);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',FFileName);
end;

procedure TEngineFile.CopyTo(EngineFile: TEngineFile;
                             Compression: Byte;
                             ClientData: Integer;
                             CopyFileCallback: pCopyFileCallback;
                             ProgressPercent: Word);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.CopyToHandle(FBaseFile,FHandle,
                                       EngineFile.BaseFile,EngineFile.Handle,
                                       Compression,ClientData,CopyFileCallback,
                                       ProgressPercent);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
end;

procedure TEngineFile.CopyFrom(EngineFile: TEngineFile;
                               TotalBytes: Int64;
                               ClientData: Integer;
                               CopyFileCallback: pCopyFileCallback;
                               ProgressPercent: Word);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.CopyFromHandle(FBaseFile,FHandle,
                                         EngineFile.BaseFile,EngineFile.Handle,
                                         TotalBytes,
                                         ClientData,CopyFileCallback,
                                         ProgressPercent);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
end;

procedure TEngineFile.SkipFrom(EngineFile: TEngineFile;
                               TotalBytes: Int64);
var
   TempResult: Integer;
begin
   TempResult:=DataEngine.SkipFromHandle(EngineFile.BaseFile,EngineFile.Handle,
                                         TotalBytes);
   if (TempResult < 0) then
      DataEngine.RaiseError(Abs(TempResult),'','','',ProperFileName);
end;

function TEngineFile.Exists: Boolean;
begin
   Result:=DataEngine.FileExists(FFileName,FInMemory,FHidden);
end;

procedure TEngineFile.LockFile;
begin
   if (FBaseFile <> nil) then
      FBaseFile.LockFileSection;
end;

procedure TEngineFile.UnlockFile;
begin
   if (FBaseFile <> nil) then
      FBaseFile.UnlockFileSection;
end;

function TEngineFile.GetProperFileName: string;
begin
   Result:=FFileName;
end;

{ TBuffer }

constructor TBuffer.Create(Owner: TBufferedFile);
begin
   FBufferedFile:=Owner;
   SetSize(FBufferedFile.BufferSize);
end;

destructor TBuffer.Destroy;
begin
   ResizeFileBuffer(0);
   inherited Destroy;
end;

procedure TBuffer.ResizeFileBuffer(Value: Integer);
begin
   ResizeBuffer(Value,FBuffer,FBufferSize);
end;

procedure TBuffer.Initialize(DefinitionPos: Byte=0);
begin
   FillChar(FBuffer^,FBufferSize,#0);
   IsDirty:=False;
end;

procedure TBuffer.Read(ReadBuffer: PChar);
begin
   Move(ReadBuffer^,FBuffer^,FBufferedFile.BufferSize);
   FIsDirty:=False;
end;

procedure TBuffer.Write(WriteBuffer: PChar);
begin
   Move(FBuffer^,WriteBuffer^,FBufferedFile.BufferSize);
   FIsDirty:=False;
end;

procedure TBuffer.SetNumber(Value: Integer);
begin
   FNumber:=Value;
end;

procedure TBuffer.SetSize(Value: Integer);
begin
   if (Value <> FSize) then
      begin
      ResizeFileBuffer(Value);
      FSize:=Value;
      end;
end;

procedure TBuffer.Copy(ToCopy: TBuffer);
begin
   FIsDirty:=ToCopy.FIsDirty;
   FNumber:=ToCopy.FNumber;
   Move(ToCopy.Buffer^,FBuffer^,MinimumInteger(FSize,ToCopy.Size));
end;

function TBuffer.IsEqualTo(ToCompare: TBuffer): Boolean;
begin
   Result:=(CompareBytes(ToCompare.Buffer,FBuffer,FSize,False)=CMP_EQUAL);
end;

function TBuffer.IsEqualToBuffer(BufferToCompare: PChar): Boolean;
begin
   Result:=(CompareBytes(BufferToCompare,FBuffer,FSize,False)=CMP_EQUAL);
end;

procedure TBuffer.CopyBuffer(BufferToCopy: PChar);
begin
   Move(BufferToCopy^,FBuffer^,FSize);
   FIsDirty:=True;
end;

procedure TBuffer.CopyToBuffer(BufferToCopyTo: PChar);
begin
   Move(FBuffer^,BufferToCopyTo^,FSize);
end;

procedure TBuffer.IncUseCount;
begin
   Inc(FUseCount)
end;

procedure TBuffer.DecUseCount;
begin
   if (FUseCount > 0) then
      Dec(FUseCount);
end;

procedure TBuffer.ClearUseCount;
begin
   FUseCount:=0;
end;

{ TBufferedFile }

constructor TBufferedFile.Create(Owner: TObject);
begin
   inherited Create(Owner);
   FDataTable:=TDataTable(Owner);
   if (not FDataTable.IsRemote) then
      begin
      FBuffers:=TList.Create;
      FWriteBuffers:=TList.Create;
      end;
end;

destructor TBufferedFile.Destroy;
begin
   if (not FDataTable.IsRemote) then
      begin
      CloseFile;
      ResizeReadBuffer(0);
      ResizeWriteBuffer(0);
      FWriteBuffers.Free;
      FBuffers.Free;
      end;
   inherited Destroy;
end;

procedure TBufferedFile.ResizeReadBuffer(Value: Integer);
begin
   ResizeBuffer(Value,FReadBuffer,FReadBufferSize);
end;

procedure TBufferedFile.ResizeWriteBuffer(Value: Integer);
begin
   ResizeBuffer(Value,FWriteBuffer,FWriteBufferSize);
end;

function TBufferedFile.GetTableName: string;
begin
   Result:=FDataTable.TableName;
end;

function TBufferedFile.GetProperDataDirectoryName: string;
begin
   Result:=FDataTable.ProperDataDirectoryName;
end;

function TBufferedFile.FindBuffer(BufferNum: Integer; var BufferIndex: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   BufferIndex:=0;
   if (FBuffers.Count=0) then
      Exit;
   CompareResult:=CMP_EQUAL;
   Low:=0;
   High:=(FBuffers.Count-1);
   while (Low <= High) do
      begin
      BufferIndex:=((Low+High) div 2);
      CompareResult:=CompareBufferNumbers(FBuffers[BufferIndex],BufferNum);
      case CompareResult of
         CMP_GREATER: High:=(BufferIndex-1);
         CMP_LESS: Low:=(BufferIndex+1);
         CMP_EQUAL:
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
   { Adjust the buffer index for proper insertion }
   if (CompareResult=CMP_LESS) then
      begin
      if (BufferIndex < FBuffers.Count) then
         Inc(BufferIndex);
      end;
end;

procedure TBufferedFile.CreateNewBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                        var BufferToCreate: TBuffer);
begin
   BufferToCreate:=CreateBuffer;
   BufferToCreate.Initialize(DefinitionPos);
   BufferToCreate.Number:=BufferNum;
   InsertAsFirstBuffer(BufferToCreate);
end;

procedure TBufferedFile.InsertAsFirstBuffer(BufferToInsert: TBuffer);
begin
   if (FFirstBuffer <> nil) and (FLastBuffer <> nil) then
      begin
      BufferToInsert.PrevBuffer:=nil;
      BufferToInsert.NextBuffer:=FFirstBuffer;
      FFirstBuffer.PrevBuffer:=BufferToInsert;
      FFirstBuffer:=BufferToInsert;
      end
   else
      begin
      BufferToInsert.PrevBuffer:=nil;
      BufferToInsert.NextBuffer:=nil;
      FFirstBuffer:=BufferToInsert;
      FLastBuffer:=BufferToInsert;
      end;
end;

procedure TBufferedFile.MoveToFirstBuffer(BufferToMove: TBuffer);
begin
   if (BufferToMove <> FFirstBuffer) then
      begin
      if (BufferToMove <> FLastBuffer) then
         begin
         BufferToMove.PrevBuffer.NextBuffer:=BufferToMove.NextBuffer;
         BufferToMove.NextBuffer.PrevBuffer:=BufferToMove.PrevBuffer;
         end
      else
         begin
         FLastBuffer:=BufferToMove.PrevBuffer;
         FLastBuffer.NextBuffer:=nil;
         end;
      BufferToMove.PrevBuffer:=nil;
      BufferToMove.NextBuffer:=FFirstBuffer;
      FFirstBuffer.PrevBuffer:=BufferToMove;
      FFirstBuffer:=BufferToMove;
      end;
end;

procedure TBufferedFile.DeleteBuffer(BufferToDelete: TBuffer);
begin
   if (BufferToDelete <> FFirstBuffer) then
      begin
      if (BufferToDelete <> FLastBuffer) then
         begin
         BufferToDelete.PrevBuffer.NextBuffer:=BufferToDelete.NextBuffer;
         BufferToDelete.NextBuffer.PrevBuffer:=BufferToDelete.PrevBuffer;
         end
      else
         begin
         FLastBuffer:=BufferToDelete.PrevBuffer;
         FLastBuffer.NextBuffer:=nil;
         end;
      end
   else
      begin
      if (BufferToDelete <> FLastBuffer) then
         begin
         FFirstBuffer:=BufferToDelete.NextBuffer;
         FFirstBuffer.PrevBuffer:=nil;
         end
      else
         begin
         FFirstBuffer:=nil;
         FLastBuffer:=nil;
         end;
      end;
end;

function TBufferedFile.FindFirstBuffer(BufferNum: Integer;
                                       var BufferToGet: TBuffer): Boolean;
var
   I: Integer;
   TempBuffer: TBuffer;
begin
   Result:=False;
   TempBuffer:=FFirstBuffer;
   I:=1;
   while (TempBuffer <> nil) and (I <= MRUBuffers) do
      begin
      if (TempBuffer.Number=BufferNum) then
         begin
         BufferToGet:=TempBuffer;
         Result:=True;
         Break;
         end;
      TempBuffer:=TempBuffer.NextBuffer;
      Inc(I);
      end;
end;

function TBufferedFile.GetReadAheadBuffers(DataCursor: TDataCursor;
                                           Direction: Byte): Integer;
begin
   Result:=1;
end;

function TBufferedFile.GetBuffer(DataCursor: TDataCursor; DefinitionPos: Byte;
                                 BufferNum: Integer; ReadAhead: Boolean; Direction: Byte;
                                 var BufferToGet: TBuffer): Boolean;
var
   BufferIndex: Integer;
   BuffersToRead: Integer;
begin
   BufferToGet:=nil;
   Result:=True;
   if (BufferNum=0) then
      CorruptError;
    if (BufferNum=(IOBlocksUsed+1)) then
      begin
      CheckMaxBuffers;
      BufferIndex:=FBuffers.Count;
      GetNewBuffer(DefinitionPos,BufferNum,BufferIndex,BufferToGet);
      BufferToGet.IncUseCount;
      FBuffers.Add(BufferToGet);
      Inc(FCacheHits);
      IncNextBuffer;
      end
   else
      begin
      if FindFirstBuffer(BufferNum,BufferToGet) then
         begin
         MoveToFirstBuffer(BufferToGet);
         Inc(FCacheHits);
         end
      else
         begin
         BufferIndex:=0;
         if FindBuffer(BufferNum,BufferIndex) then
            begin
            BufferToGet:=FBuffers[BufferIndex];
            MoveToFirstBuffer(BufferToGet);
            Inc(FCacheHits);
            end
         else
            begin
            { Version 5 }
            if (not DataCursor.DataSession.StrictChangeDetection) then
               begin
               Result:=(not DataCursor.InternalReadLockTable);
            { Version 5 }
               if (not Result) then
                  begin
                  BufferToGet:=nil;
                  Exit;
                  end;
               end;
            if ReadAhead and (Direction <> READ_CURRENT) then
               BuffersToRead:=MinimumInteger(GetReadAheadBuffers(DataCursor,Direction),
                                             ((IOBlocksUsed+1)-BufferNum))
            else
               BuffersToRead:=1;
            ReadBuffers(DefinitionPos,BufferNum,BuffersToRead,
                        Direction,BufferIndex,BufferToGet);
            end;
         end;
      if (BufferToGet=nil) or (BufferToGet.Number <> BufferNum) then
         CorruptError;
      BufferToGet.IncUseCount;
      end;
end;

procedure TBufferedFile.PutBuffer(BufferToRelease: TBuffer);
begin
   if (BufferToRelease <> nil) then
      BufferToRelease.DecUseCount;
end;

function TBufferedFile.FindBufferToDelete: TBuffer;
begin
   Result:=FLastBuffer;
   while (Result <> nil) do
      begin
      with Result do
         begin
         if (not IsDirty) and (UseCount=0) then
            Break;
         end;
      Result:=Result.PrevBuffer;
      end;
end;

procedure TBufferedFile.GetNewBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                     var BufferIndex: Integer;
                                     var BufferToGet: TBuffer);
begin
   if (FBuffers.Count=FBuffers.Capacity) then
      ClearLastBuffer(DefinitionPos,BufferNum,BufferIndex,BufferToGet)
   else
      CreateNewBuffer(DefinitionPos,BufferNum,BufferToGet);
end;

procedure TBufferedFile.ClearLastBuffer(DefinitionPos: Byte; BufferNum: Integer;
                                        var BufferIndex: Integer;
                                        var BufferToGet: TBuffer);
var
   DeleteIndex: Integer;
begin
   BufferToGet:=FindBufferToDelete;
   if (BufferToGet=nil) and (not FDataTable.InTransaction) then
      begin
      if FlushBuffers(True) then
         BufferToGet:=FindBufferToDelete;
      end;
   if (BufferToGet <> nil) then
      begin
      DeleteIndex:=0;
      if (not FindBuffer(BufferToGet.Number,DeleteIndex)) then
         CorruptError;
      if (DeleteIndex < BufferIndex) then
         Dec(BufferIndex);
      FBuffers.Delete(DeleteIndex);
      MoveToFirstBuffer(BufferToGet);
      with BufferToGet do
         begin
         Initialize(DefinitionPos);
         Number:=BufferNum;
         end;
      end
   else
      begin
      with FBuffers do
         Capacity:=Capacity+BufferExpand;
      CreateNewBuffer(DefinitionPos,BufferNum,BufferToGet);
      end;
end;

function TBufferedFile.DeleteLastBuffer: Boolean;
var
   DeleteIndex: Integer;
   BufferToDelete: TBuffer;
begin
   Result:=False;
   BufferToDelete:=FindBufferToDelete;
   if (BufferToDelete=nil) then
      begin
      if FlushBuffers(True) then
         BufferToDelete:=FindBufferToDelete;
      end;
   if (BufferToDelete <> nil) then
      begin
      DeleteBuffer(BufferToDelete);
      if (not FindBuffer(BufferToDelete.Number,DeleteIndex)) then
         CorruptError;
      FBuffers.Delete(DeleteIndex);
      BufferToDelete.Free;
      Result:=True;
      end;
end;

procedure TBufferedFile.ReadBuffers(DefinitionPos: Byte; BufferNum: Integer;
                                    NumBuffers: Integer; Direction: Byte;
                                    InsertIndex: Integer;
                                    var BufferToGet: TBuffer);
var
   I: Integer;
   ActualBufferSize: Integer;
   LastBufferNumber: Integer;
   BufferOffset: Integer;
   BufferFound: Boolean;
begin
   Inc(FCacheMisses);
   FReadSize:=(NumBuffers*IOBlockSize);
   if (Direction=READ_CURRENT) or (Direction=READ_FORWARD) then
      FReadFilePos:=HeaderSize+(Int64(BufferNum-1)*IOBlockSize)
   else
      FReadFilePos:=HeaderSize+((Int64(BufferNum)*IOBlockSize)-FReadSize);
   try
      ResizeReadBuffer(FReadSize);
      try
         LockFile;
         try
            Seek(FReadFilePos,FROM_BOF);
            ActualBufferSize:=Read(FReadBuffer^,FReadSize,
                                  ((Exclusive or FDataTable.InTransaction) and
                                   FDataTable.WrittenTo));
         finally
            UnlockFile;
         end;
         Inc(FReads);
         Inc(FTotalReads,ActualBufferSize);
         if (Direction=READ_CURRENT) or (Direction=READ_FORWARD) then
            begin
            BufferOffset:=(ActualBufferSize-IOBlockSize);
            LastBufferNumber:=(BufferNum+(ActualBufferSize div IOBlockSize)-1);
            BufferFound:=FindBuffer(LastBufferNumber,InsertIndex);
            if (InsertIndex > 0) then
               begin
               if BufferFound then
                  I:=InsertIndex
               else
                  I:=(InsertIndex-1);
               if (TBuffer(FBuffers[I]).Number < BufferNum) then
                  begin
                  while (BufferOffset >= 0) do
                     begin
                     GetNewBuffer(DefinitionPos,LastBufferNumber,
                                  InsertIndex,BufferToGet);
                     FBuffers.Insert(InsertIndex,BufferToGet);
                     BufferToGet.Read((FReadBuffer+BufferOffset));
                     Dec(BufferOffset,IOBlockSize);
                     Dec(LastBufferNumber);
                     end;
                  end
               else
                  begin
                  while (BufferOffset >= 0) and (I >= 0) do
                     begin
                     with TBuffer(FBuffers[I]) do
                        begin
                        if (Number < LastBufferNumber) then
                           begin
                           GetNewBuffer(DefinitionPos,LastBufferNumber,
                                        InsertIndex,BufferToGet);
                           FBuffers.Insert(InsertIndex,BufferToGet);
                           BufferToGet.Read((FReadBuffer+BufferOffset));
                           Dec(BufferOffset,IOBlockSize);
                           Dec(LastBufferNumber);
                           I:=(InsertIndex-1);
                           end
                        else if (Number=LastBufferNumber) then
                           begin
                           if (UseCount=0) and (not IsDirty) then
                              Read((FReadBuffer+BufferOffset));
                           Dec(BufferOffset,IOBlockSize);
                           InsertIndex:=I;
                           Dec(LastBufferNumber);
                           Dec(I);
                           end;
                        end;
                     end;
                  while (BufferOffset >= 0) do
                     begin
                     GetNewBuffer(DefinitionPos,LastBufferNumber,
                                  InsertIndex,BufferToGet);
                     FBuffers.Insert(InsertIndex,BufferToGet);
                     BufferToGet.Read((FReadBuffer+BufferOffset));
                     Dec(BufferOffset,IOBlockSize);
                     Dec(LastBufferNumber);
                     end;
                  end;
               end
            else
               begin
               if BufferFound then
                  begin
                  with TBuffer(FBuffers[InsertIndex]) do
                     begin
                     if (UseCount=0) and (not IsDirty) then
                        Read((FReadBuffer+BufferOffset));
                     end;
                  Dec(BufferOffset,IOBlockSize);
                  Dec(LastBufferNumber);
                  end;
               while (BufferOffset >= 0) do
                  begin
                  GetNewBuffer(DefinitionPos,LastBufferNumber,
                               InsertIndex,BufferToGet);
                  FBuffers.Insert(InsertIndex,BufferToGet);
                  BufferToGet.Read((FReadBuffer+BufferOffset));
                  Dec(BufferOffset,IOBlockSize);
                  Dec(LastBufferNumber);
                  end;
               end;
            end
         else
            begin
            BufferOffset:=0;
            LastBufferNumber:=BufferNum-(ActualBufferSize div IOBlockSize)+1;
            FindBuffer(LastBufferNumber,InsertIndex);
            if (InsertIndex < FBuffers.Count) then
               begin
               I:=InsertIndex;
               if (TBuffer(FBuffers[I]).Number > BufferNum) then
                  begin
                  while (BufferOffset < ActualBufferSize) do
                     begin
                     GetNewBuffer(DefinitionPos,LastBufferNumber,
                                  InsertIndex,BufferToGet);
                     FBuffers.Insert(InsertIndex,BufferToGet);
                     BufferToGet.Read((FReadBuffer+BufferOffset));
                     Inc(BufferOffset,IOBlockSize);
                     Inc(LastBufferNumber);
                     Inc(InsertIndex);
                     end;
                  end
               else
                  begin
                  while (BufferOffset < ActualBufferSize) and (I < FBuffers.Count) do
                     begin
                     with TBuffer(FBuffers[I]) do
                        begin
                        if (Number > LastBufferNumber) then
                           begin
                           GetNewBuffer(DefinitionPos,LastBufferNumber,
                                        InsertIndex,BufferToGet);
                           FBuffers.Insert(InsertIndex,BufferToGet);
                           BufferToGet.Read((FReadBuffer+BufferOffset));
                           Inc(BufferOffset,IOBlockSize);
                           Inc(LastBufferNumber);
                           Inc(InsertIndex);
                           I:=InsertIndex;
                           end
                        else if (Number=LastBufferNumber) then
                           begin
                           if (UseCount=0) and (not IsDirty) then
                              Read((FReadBuffer+BufferOffset));
                           Inc(BufferOffset,IOBlockSize);
                           Inc(LastBufferNumber);
                           Inc(I);
                           InsertIndex:=I;
                           end;
                        end;
                     end;
                  while (BufferOffset < ActualBufferSize) do
                     begin
                     GetNewBuffer(DefinitionPos,LastBufferNumber,
                                  InsertIndex,BufferToGet);
                     FBuffers.Insert(InsertIndex,BufferToGet);
                     BufferToGet.Read((FReadBuffer+BufferOffset));
                     Inc(BufferOffset,IOBlockSize);
                     Inc(LastBufferNumber);
                     Inc(InsertIndex);
                     end;
                  end;
               end
            else
               begin
               while (BufferOffset < ActualBufferSize) do
                  begin
                  GetNewBuffer(DefinitionPos,LastBufferNumber,
                               InsertIndex,BufferToGet);
                  FBuffers.Insert(InsertIndex,BufferToGet);
                  BufferToGet.Read((FReadBuffer+BufferOffset));
                  Inc(BufferOffset,IOBlockSize);
                  Inc(LastBufferNumber);
                  Inc(InsertIndex);
                  end;
               end;
            end;
      finally
         ResizeReadBuffer(0);
      end;
   finally
      FReadSize:=0;
      FReadFilePos:=0;
   end;
end;


function TBufferedFile.FlushBuffers(Internal: Boolean=False): Boolean;
var
   I: Integer;
   J: Integer;
   ChunkBufferSize: Integer;
   FirstBufferNumber: Integer;
   LastBufferNumber: Integer;
   FirstBufferPos: Integer;
   LastBufferPos: Integer;
   BufferOffset: Integer;
   FilePos: Int64;
begin
   Result:=False;
   FWriteBuffers.Count:=0;
   FWriteBuffers.Capacity:=FBuffers.Capacity;
   for I:=0 to FBuffers.Count-1 do
      begin
      with TBuffer(FBuffers[I]) do
         begin
         FilePos:=HeaderSize+(Int64(Number-1)*IOBlockSize);
         if IsDirty and (UseCount=0) and
            ((FilePos < FReadFilePos) or
             (FilePos >= (FReadFilePos+FReadSize))) then
            FWriteBuffers.Add(FBuffers[I])
         { Version 5 }
         else if (not Internal) then
            begin
            { Should never happen }
            if IsDirty and (UseCount > 0) then
               CorruptError;
            end;
         { Version 5 }
         end;
      end;
   if (FWriteBuffers.Count > 0) then
      begin
      try
         Result:=True;
         I:=0;
         while (I < FWriteBuffers.Count) do
            begin
            FirstBufferPos:=I;
            LastBufferPos:=I;
            FirstBufferNumber:=TBuffer(FWriteBuffers[I]).Number;
            LastBufferNumber:=FirstBufferNumber-1;
            FilePos:=HeaderSize+(Int64(FirstBufferNumber-1)*IOBlockSize);
            ChunkBufferSize:=0;
            while (I < FWriteBuffers.Count) do
               begin
               with TBuffer(FWriteBuffers[I]) do
                  begin
                  if (Number=(LastBufferNumber+1)) then
                     begin
                     Inc(ChunkBufferSize,IOBlockSize);
                     LastBufferNumber:=Number;
                     LastBufferPos:=I;
                     Inc(I);
                     end
                  else
                     Break;
                  end;
               end;
            ResizeWriteBuffer(ChunkBufferSize);
            BufferOffset:=0;
            for J:=FirstBufferPos to LastBufferPos do
               begin
               with TBuffer(FWriteBuffers[J]) do
                  begin
                  Write((FWriteBuffer+BufferOffset));
                  Inc(BufferOffset,IOBlockSize);
                  end;
               end;
            LockFile;
            try
               Seek(FilePos,FROM_BOF);
               Write(FWriteBuffer^,ChunkBufferSize);
               FDataTable.WrittenTo:=True;
            finally
               UnlockFile;
            end;
            Inc(FWrites);
            end;
      finally
         ResizeWriteBuffer(0);
      end;
      end;
end;

procedure TBufferedFile.FreeBuffers;
var
   I: Integer;
   TempBuffer: TBuffer;
begin
   for I:=(FBuffers.Count-1) downto 0 do
      begin
      TempBuffer:=TBuffer(FBuffers[I]);
      TempBuffer.Free;
      FBuffers.Delete(I);
      end;
   FFirstBuffer:=nil;
   FLastBuffer:=nil;
end;

procedure TBufferedFile.AdjustBuffers;
var
   NewCapacity: Integer;
begin
   NewCapacity:=CalculateCapacity;
   while (FBuffers.Count > NewCapacity) do
      begin
      if (not DeleteLastBuffer) then
         Break;
      end;
   FBuffers.Capacity:=MaximumInteger(FBuffers.Count,NewCapacity);
end;

procedure TBufferedFile.OpenFile;
begin
   if IsOpen then
      Exit;
   inherited OpenFile;
end;

procedure TBufferedFile.InitializeBuffers;
begin
   { Reset the cache statistics }
   FCacheHits:=0;
   FCacheMisses:=0;
   FReads:=0;
   FWrites:=0;
   FBuffers.Capacity:=CalculateCapacity;
   FReadAheadBuffers:=CalculateReadAhead;
end;

procedure TBufferedFile.CloseFile;
begin
   if (not IsOpen) then
      Exit;
   FreeBuffers;
   inherited CloseFile;
end;

procedure TBufferedFile.CreateFile;
begin
   inherited CreateFile;
end;

function TBufferedFile.GetFileSize: Int64;
begin
   Result:=HeaderSize+(Int64(IOBlocksUsed)*IOBlockSize);
end;

procedure TBufferedFile.ClearHeader;
var
   Buffer: array[1..1] of Char;
begin
   Seek(HeaderSize,FROM_BOF);
   Write(Buffer,0);
   if FDataTable.DataDirectory.DataSession.ForceBufferFlush then
      Flush;
   FDataTable.WrittenTo:=True;
end;

{ TDataPassword }

constructor TDataPassword.Create(Owner: TDataSession);
begin
   FDataSession:=Owner;
end;

destructor TDataPassword.Destroy;
begin
   if (FDataSize > 0) then
      begin
      DeAllocMem(FData);
      FDataSize:=0;
      end;
   inherited;
end;

procedure TDataPassword.Initialize(const Password: string);
begin
   FPassword:=Password;
   FDigest:=MD5String(Password);
   DataEngine.CryptoInit(Pointer(@FDigest),SizeOf(TMD5Digest),FData,FDataSize);
end;

function TDataPassword.CompareDigest(Value: TMD5Digest): Boolean;
var
   TempDigest: TMD5Digest;
begin
   TempDigest:=Value;
   DataEngine.Decrypt(FData,@TempDigest,SizeOf(TMD5Digest));
   Result:=MD5DigestCompare(FDigest,TempDigest);
end;

function TDataPassword.ComparePassword(const Value: string): Boolean;
begin
   Result:=(AnsiCompareStr(FPassword,Value)=0);
end;

procedure TDataPassword.Copy(Value: TDataPassword);
begin
   FPassword:=Value.FPassword;
   FDigest:=Value.FDigest;
   FData:=Value.FData;
end;

{ TPingThread }

constructor TPingThread.Create(Owner: TDataSession);
begin
   inherited Create(True);
   FEvent:=OSAllocEvent;
   FDataSession:=Owner;
   Priority:=tpLower;
   Resume;
end;

destructor TPingThread.Destroy;
begin
   OSDeAllocEvent(FEvent);
   inherited;
end;

procedure TPingThread.Ping;
begin
   OSSetEvent(FEvent);
end;

procedure TPingThread.Execute;
var
   WaitResult: Integer;
   Reconnected: Boolean;
begin
   while (not Terminated) do
      begin
      WaitResult:=OSWaitForEvent(FEvent,LongWord($FFFFFFFF));
      OSResetEvent(FEvent);
      case WaitResult of
         SIGNALLED:
            begin
            if (not Terminated) then
               begin
               with FDataSession do
                  begin
                  StartRemoteRequest;
                  try
                     try
                        CheckForConnection;
                        SetRequestCode(REQUEST_PING);
                        BeginPack;
                        EndPack;
                        Reconnected:=False;
                        while True do
                           begin
                           try
                              Send;
                              Break;
                           except
                              if (not Reconnected) then
                                 begin
                                 HandleReconnect;
                                 Reconnected:=True;
                                 end;
                           end;
                           end;
                     except
                        { Kill all exceptions during pinging }
                     end;
                  finally
                     EndRemoteRequest;
                     Pinging:=False;
                  end;
                  end;
               end;
            end;
         ABANDONED,FAILED:
            Terminate;
         end;
      end;
end;

{ TDataSocket }

function TDataSocket.WaitForData(Timeout: Integer): Boolean;
var
   FDSet: TFDSet;
   TimeVal: TTimeVal;
begin
   TimeVal.tv_sec:=(Timeout div 1000);
   TimeVal.tv_usec:=((Timeout mod 1000)*1000);
   FD_ZERO(FDSet);
   FD_SET(Socket.SocketHandle,FDSet);
   Result:=(select(0,@FDSet,nil,nil,@TimeVal) > 0);
end;

{ TDataSession }

constructor TDataSession.Create(Owner: TDataEngine);
begin
   FDataEngine:=Owner;
   FDataDirectoryList:=TList.Create;
   FPasswordStack:=TList.Create;
   FPasswordList:=TList.Create;
   FLockRetries:=DEFAULT_RECORD_LOCK_RETRIES;
   FLockWait:=DEFAULT_RECORD_LOCK_WAIT;
   FLockProtocol:=LOCK_PESSIMISTIC;
   FProgress:=DEFAULT_PROGRESS_STEPS;
   FPrivateDirectory:=OSGetTempDirectory;
   FSessionLock:=OSAllocCriticalSection;
   OSInitializeCriticalSection(FSessionLock);
   FPingTimer:=TThreadTimer.Create;
   FIsEncrypted:=False;
   FEncryptPassword:=DEFAULT_ENCRYPT_PASSWORD;
   FCompression:=NO_COMPRESSION;
   FTimeOut:=DEFAULT_TIMEOUT;
   FAddress:=DEFAULT_ADDRESS;
   FPort:=DEFAULT_PORT;
end;

destructor TDataSession.Destroy;
begin
   { Destroy any server-side procedure objects }
   if (FCallbackSessionObject <> nil) then
      begin
      FCallbackSessionObject.Free;
      FCallbackSessionObject:=nil;
      end;
   if FIsRemote then
      begin
      Disconnect;
      ResizeReceiveBuffer(0);
      ResizeSendBuffer(0);
      end
   else
      begin
      DeleteAllPasswords;
      FreeAllPasswords;
      end;
   FPingTimer.Free;
   OSDeleteCriticalSection(FSessionLock);
   OSDeAllocCriticalSection(FSessionLock);
   FreeDataDirectories;
   FPasswordList.Free;
   FPasswordStack.Free;
   FDataDirectoryList.Free;
   FreeEncryptData;
   inherited Destroy;
end;

procedure TDataSession.FreeEncryptData;
begin
   if (FEncryptDataSize > 0) then
      begin
      DeAllocMem(FEncryptData);
      FEncryptDataSize:=0;
      end;
end;

procedure TDataSession.ResizeSendBuffer(Value: Integer; ShrinkBuffer: Boolean=False);
begin
   ResizeBuffer(Value,FSendBuffer,FSendBufferSize,ShrinkBuffer);
end;

procedure TDataSession.ResizeReceiveBuffer(Value: Integer; ShrinkBuffer: Boolean=False);
begin
   ResizeBuffer(Value,FReceiveBuffer,FReceiveBufferSize);
end;

function TDataSession.GetSendBuffer: PChar;
begin
   Result:=FSendBuffer;
end;

function TDataSession.GetReceiveBuffer: PChar;
begin
   Result:=FReceiveBuffer;
end;

procedure TDataSession.BeginPack;
begin
   FPackPos:=SizeOf(TRequestHeader);
   ResizeSendBuffer(FPackPos);
   FRequestHeader.RequestParamSize:=0;
end;

procedure TDataSession.Pack(const Buffer; BufferSize: Integer);
begin
   ResizeSendBuffer(FPackPos+SizeOf(Integer)+BufferSize);
   Move(BufferSize,(FSendBuffer+FPackPos)^,SizeOf(Integer));
   Inc(FPackPos,SizeOf(Integer));
   Inc(FRequestHeader.RequestParamSize,SizeOf(Integer));
   Move(Buffer,(FSendBuffer+FPackPos)^,BufferSize);
   Inc(FPackPos,BufferSize);
   Inc(FRequestHeader.RequestParamSize,BufferSize);
end;

procedure TDataSession.EndPack;
var
   TempCompressedBuffer: PChar;
   TempCompressedBytes: Integer;
   TempCompression: Byte;
begin
   { Massage the compression for size optimizations }
   if (FRemoteEngineVersion >= 4.11) and
      (FCompression <> NO_COMPRESSION) then
      begin
      if (FRequestHeader.RequestParamSize <= MIN_COMPRESS_SIZE) then
         TempCompression:=NO_COMPRESSION
      else if (FRequestHeader.RequestParamSize <= FAST_COMPRESS_SIZE) then
         TempCompression:=BEST_SPEED_COMPRESSION
      else
         TempCompression:=FCompression;
      end
   else
      TempCompression:=FCompression;
   { If no compression is set then just send as is }
   if (TempCompression=NO_COMPRESSION) then
      begin
      with FRequestHeader do
         begin
         RequestSignature:=DataEngine.SignatureDigest;
         if (TempCompression <> FCompression) then
            RequestCompression:=((FCompression*TEMP_COMPRESSION_OFFSET)+TempCompression)
         else
            RequestCompression:=TempCompression;
         TotalRequestSize:=BlockOffset(SizeOf(TRequestHeader)+RequestParamSize,CRYPTO_BLOCK_SIZE);
         end;
      Move(FRequestHeader,FSendBuffer^,SizeOf(TRequestHeader));
      end
   else
      begin
      TempCompressedBuffer:=nil;
      TempCompressedBytes:=0;
      DataEngine.Compress(Pointer(FSendBuffer+SizeOf(TRequestHeader)),FRequestHeader.RequestParamSize,
                          TempCompression,Pointer(TempCompressedBuffer),TempCompressedBytes);
      try
         with FRequestHeader do
            begin
            RequestSignature:=DataEngine.SignatureDigest;
            if (TempCompression <> FCompression) then
               RequestCompression:=((FCompression*TEMP_COMPRESSION_OFFSET)+TempCompression)
            else
               RequestCompression:=TempCompression;
            RequestParamSize:=TempCompressedBytes;
            TotalRequestSize:=BlockOffset(SizeOf(TRequestHeader)+RequestParamSize,CRYPTO_BLOCK_SIZE);
            end;
         ResizeSendBuffer(FRequestHeader.TotalRequestSize);
         Move(FRequestHeader,FSendBuffer^,SizeOf(TRequestHeader));
         Move(TempCompressedBuffer^,(FSendBuffer+SizeOf(TRequestHeader))^,
              TempCompressedBytes);
      finally
         DeAllocMem(TempCompressedBuffer);
      end;
      end;
   if (not FInitializingConnection) and FIsEncrypted then
      DataEngine.Encrypt(FEncryptData,(FSendBuffer+SizeOf(TMD5Digest)+SizeOf(Integer)),
                         (FRequestHeader.TotalRequestSize-(SizeOf(TMD5Digest)+SizeOf(Integer))));
end;

procedure TDataSession.BeginUnpack;
var
   TempDecompressedBuffer: PChar;
   TempDecompressedBytes: Integer;
   TempCompression: Byte;
begin
   FUnpackPos:=0;
   if (not FInitializingConnection) and FIsEncrypted then
      DataEngine.Decrypt(FEncryptData,(FReceiveBuffer+SizeOf(TMD5Digest)+SizeOf(Integer)),
                         (pReplyHeader(FReceiveBuffer)^.TotalReplySize-(SizeOf(TMD5Digest)+SizeOf(Integer))));
   Move(FReceiveBuffer^,FReplyHeader,SizeOf(TReplyHeader));
   Inc(FUnpackPos,SizeOf(TReplyHeader));
   { Check for temporary compression settings }
   if (FReplyHeader.ReplyCompression > BEST_COMPRESSION) then
      TempCompression:=(FReplyHeader.ReplyCompression mod TEMP_COMPRESSION_OFFSET)
   else
      TempCompression:=FReplyHeader.ReplyCompression;
   { If compressed reply then need to uncompress data }
   if (TempCompression <> NO_COMPRESSION) then
      begin
      TempDecompressedBuffer:=nil;
      TempDecompressedBytes:=0;
      DataEngine.Decompress(Pointer(FReceiveBuffer+SizeOf(TReplyHeader)),FReplyHeader.ResultSize,
                            Pointer(TempDecompressedBuffer),TempDecompressedBytes);
      try
         with FReplyHeader do
            begin
            TotalReplySize:=(SizeOf(TReplyHeader)+TempDecompressedBytes);
            ResultSize:=TempDecompressedBytes;
            end;
         ResizeReceiveBuffer(SizeOf(TReplyHeader)+TempDecompressedBytes);
         Move(FReplyHeader,FReceiveBuffer^,SizeOf(TReplyHeader));
         Move(TempDecompressedBuffer^,(FReceiveBuffer+SizeOf(TReplyHeader))^,
              TempDecompressedBytes);
      finally
         DeAllocMem(TempDecompressedBuffer);
      end;
      end
   else
      begin
      { Otherwise just adjust the total reply size to account for slack
        space introduced by the crypto blocking }
      with FReplyHeader do
         TotalReplySize:=(SizeOf(TReplyHeader)+ResultSize);
      Move(FReplyHeader,FReceiveBuffer^,SizeOf(TReplyHeader));
      end;
end;

function TDataSession.Unpack(var Buffer): Integer;
begin
   if ((FUnpackPos+SizeOf(Integer)) > FReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FReceiveBuffer+FUnpackPos)^,Result,SizeOf(Integer));
   Inc(FUnpackPos,SizeOf(Integer));
   if ((FUnpackPos+Result) > FReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FReceiveBuffer+FUnpackPos)^,Buffer,Result);
   Inc(FUnpackPos,Result);
end;

function TDataSession.SkipUnpack: Integer;
begin
   if ((FUnpackPos+SizeOf(Integer)) > FReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FReceiveBuffer+FUnpackPos)^,Result,SizeOf(Integer));
   Inc(FUnpackPos,SizeOf(Integer));
   if ((FUnpackPos+Result) > FReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Inc(FUnpackPos,Result);
end;

function TDataSession.RemainingReplySize: Integer;
begin
   Result:=(FReplyHeader.TotalReplySize-FUnpackPos);
end;

procedure TDataSession.UnpackException;
var
   TempUserName: string;
   TempDatabaseName: string;
   TempTableName: string;
   TempFieldName: string;
   TempIndexName: string;
   TempMessage: string;
   TempProcedureName: string;
   TempEventName: string;
   TempLine: Integer;
   TempColumn: Integer;
begin
   TempUserName[0]:=Char(Byte(Unpack(TempUserName[1])));
   TempDatabaseName[0]:=Char(Byte(Unpack(TempDatabaseName[1])));
   TempTableName[0]:=Char(Byte(Unpack(TempTableName[1])));
   TempFieldName[0]:=Char(Byte(Unpack(TempFieldName[1])));
   TempIndexName[0]:=Char(Byte(Unpack(TempIndexName[1])));
   TempMessage[0]:=Char(Byte(Unpack(TempMessage[1])));
   TempProcedureName[0]:=Char(Byte(Unpack(TempProcedureName[1])));
   TempEventName[0]:=Char(Byte(Unpack(TempEventName[1])));
   if (FRemoteEngineVersion >= 4.09) then
      begin
      Unpack(TempLine);
      Unpack(TempColumn);
      end
   else
      begin
      TempLine:=0;
      TempColumn:=0;
      end;
   DataEngine.RaiseError(GetResultCode,GetRemoteLocation,TempUserName,TempDatabaseName,
                         TempTableName,TempFieldName,TempIndexName,TempMessage,
                         TempProcedureName,TempEventName,TempLine,TempColumn);
end;

procedure TDataSession.CheckForException;
begin
   if (GetResultCode <> DBISAM_NONE) then
      UnpackException;
end;

procedure TDataSession.CheckForConnection;
begin
   if (not FConnected) then
      HandleReconnect;
end;

procedure TDataSession.FreeDataDirectories;
var
   I: Integer;
begin
   I:=0;
   while (I < FDataDirectoryList.Count) do
      begin
      TDataDirectory(FDataDirectoryList[I]).Free;
      FDataDirectoryList.Delete(I);
      end;
end;

function TDataSession.GetHasOpenDirectories: Boolean;
begin
   Result:=(FDataDirectoryList.Count > 0);
end;

function TDataSession.GetPrivateDirectory: string;
begin
   if (FPrivateDirectory='') then
      Result:=AddBS(Trim(OSGetCurrentDirectory))
   else
      Result:=FPrivateDirectory;
end;

procedure TDataSession.SetPrivateDirectory(const Value: string);
begin
   if (Value='') then
      FPrivateDirectory:=Value
   else
      begin
      if (AddBS(Trim(Value)) <> FPrivateDirectory) then
         FPrivateDirectory:=AddBS(Trim(Value));
      end;
end;

function TDataSession.GetProgressPercent: Word;
begin
   if (FProgress > 0) then
      Result:=(MAX_PROGRESS_STEPS div FProgress)
   else
      Result:=100;
end;

procedure TDataSession.SetProgress(Value: Word);
begin
   if (Value <> FProgress) then
      begin
      FProgress:=Value;
      if FIsRemote and FLoggedIn then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetForceBufferFlush(Value: Boolean);
begin
   if (Value <> FForceBufferFlush) then
      begin
      FForceBufferFlush:=Value;
      if FIsRemote and FLoggedIn then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetStrictChangeDetection(Value: Boolean);
begin
   if (Value <> FStrictChangeDetection) then
      begin
      FStrictChangeDetection:=Value;
      if FIsRemote and FLoggedIn then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetLockRetries(Value: Byte);
begin
   if (Value <> FLockRetries) then
      begin
      FLockRetries:=Value;
      if FIsRemote and FLoggedIn then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetLockWait(Value: Word);
begin
   if (Value <> FLockWait) then
      begin
      FLockWait:=Value;
      if FIsRemote and FLoggedIn  then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetLockProtocol(Value: Byte);
begin
   if (Value <> FLockProtocol) then
      begin
      FLockProtocol:=Value;
      if FIsRemote and FLoggedIn then
         SetSessionParams;
      end;
end;

procedure TDataSession.SetIsRemote(Value: Boolean);
begin
   if (Value <> FIsRemote) then
      begin
      if (not FConnected) then
         FIsRemote:=Value;
      end;
end;

procedure TDataSession.SetIsEncrypted(Value: Boolean);
begin
   if (Value <> FIsEncrypted) then
      begin
      if (not FConnected) then
         FIsEncrypted:=Value;
      end;
end;

procedure TDataSession.SetEncryptPassword(const Value: string);
begin
   if (Value <> FEncryptPassword) then
      begin
      if (not FConnected) then
         FEncryptPassword:=Value;
      end;
end;

function TDataSession.GetStackPassword(const Value: string): TDataPassword;
var
   I: Integer;
begin
   Result:=nil;
   for I:=0 to FPasswordStack.Count-1 do
      begin
      with TDataPassword(FPasswordStack[I]) do
         begin
         if ComparePassword(Value) then
            begin
            Result:=FPasswordStack[I];
            FPasswordStack.Delete(I);
            Break;
            end;
         end;
      end;
end;

procedure TDataSession.FreeAllPasswords;
var
   I: Integer;
begin
   for I:=FPasswordStack.Count-1 downto 0 do
      begin
      TDataPassword(FPasswordStack[I]).Free;
      FPasswordStack.Delete(I);
      end;
end;

procedure TDataSession.AddPassword(const Value: string);
var
   NewPassword: TDataPassword;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDPASSWORD);
         BeginPack;
         Pack(Value[1],Length(Value));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      if (Value <> '') and (not CheckForPassword(Value)) then
         begin
         NewPassword:=GetStackPassword(Value);
         if (NewPassword <> nil) then
            FPasswordList.Add(NewPassword)
         else
            begin
            NewPassword:=TDataPassword.Create(Self);
            try
               NewPassword.Initialize(Value);
            except
               NewPassword.Free;
               raise;
            end;
            FPasswordList.Add(NewPassword);
            end;
         end;
      end;
end;

procedure TDataSession.DeletePassword(const Value: string);
var
   I: Integer;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELPASSWORD);
         BeginPack;
         Pack(Value[1],Length(Value));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      for I:=0 to FPasswordList.Count-1 do
         begin
         with TDataPassword(FPasswordList[I]) do
            begin
            if ComparePassword(Value) then
               begin
               FPasswordStack.Add(FPasswordList[I]);
               FPasswordList.Delete(I);
               Break;
               end;
            end;
         end;
      end;
end;

procedure TDataSession.DeleteAllPasswords;
var
   I: Integer;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELALLPASSWORDS);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      for I:=FPasswordList.Count-1 downto 0 do
         begin
         FPasswordStack.Add(FPasswordList[I]);
         FPasswordList.Delete(I);
         end;
      end;
end;

function TDataSession.CheckForDigest(Value: TMD5Digest): TDataPassword;
var
   I: Integer;
begin
   Result:=nil;
   for I:=0 to FPasswordList.Count-1 do
      begin
      with TDataPassword(FPasswordList[I]) do
         begin
         if CompareDigest(Value) then
            begin
            Result:=TDataPassword(FPasswordList[I]);
            Break;
            end;
         end;
      end;
end;

function TDataSession.CheckForPassword(const Value: string): Boolean;
var
   I: Integer;
begin
   Result:=False;
   for I:=0 to FPasswordList.Count-1 do
      begin
      with TDataPassword(FPasswordList[I]) do
         begin
         if ComparePassword(Value) then
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
end;

function TDataSession.GetDataPassword(const Value: string): TDataPassword;
var
   I: Integer;
begin
   Result:=nil;
   for I:=0 to FPasswordList.Count-1 do
      begin
      with TDataPassword(FPasswordList[I]) do
         begin
         if ComparePassword(Value) then
            begin
            Result:=FPasswordList[I];
            Break;
            end;
         end;
      end;
end;

{ Version 5 }
function TDataSession.OpenDataDirectory(const DataDirectoryName: string;
                                        const DataDirectoryPath: string;
                                        KeepSharedTablesOpen: Boolean;
                                        NoRemoteCall: Boolean;
                                        CompareNames: Boolean=False): TDataDirectory;
{ Version 5 }
var
   I: Integer;
   TempDir: string;
begin
   if FIsRemote then
      begin
      if (not NoRemoteCall) then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_OPENDATADIR);
            BeginPack;
            Pack(DataDirectoryName[1],Length(DataDirectoryName));
            if (RemoteEngineVersion >= 4.17) then
               Pack(KeepSharedTablesOpen,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            for I:=0 to FDataDirectoryList.Count-1 do
               begin
               if (AnsiCompareText(Trim(TDataDirectory(FDataDirectoryList[I]).Name),
                                   Trim(DataDirectoryName))=0) then
                  begin
                  Result:=TDataDirectory(FDataDirectoryList[I]);
                  Result.IncUseCount;
                  Exit;
                  end;
               end;
            Result:=TDataDirectory.Create(Self,DataDirectoryName,'');
            FDataDirectoryList.Add(Result);
            with Result do
               begin
               Unpack(FRemoteID);
               Unpack(FReadOnly);
               IncUseCount;
               KeepTablesOpen:=KeepSharedTablesOpen;
               end;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         for I:=0 to FDataDirectoryList.Count-1 do
            begin
            if (AnsiCompareText(Trim(TDataDirectory(FDataDirectoryList[I]).Name),
                                Trim(DataDirectoryName))=0) then
               begin
               Result:=TDataDirectory(FDataDirectoryList[I]);
               Result.IncUseCount;
               Exit;
               end;
            end;
         Result:=TDataDirectory.Create(Self,DataDirectoryName,'');
         FDataDirectoryList.Add(Result);
         Result.IncUseCount;
         Result.KeepTablesOpen:=KeepSharedTablesOpen;
         end;
      end
   else
      begin
      if (AnsiCompareText(DataDirectoryName,INMEMORY_DATABASE_NAME) <> 0) then
         begin
         if (DataDirectoryPath='') then
            TempDir:=AddBS(Trim(OSGetCurrentDirectory))
         else
            TempDir:=AddBS(Trim(DataDirectoryPath));
         end
      else
         begin
         if (DataDirectoryPath <> '') then
            TempDir:=AddBS(Trim(DataDirectoryPath))
         else
            TempDir:='';
         end;
      for I:=0 to FDataDirectoryList.Count-1 do
         begin
         if (OSCompareFileNames(Trim(TDataDirectory(FDataDirectoryList[I]).Directory),
                                Trim(TempDir))=0) then
            begin
            { Version 5 }
            if (not CompareNames) or
               (CompareNames and (AnsiCompareText(Trim(TDataDirectory(FDataDirectoryList[I]).Name),
                                                  Trim(DataDirectoryName))=0)) then
            { Version 5 }
               begin
               Result:=TDataDirectory(FDataDirectoryList[I]);
               Result.IncUseCount;
               Exit;
               end;
            end;
         end;
      Result:=TDataDirectory.Create(Self,DataDirectoryName,TempDir);
      FDataDirectoryList.Add(Result);
      Result.IncUseCount;
      Result.KeepTablesOpen:=KeepSharedTablesOpen;
      end;
end;

procedure TDataSession.CloseDataDirectory(ExistingDataDirectory: TDataDirectory;
                                          NoRemoteCall: Boolean);
var
   TempPos: Integer;
begin
   TempPos:=FDataDirectoryList.IndexOf(ExistingDataDirectory);
   if (TempPos <> -1) then
      begin
      with ExistingDataDirectory do
         begin
         if (UseCount > 0) then
            begin
            DecUseCount;
            if (UseCount=0) then
               begin
               if FIsRemote and (not NoRemoteCall) then
                  begin
                  try
                     StartRemoteRequest;
                     try
                        CheckForConnection;
                        SetRequestCode(REQUEST_CLOSEDATADIR);
                        BeginPack;
                        Pack(FRemoteID,SizeOf(Integer));
                        EndPack;
                        SendReceive;
                        CheckForException;
                     finally
                        EndRemoteRequest;
                     end;
                  except
                  end;
                  end;
               Free;
               FDataDirectoryList.Delete(TempPos);
               end;
            end;
         end;
      end;
end;

function TDataSession.GetRemoteLocation: string;
begin
   Result:='';
   if (FHost <> '') then
      Result:=FHost
   else if (FAddress <> '') then
      Result:=FAddress;
end;

procedure SocketError(ErrorCode: Integer);
begin
   DataEngine.FSocketErrorNumber:=ErrorCode;
   raise ESocketError.Create('Socket Error');
end;

procedure TDataSession.Connect;
var
   BeginTicks: LongWord;
   EndTicks: LongWord;
   TempTraceRecord: TDataTraceRecord;
begin
   if FConnected then
      Exit;
   try
      FReconnectStopAsking:=False;
      BeginTicks:=OSGetTickCount;
      FRemoteID:=0;
      FSocket:=TDataSocket.Create(nil);
      FOldErrorProc:=SetErrorProc(SocketError);
      with FSocket do
         begin
         ClientType:=ctBlocking;
         Port:=Self.FPort;
         Host:=Self.FHost;
         Address:=Self.FAddress;
         Service:=Self.FService;
         Open;
         end;
      FConnected:=True;
      EndTicks:=OSGetTickCount;
      if FTracing then
         begin
         with TempTraceRecord do
            begin
            DateTime:=Now;
            EventType:=TRACE_TYPE_CONNECT;
            ElapsedTime:=OSCalcElapsedTime(BeginTicks,EndTicks);
            RemoteEncryption:=FIsEncrypted;
            RemoteCompression:=FCompression;
            RemoteHost:=FHost;
            RemoteAddress:=FAddress;
            RemotePort:=FPort;
            RemoteService:=FService;
            RemoteUser:=FUserName;
            RemoteRequestID:=0;
            RemoteRequestName:='';
            RemoteRequestSize:=0;
            RemoteReplyResultID:=0;
            RemoteReplyResultName:='';
            RemoteReplySize:=0;
            end;
         DoTrace(TempTraceRecord);
         end;
      FreeEncryptData;
      FEncryptDigest:=MD5String(FEncryptPassword);
      DataEngine.CryptoInit(Pointer(@FEncryptDigest),SizeOf(TMD5Digest),
                            FEncryptData,FEncryptDataSize);
   except
      Disconnect;
      DataEngine.RaiseError(DBISAM_REMOTECONNECT,GetRemoteLocation);
   end;
   FInitializingConnection:=True;
   try
      SetConnectionParams;
   finally
      FInitializingConnection:=False;
   end;
end;

function TDataSession.CheckReconnect(var Continue: Boolean;
                                     var StopAsking: Boolean): Boolean;
begin
   Result:=False;
   if Assigned(FReconnectCallback) then
      begin
      FReconnectCallback(FReconnectClientData,Continue,StopAsking);
      Result:=True;
      end;
end;

procedure TDataSession.HandleReconnect;
var
   TempContinue: Boolean;
begin
   if (not FReconnectStopAsking) then
      begin
      TempContinue:=True;
      if CheckReconnect(TempContinue,FReconnectStopAsking) then
         begin
         if TempContinue then
            begin
            FReconnectStopAsking:=False;
            Reconnect;
            end
         else
            Abort;
         end
      else
         Reconnect;
      end
   else
      Abort;
end;

procedure TDataSession.Reconnect;
var
   BeginTicks: LongWord;
   EndTicks: LongWord;
   TempTraceRecord: TDataTraceRecord;
begin
   if FConnected then
      Exit;
   try
      BeginTicks:=OSGetTickCount;
      FSocket:=TDataSocket.Create(nil);
      with FSocket do
         begin
         ClientType:=ctBlocking;
         Port:=Self.FPort;
         Host:=Self.FHost;
         Address:=Self.FAddress;
         Service:=Self.FService;
         Open;
         end;
      FConnected:=True;
      EndTicks:=OSGetTickCount;
      if FTracing then
         begin
         with TempTraceRecord do
            begin
            DateTime:=Now;
            EventType:=TRACE_TYPE_RECONNECT;
            ElapsedTime:=OSCalcElapsedTime(BeginTicks,EndTicks);
            RemoteEncryption:=FIsEncrypted;
            RemoteCompression:=FCompression;
            RemoteHost:=FHost;
            RemoteAddress:=FAddress;
            RemotePort:=FPort;
            RemoteService:=FService;
            RemoteUser:=FUserName;
            RemoteRequestID:=0;
            RemoteRequestName:='';
            RemoteRequestSize:=0;
            RemoteReplyResultID:=0;
            RemoteReplyResultName:='';
            RemoteReplySize:=0;
            end;
         DoTrace(TempTraceRecord);
         end;
   except
      Disconnect;
      DataEngine.RaiseError(DBISAM_REMOTECONNECT,GetRemoteLocation);
   end;
   FInitializingConnection:=True;
   try
      SetReconnectionParams;
   finally
      FInitializingConnection:=False;
   end;
end;

procedure TDataSession.Disconnect;
var
   BeginTicks: LongWord;
   EndTicks: LongWord;
   TempTraceRecord: TDataTraceRecord;
begin
   if FConnected then
      begin
      BeginTicks:=OSGetTickCount;
      SetErrorProc(FOldErrorProc);
      FSocket.Close;
      EndTicks:=OSGetTickCount;
      if FTracing then
         begin
         with TempTraceRecord do
            begin
            DateTime:=Now;
            EventType:=TRACE_TYPE_DISCONNECT;
            ElapsedTime:=OSCalcElapsedTime(BeginTicks,EndTicks);
            RemoteEncryption:=FIsEncrypted;
            RemoteCompression:=FCompression;
            RemoteHost:=FHost;
            RemoteAddress:=FAddress;
            RemotePort:=FPort;
            RemoteService:=FService;
            RemoteUser:=FUserName;
            RemoteRequestID:=0;
            RemoteRequestName:='';
            RemoteRequestSize:=0;
            RemoteReplyResultID:=0;
            RemoteReplyResultName:='';
            RemoteReplySize:=0;
            end;
         DoTrace(TempTraceRecord);
         end;
      FConnected:=False;
      end;
   if (FSocket <> nil) then
      begin
      FSocket.Free;
      FSocket:=nil;
      end;
end;

procedure TDataSession.SetConnectionParams;
var
   TempEngineVersion: Currency;
   TempEngineType: string;
   TempComputerName: string;
   TempCallbackType: Word;
begin
   StartRemoteRequest;
   try
      CheckForConnection;
      SetRequestCode(REQUEST_CONNECTPARAMS);
      BeginPack;
      TempEngineVersion:=ENGINE_VERSION_NUM;
      Pack(TempEngineVersion,SizeOf(Currency));
      Pack(FIsEncrypted,SizeOf(Boolean));
      TempComputerName:=OSGetComputerName+IntToStr(OSGetProcessID);
      Pack(TempComputerName[1],Length(TempComputerName));
      Pack(OSGetThreadID,SizeOf(Integer));
      EndPack;
      Send;
      Receive(TempCallbackType);
      if (GetResultCode <> DBISAM_NONE) then
         begin
         Disconnect;
         DataEngine.RaiseError(GetResultCode,GetRemoteLocation);
         end
      else
         begin
         Unpack(FRemoteID);
         Unpack(FRemoteEngineVersion);
         { Version 5 }
         if (RemoteEngineVersion >= 4.23) then
            Unpack(FRemoteEngineBuildNumber)
         else
            FRemoteEngineBuildNumber:=0;
         { Version 5 }
         TempEngineType[0]:=Char(Byte(Unpack(TempEngineType[1])));
         end;
   finally
      EndRemoteRequest;
   end;
end;

procedure TDataSession.SetReconnectionParams;
var
   TempEngineVersion: Currency;
   TempComputerName: string;
   TempCallbackType: Word;
   SaveBuffer: PChar;
   SaveHeader: TRequestHeader;
begin
   CheckForConnection;
   SaveBuffer:=AllocMem(FSendBufferSize);
   try
      Move(FSendBuffer^,SaveBuffer^,FSendBufferSize);
      Move(FRequestHeader,SaveHeader,SizeOf(TRequestHeader));
      SetRequestCode(REQUEST_RECONNECT);
      BeginPack;
      TempEngineVersion:=ENGINE_VERSION_NUM;
      Pack(TempEngineVersion,SizeOf(Currency));
      Pack(FRemoteID,SizeOf(Integer));
      Pack(FIsEncrypted,SizeOf(Boolean));
      TempComputerName:=OSGetComputerName+IntToStr(OSGetProcessID);
      Pack(TempComputerName[1],Length(TempComputerName));
      Pack(OSGetThreadID,SizeOf(Integer));
      EndPack;
      Send;
      Receive(TempCallbackType);
      Move(SaveBuffer^,FSendBuffer^,FSendBufferSize);
      Move(SaveHeader,FRequestHeader,SizeOf(TRequestHeader));
      if (GetResultCode <> DBISAM_NONE) then
         begin
         Disconnect;
         DataEngine.RaiseError(GetResultCode,GetRemoteLocation);
         end;
   finally
      DeAllocMem(SaveBuffer);
   end;
end;

procedure TDataSession.Login;
var
   LoginAttempts: Byte;
   LoginInfoSet: Boolean;
   TempLoginSize: Integer;
   TempLoginBuffer: PChar;
   TempLoginPos: Integer;
   TempCallbackType: Word;
begin
   LoginAttempts:=0;
   LoginInfoSet:=((FUserName <> '') and (FPassword <> ''));
   while True do
      begin
      if LoginInfoSet or DoLogin then
         begin
         SetRequestCode(REQUEST_LOGIN);
         BeginPack;
         TempLoginSize:=BlockOffset((Length(FUserName)+1+Length(FPassword)+1),
                                    CRYPTO_BLOCK_SIZE);
         TempLoginBuffer:=AllocMem(TempLoginSize);
         try
            TempLoginPos:=0;
            Move(FUserName[0],(TempLoginBuffer+TempLoginPos)^,SizeOf(Byte));
            Inc(TempLoginPos,SizeOf(Byte));
            Move(FUserName[1],(TempLoginBuffer+TempLoginPos)^,Length(FUserName));
            Inc(TempLoginPos,Length(FUserName));
            Move(FPassword[0],(TempLoginBuffer+TempLoginPos)^,SizeOf(Byte));
            Inc(TempLoginPos,SizeOf(Byte));
            Move(FPassword[1],(TempLoginBuffer+TempLoginPos)^,Length(FPassword));
            DataEngine.Encrypt(FEncryptData,TempLoginBuffer,TempLoginSize);
            Pack(TempLoginSize,SizeOf(Integer));
            Pack(TempLoginBuffer^,TempLoginSize);
         finally
            DeAllocMem(TempLoginBuffer);
         end;
         EndPack;
         Send;
         Receive(TempCallbackType);
         if (GetResultCode=DBISAM_NONE) then
            begin
            FLoggedIn:=True;
            StartPinging;
            Break;
            end
         else if (GetResultCode <> DBISAM_REMOTEINVLOGIN) then
            begin
            Disconnect;
            DataEngine.RaiseError(GetResultCode,GetRemoteLocation,FUserName);
            end;
         FUserName:='';
         FPassword:='';
         LoginInfoSet:=False;
         Inc(LoginAttempts);
         if (LoginAttempts >= MAX_LOGIN_ATTEMPTS) then
            begin
            Disconnect;
            DataEngine.RaiseError(DBISAM_REMOTEINVLOGIN,GetRemoteLocation,FUserName);
            end;
         end
      else
         begin
         Disconnect;
         DataEngine.RaiseError(DBISAM_REMOTEINVLOGIN,GetRemoteLocation,FUserName);
         end;
      end;
end;

procedure TDataSession.Logout;
var
   Reconnected: Boolean;
begin
   if FLoggedIn then
      begin
      StopPinging;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_LOGOUT);
         BeginPack;
         EndPack;
         Reconnected:=False;
         while True do
            begin
            try
               Send;
               FLoggedIn:=False;
               Break;
            except
               if (not Reconnected) then
                  begin
                  HandleReconnect;
                  Reconnected:=True;
                  end;
            end;
            end;
         Disconnect;
      except
         { Kill all exceptions during logout }
      end;
      end;
end;

procedure TDataSession.SetSessionParams;
begin
   StartRemoteRequest;
   try
      SetRequestCode(REQUEST_SESSIONPARAMS);
      BeginPack;
      Pack(FForceBufferFlush,SizeOf(Boolean));
      Pack(FStrictChangeDetection,SizeOf(Boolean));
      Pack(FLockRetries,SizeOf(Byte));
      Pack(FLockWait,SizeOf(Word));
      Pack(FLockProtocol,SizeOf(Byte));
      Pack(FProgress,SizeOf(Word));
      EndPack;
      SendReceive;
      CheckForException;
   finally
      EndRemoteRequest;
   end;
end;

{ Version 5 }
procedure TDataSession.RemoveAllRemoteMemoryTables;
var
   TempComputerName: string;
begin
   if (RemoteEngineVersion >= 4.20) then
      begin
      StartRemoteRequest;
      try
         SetRequestCode(REQUEST_DELALLMEMTABLES);
         BeginPack;
         TempComputerName:=OSGetComputerName;
         Pack(TempComputerName[1],Length(TempComputerName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;
{ Version 5 }

procedure TDataSession.CheckCallbacks(NewClientData: Integer);
var
   I: Integer;
begin
   if Assigned(FLoginCallback) then
      FLoginClientData:=NewClientData;
   if Assigned(FSendCallback) then
      FSendClientData:=NewClientData;
   if Assigned(FReceiveCallback) then
      FReceiveClientData:=NewClientData;
   if Assigned(FTraceCallback) then
      FTraceClientData:=NewClientData;
   if Assigned(FReconnectCallback) then
      FReconnectClientData:=NewClientData;
   if Assigned(FGetPathCallback) then
      FGetPathClientData:=NewClientData;
   if Assigned(FGetRightsCallback) then
      FGetRightsClientData:=NewClientData;
   if Assigned(FCheckRightsCallback) then
      FCheckRightsClientData:=NewClientData;
   if Assigned(FProcedureProgressCallback) then
      FProcedureProgressClientData:=NewClientData;
   if (not FInsideEngine) then
      begin
      if Assigned(FPasswordCallback) then
         FPasswordClientData:=NewClientData;
      end
   else
      begin
      if Assigned(FSavePasswordCallback) then
         FSavePasswordClientData:=NewClientData;
      end;
   for I:=0 to FDataDirectoryList.Count-1 do
      TDataDirectory(FDataDirectoryList[I]).CheckCallbacks(NewClientData);
end;

procedure TDataSession.SetLoginCallback(ClientData: Integer;
                                        LoginCallback: pLoginCallback);
begin
   FLoginClientData:=ClientData;
   FLoginCallback:=pLoginCallback(@LoginCallback);
end;

procedure TDataSession.SetTimeoutCallback(ClientData: Integer;
                                          TimeoutCallback: pTimeoutCallback);
begin
   FTimeoutClientData:=ClientData;
   FTimeoutCallback:=pTimeoutCallback(@TimeoutCallback);
end;

procedure TDataSession.SetSendCallback(ClientData: Integer;
                                       SendCallback: pSendReceiveCallback);
begin
   FSendClientData:=ClientData;
   FSendCallback:=pSendReceiveCallback(@SendCallback);
end;

procedure TDataSession.SetReceiveCallback(ClientData: Integer;
                                          ReceiveCallback: pSendReceiveCallback);
begin
   FReceiveClientData:=ClientData;
   FReceiveCallback:=pSendReceiveCallback(@ReceiveCallback);
end;

procedure TDataSession.SetTraceCallback(ClientData: Integer;
                                        TraceCallback: pTraceCallback);
begin
   FTraceClientData:=ClientData;
   FTraceCallback:=pTraceCallback(@TraceCallback);
end;

procedure TDataSession.SetReconnectCallback(ClientData: Integer;
                                           ReconnectCallback: pReconnectCallback);
begin
   FReconnectClientData:=ClientData;
   FReconnectCallback:=pReconnectCallback(@ReconnectCallback);
end;

procedure TDataSession.SetGetPathCallback(ClientData: Integer;
                                          GetPathCallback: pGetPathCallback);
begin
   FGetPathClientData:=ClientData;
   FGetPathCallback:=pGetPathCallback(@GetPathCallback);
end;

procedure TDataSession.SetGetRightsCallback(ClientData: Integer;
                                            GetRightsCallback: pGetRightsCallback);
begin
   FGetRightsClientData:=ClientData;
   FGetRightsCallback:=pGetRightsCallback(@GetRightsCallback);
end;

procedure TDataSession.SetCheckRightsCallback(ClientData: Integer;
                                              CheckRightsCallback: pCheckRightsCallback);
begin
   FCheckRightsClientData:=ClientData;
   FCheckRightsCallback:=pCheckRightsCallback(@CheckRightsCallback);
end;

procedure TDataSession.SetPasswordCallback(ClientData: Integer;
                                           PasswordCallback: pPasswordCallback);
begin
   FPasswordClientData:=ClientData;
   FPasswordCallback:=pPasswordCallback(@PasswordCallback);
end;

procedure TDataSession.SavePasswordCallbackData;
begin
   FSavePasswordClientData:=FPasswordClientData;
   FSavePasswordCallback:=pPasswordCallback(@FPasswordCallback);
end;

procedure TDataSession.RestorePasswordCallbackData;
begin
   FPasswordClientData:=FSavePasswordClientData;
   FPasswordCallback:=pPasswordCallback(@FSavePasswordCallback);
   FSavePasswordClientData:=0;
   FSavePasswordCallback:=nil;
end;

procedure TDataSession.SetProcedureProgressCallback(ClientData: Integer;
                                                    ProcedureProgressCallback: pProcedureProgressCallback);
begin
   FProcedureProgressClientData:=ClientData;
   FProcedureProgressCallback:=pProcedureProgressCallback(@ProcedureProgressCallback);
end;

function TDataSession.AskForPassword: Boolean;
begin
   Result:=False;
   if Assigned(FPasswordCallback) then
      Result:=FPasswordCallback(FPasswordClientData);
end;

function TDataSession.DoLogin: Boolean;
begin
   if (FUserName='') or (FPassword='') then
      begin
      Result:=False;
      if Assigned(FLoginCallback) then
         Result:=FLoginCallback(FLoginClientData,FUserName,FPassword);
      end
   else
      Result:=True;
end;

function TDataSession.DoTimeout(var StayConnected: Boolean): Boolean;
begin
   Result:=False;
   if Assigned(FTimeoutCallback) then
      begin
      FTimeoutCallback(FTimeoutClientData,StayConnected);
      Result:=True;
      end;
end;

procedure TDataSession.DoSendProgress(NumBytes: Integer; PercentDone: Word);
begin
   if Assigned(FSendCallback) then
      FSendCallback(FSendClientData,NumBytes,PercentDone);
end;

procedure TDataSession.DoReceiveProgress(NumBytes: Integer; PercentDone: Word);
begin
   if Assigned(FReceiveCallback) then
      FReceiveCallback(FReceiveClientData,NumBytes,PercentDone);
end;

procedure TDataSession.DoTrace(TraceRecord: TDataTraceRecord);
begin
   try
      if Assigned(FTraceCallback) then
         FTraceCallback(FTraceClientData,TraceRecord);
   except
      { Don't let exceptions in the tracing callback mess up the comms }
   end;
end;

procedure TDataSession.DoGetPath(const DataDirectoryName: string;
                                 var Path: string);
begin
   if Assigned(FGetPathCallback) then
      FGetPathCallback(FGetPathClientData,DataDirectoryName,Path);
end;

procedure TDataSession.DoGetRights(const DataDirectoryName: string;
                                   var Rights: Integer);
begin
   if Assigned(FGetRightsCallback) then
      FGetRightsCallback(FGetRightsClientData,DataDirectoryName,Rights);
end;

procedure TDataSession.DoCheckRights(DataDirectory: TObject; RightToCheck: Byte);
begin
   if Assigned(FCheckRightsCallback) then
      FCheckRightsCallback(FCheckRightsClientData,DataDirectory,RightToCheck);
end;

procedure TDataSession.DoProcedureProgress(const Status: string; PercentDone: Word;
                                           var Abort: Boolean);
begin
   if Assigned(FProcedureProgressCallback) then
      FProcedureProgressCallback(FProcedureProgressClientData,Status,
                                 PercentDone,Abort);
end;

function TDataSession.GetRequestCode: Word;
begin
   Result:=FRequestHeader.RequestCode;
end;

procedure TDataSession.SetRequestCode(Value: Word);
begin
   FRequestHeader.RequestCode:=Value;
end;

function TDataSession.GetResultCode: Word;
begin
   Result:=FReplyHeader.ResultCode;
end;

function TDataSession.SocketConnected: Boolean;
begin
   Result:=FSocket.Socket.Connected;
end;

function TDataSession.WaitForData(TimeOut: Integer): Boolean;
begin
   Result:=TDataSocket(FSocket).WaitForData(TimeOut);
end;

function TDataSession.ReceiveBuffer(var Buffer; Count: Integer): Integer;
begin
   Result:=FSocket.Socket.ReceiveBuf(Buffer,Count);
end;

function TDataSession.SendBuffer(var Buffer; Count: Integer): Integer;
begin
   Result:=FSocket.Socket.SendBuf(Buffer,Count);
end;

procedure TDataSession.SetPing(Value: Boolean);
begin
   if (Value <> FPing) then
      begin
      FPing:=Value;
      if FPing then
         StartPinging
      else
         StopPinging;
      end;
end;

procedure TDataSession.SetPingInterval(Value: Word);
begin
   if (Value <> FPingInterval) then
      begin
      FPingInterval:=Value;
      StartPinging;
      end;
end;

procedure TDataSession.StartPinging;
begin
   if FLoggedIn and FPing then
      begin
      FPingThread:=TPingThread.Create(Self);
      with FPingTimer do
         begin
         OnTimer:=PingTimerTimer;
         Interval:=(FPingInterval*1000);
         Enabled:=True;
         end;
      end;
end;

procedure TDataSession.StopPinging;
begin
   FPingTimer.Enabled:=False;
   if (FPingThread <> nil) then
      begin
      with FPingThread do
         begin
         Terminate;
         Ping;
         Free;
         end;
      end;
end;

procedure TDataSession.PingTimerTimer(Sender: TObject);
begin
   if FPinging then
      Exit;
   FPinging:=True;
   FPingThread.Ping;
end;

procedure TDataSession.StartRemoteRequest;
begin
   OSEnterCriticalSection(FSessionLock);
end;

procedure TDataSession.EndRemoteRequest;
begin
   ResizeSendBuffer(DEFAULT_SEND_BUFFER_SIZE,True);
   ResizeReceiveBuffer(DEFAULT_RECV_BUFFER_SIZE,True);
   OSLeaveCriticalSection(FSessionLock);
end;

function TDataSession.InternalSend: Boolean;
var
   TotalBytesSent: Integer;
   BytesToSend: Integer;
   BytesSent: Integer;
   BeginTicks: LongWord;
   EndTicks: LongWord;
   TempTraceRecord: TDataTraceRecord;
   TempPercentDone: Integer;
   TempLastPercentDone: Integer;
begin
   try
      BeginTicks:=OSGetTickCount;
      TotalBytesSent:=0;
      TempLastPercentDone:=0;
      DoSendProgress(0,0);
      while SocketConnected and
            (TotalBytesSent < FRequestHeader.TotalRequestSize) do
         begin
         BytesToSend:=MinimumInteger((FRequestHeader.TotalRequestSize-TotalBytesSent),
                                      MAX_SEND_SIZE);
         BytesSent:=SendBuffer((FSendBuffer+TotalBytesSent)^,BytesToSend);
         Inc(TotalBytesSent,BytesSent);
         TempPercentDone:=Trunc(((TotalBytesSent/FRequestHeader.TotalRequestSize)*100));
         if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
            begin
            DoSendProgress(TotalBytesSent,TempPercentDone);
            TempLastPercentDone:=TempPercentDone;
            end;
         end;
      Result:=(TotalBytesSent=FRequestHeader.TotalRequestSize);
      if Result then
         begin
         DoSendProgress(TotalBytesSent,100);
         EndTicks:=OSGetTickCount;
         if FTracing then
            begin
            with TempTraceRecord do
               begin
               DateTime:=Now;
               EventType:=TRACE_TYPE_REQUEST;
               ElapsedTime:=OSCalcElapsedTime(BeginTicks,EndTicks);
               RemoteEncryption:=FIsEncrypted;
               RemoteCompression:=FCompression;
               RemoteHost:=FHost;
               RemoteAddress:=FAddress;
               RemotePort:=FPort;
               RemoteService:=FService;
               RemoteUser:=FUserName;
               RemoteRequestID:=FRequestHeader.RequestCode;
               RemoteRequestName:=DataEngine.TranslateRequestConstant(FRequestHeader.RequestCode);
               RemoteRequestSize:=FRequestHeader.TotalRequestSize;
               RemoteReplyResultID:=0;
               RemoteReplyResultName:='';
               RemoteReplySize:=0;
               end;
            DoTrace(TempTraceRecord);
            end;
         end;
   except
      Result:=False;
   end;
end;

function TDataSession.InternalReceive: Byte;
var
   TotalBytesReceived: Integer;
   BytesToRead: Integer;
   BytesRead: Integer;
   ReceiveSize: Integer;
   BeginTicks: LongWord;
   EndTicks: LongWord;
   TempTraceRecord: TDataTraceRecord;
   TempSignature: TMD5Digest;
   TempPercentDone: Integer;
   TempLastPercentDone: Integer;
begin
   Result:=RECEIVE_NONE;
   try
      BeginTicks:=OSGetTickCount;
      TotalBytesReceived:=0;
      if WaitForData((FTimeout*1000)) then
         begin
         TempLastPercentDone:=0;
         DoReceiveProgress(0,0);
         BytesRead:=ReceiveBuffer(TempSignature,SizeOf(TMD5Digest));
         if (BytesRead <> SizeOf(TMD5Digest)) or
            ((not MD5DigestCompare(TempSignature,DataEngine.SignatureDigest)) and
             (not MD5DigestCompare(TempSignature,MD5String(DBISAM_SIGNATURE)))) then
            Result:=RECEIVE_ERROR
         else
            begin
            Inc(TotalBytesReceived,BytesRead);
            ResizeReceiveBuffer(TotalBytesReceived);
            Move(TempSignature,FReceiveBuffer^,BytesRead);
            if WaitForData((FTimeout*1000)) then
               begin
               ReceiveSize:=0;
               BytesRead:=ReceiveBuffer(ReceiveSize,SizeOf(Integer));
               if (BytesRead <> SizeOf(Integer)) then
                  Result:=RECEIVE_ERROR
               else
                  begin
                  ResizeReceiveBuffer(ReceiveSize);
                  Move(ReceiveSize,(FReceiveBuffer+TotalBytesReceived)^,BytesRead);
                  Inc(TotalBytesReceived,BytesRead);
                  while SocketConnected and
                        (TotalBytesReceived < ReceiveSize) do
                     begin
                     if WaitForData((FTimeout*1000)) then
                        begin
                        BytesToRead:=MinimumInteger((ReceiveSize-TotalBytesReceived),MAX_RECV_SIZE);
                        BytesRead:=ReceiveBuffer((FReceiveBuffer+TotalBytesReceived)^,BytesToRead);
                        Inc(TotalBytesReceived,BytesRead);
                        TempPercentDone:=Trunc(((TotalBytesReceived/ReceiveSize)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           DoReceiveProgress(TotalBytesReceived,TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     end;
                  if (TotalBytesReceived=ReceiveSize) then
                     Result:=RECEIVE_PRESENT
                  else
                     Result:=RECEIVE_ERROR;
                  end;
               end;
            end;
         end;
      if (Result=RECEIVE_PRESENT) then
         begin
         DoReceiveProgress(TotalBytesReceived,100);
         EndTicks:=OSGetTickCount;
         BeginUnpack;
         if FTracing then
            begin
            with TempTraceRecord do
               begin
               DateTime:=Now;
               EventType:=TRACE_TYPE_REPLY;
               ElapsedTime:=OSCalcElapsedTime(BeginTicks,EndTicks);
               RemoteEncryption:=FIsEncrypted;
               RemoteCompression:=FCompression;
               RemoteHost:=FHost;
               RemoteAddress:=FAddress;
               RemotePort:=FPort;
               RemoteService:=FService;
               RemoteUser:=FUserName;
               RemoteRequestID:=0;
               RemoteRequestName:='';
               RemoteRequestSize:=0;
               RemoteReplyResultID:=pReplyHeader(FReceiveBuffer)^.ResultCode;
               RemoteReplyResultName:=DataEngine.TranslateErrorConstant(pReplyHeader(FReceiveBuffer)^.ResultCode);
               RemoteReplySize:=pReplyHeader(FReceiveBuffer)^.TotalReplySize;
               end;
            DoTrace(TempTraceRecord);
            end;
         end;                        
   except
      Result:=RECEIVE_ERROR;
   end;
end;

procedure TDataSession.Send;
begin
   if (not InternalSend) then
      begin
      Disconnect;
      DataEngine.RaiseError(DBISAM_REMOTECOMMLOST,GetRemoteLocation);
      end;
end;

procedure TDataSession.Receive(var CallbackType: Word);
var
   TempResult: Boolean;
   TempStatus: string;
   TempPercentDone: Word;
   TempAbort: Boolean;
begin
   while True do
      begin
      case InternalReceive of
         RECEIVE_PRESENT:
            begin
            if (GetResultCode=DBISAM_REMOTECALLBACK) then
               begin
               Unpack(CallbackType);
               case CallbackType of
                  CALLBACK_PASSWORD:
                     begin
                     TempResult:=AskForPassword;
                     SetRequestCode(REQUEST_CALLBACKRESPONSE);
                     BeginPack;
                     Pack(TempResult,SizeOf(Boolean));
                     EndPack;
                     Send;
                     end;
                  CALLBACK_PROCEDUREPROGRESS:
                     begin
                     TempStatus[0]:=Char(Byte(Unpack(TempStatus[1])));
                     Unpack(TempPercentDone);
                     Unpack(TempAbort);
                     DoProcedureProgress(TempStatus,TempPercentDone,TempAbort);
                     SetRequestCode(REQUEST_CALLBACKRESPONSE);
                     BeginPack;
                     Pack(TempAbort,SizeOf(Boolean));
                     EndPack;
                     Send;
                     end;
                  else
                     Break;
                  end;
               end
            else
               Break;
            end;
         RECEIVE_ERROR:
            begin
            Disconnect;
            DataEngine.RaiseError(DBISAM_REMOTECOMMLOST,GetRemoteLocation);
            end;
         RECEIVE_NONE:
            begin
            TempResult:=False;
            if DoTimeout(TempResult) then
               begin
               if (not TempResult) then
                  begin
                  Disconnect;
                  Abort;
                  end;
               end
            else
               begin
               Disconnect;
               DataEngine.RaiseError(DBISAM_REMOTECOMMLOST,GetRemoteLocation);
               end;
            end;
         end;
      end;
end;

procedure TDataSession.SendReceive;
var
   Reconnected: Boolean;
   TempCallbackType: Word;
begin
   Reconnected:=False;
   while True do
      begin
      try
         Send;
         Receive(TempCallbackType);
         Break;
      except
         on E: Exception do
            begin
            if (not Reconnected) then
               begin
               HandleReconnect;
               Reconnected:=True;
               end
            else
               raise;
            end;
      end;
      end;
end;

procedure TDataSession.GetRemoteUserNames(UserNamesList: TStrings);
var
   I: Integer;
   TotalUsers: Integer;
   TempUserName: string;
begin
   UserNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETUSERNAMES);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalUsers);
         for I:=1 to TotalUsers do
            begin
            TempUserName[0]:=Char(Byte(Unpack(TempUserName[1])));
            UserNamesList.Add(TempUserName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteUser(const UserName: string; var UserPassword: string;
                                     var UserDescription: string;
                                     var IsAdministrator: Boolean;
                                     var MaxConnections: Word);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETUSER);
         BeginPack;
         Pack(UserName[1],Length(UserName));
         EndPack;
         SendReceive;
         CheckForException;
         UserPassword[0]:=Char(Byte(Unpack(UserPassword[1])));
         UserDescription[0]:=Char(Byte(Unpack(UserDescription[1])));
         Unpack(IsAdministrator);
         if (RemoteEngineVersion >= 4.09) then
            Unpack(MaxConnections)
         else
            MaxConnections:=DEFAULT_MAX_USER_CONNECTIONS;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.AddRemoteUser(const UserName: string; const UserPassword: string;
                                     const UserDescription: string;
                                     IsAdministrator: Boolean; MaxConnections: Word);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDUSER);
         BeginPack;
         Pack(UserName[1],Length(UserName));
         Pack(UserPassword[1],Length(UserPassword));
         Pack(UserDescription[1],Length(UserDescription));
         Pack(IsAdministrator,SizeOf(Boolean));
         if (RemoteEngineVersion >= 4.09) then
            Pack(MaxConnections,SizeOf(Word));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteUser(const UserName: string; const UserPassword: string;
                                        const UserDescription: string;
                                        IsAdministrator: Boolean; MaxConnections: Word);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYUSER);
         BeginPack;
         Pack(UserName[1],Length(UserName));
         Pack(UserPassword[1],Length(UserPassword));
         Pack(UserDescription[1],Length(UserDescription));
         Pack(IsAdministrator,SizeOf(Boolean));
         if (RemoteEngineVersion >= 4.09) then
            Pack(MaxConnections,SizeOf(Word));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteUserPassword(const UserName: string;
                                                const UserPassword: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYUSERPASSWORD);
         BeginPack;
         Pack(UserName[1],Length(UserName));
         Pack(UserPassword[1],Length(UserPassword));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteUser(const UserName: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEUSER);
         BeginPack;
         Pack(UserName[1],Length(UserName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteDatabaseNames(DatabaseNamesList: TStrings);
var
   I: Integer;
   TotalDatabases: Integer;
   TempDatabaseName: string;
begin
   DatabaseNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETDBNAMES);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalDatabases);
         for I:=1 to TotalDatabases do
            begin
            TempDatabaseName[0]:=Char(Byte(Unpack(TempDatabaseName[1])));
            DatabaseNamesList.Add(TempDatabaseName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteDatabase(const DatabaseName: string;
                                         var DatabaseDescription: string;
                                         var ServerPath: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETDB);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         EndPack;
         SendReceive;
         CheckForException;
         DatabaseDescription[0]:=Char(Byte(Unpack(DatabaseDescription[1])));
         ServerPath[0]:=Char(Byte(Unpack(ServerPath[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.AddRemoteDatabase(const DatabaseName: string;
                                         const DatabaseDescription: string;
                                         const ServerPath: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDDB);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(DatabaseDescription[1],Length(DatabaseDescription));
         Pack(ServerPath[1],Length(ServerPath));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteDatabase(const DatabaseName: string;
                                            const DatabaseDescription: string;
                                            const ServerPath: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYDB);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(DatabaseDescription[1],Length(DatabaseDescription));
         Pack(ServerPath[1],Length(ServerPath));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteDatabase(const DatabaseName: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEDB);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.AddRemoteDatabaseUser(const DatabaseName: string;
                                             const AuthorizedUser: string;
                                              RightsToAssign: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDDBUSER);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         Pack(RightsToAssign,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteDatabaseUser(const DatabaseName: string;
                                                const AuthorizedUser: string;
                                                  RightsToAssign: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYDBUSER);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         Pack(RightsToAssign,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteDatabaseUser(const DatabaseName: string;
                                                const AuthorizedUser: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEDBUSER);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteDatabaseUser(const DatabaseName: string;
                                             const AuthorizedUser: string;
                                              var UserRights: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETDBUSER);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(UserRights);
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteDatabaseUserNames(const DatabaseName: string;
                                                  DatabaseUserNamesList: TStrings);
var
   TotalUsers: Integer;
   TempUserName: string;
   I: Integer;
begin
   DatabaseUserNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETDBUSERNAMES);
         BeginPack;
         Pack(DatabaseName[1],Length(DatabaseName));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalUsers);
         for I:=1 to TotalUsers do
            begin
            TempUserName[0]:=Char(Byte(Unpack(TempUserName[1])));
            DatabaseUserNamesList.Add(TempUserName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteProcedureNames(ProcedureNamesList: TStrings);
var
   I: Integer;
   TotalProcedures: Integer;
   TempProcedureName: string;
begin
   ProcedureNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETPROCNAMES);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalProcedures);
         for I:=1 to TotalProcedures do
            begin
            TempProcedureName[0]:=Char(Byte(Unpack(TempProcedureName[1])));
            ProcedureNamesList.Add(TempProcedureName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteProcedure(const ProcedureName: string;
                                          var ProcedureDescription: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETPROC);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         EndPack;
         SendReceive;
         CheckForException;
         ProcedureDescription[0]:=Char(Byte(Unpack(ProcedureDescription[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.AddRemoteProcedure(const ProcedureName: string;
                                          const ProcedureDescription: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDPROC);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(ProcedureDescription[1],Length(ProcedureDescription));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteProcedure(const ProcedureName: string;
                                             const ProcedureDescription: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYPROC);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(ProcedureDescription[1],Length(ProcedureDescription));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteProcedure(const ProcedureName: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEPROC);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.AddRemoteProcedureUser(const ProcedureName: string;
                                              const AuthorizedUser: string;
                                               RightsToAssign: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDPROCUSER);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         Pack(RightsToAssign,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteProcedureUser(const ProcedureName: string;
                                                 const AuthorizedUser: string;
                                                   RightsToAssign: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYPROCUSER);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         Pack(RightsToAssign,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteProcedureUser(const ProcedureName: string;
                                                 const AuthorizedUser: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEPROCUSER);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteProcedureUser(const ProcedureName: string;
                                              const AuthorizedUser: string;
                                               var UserRights: Integer);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETPROCUSER);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         Pack(AuthorizedUser[1],Length(AuthorizedUser));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(UserRights);
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteProcedureUserNames(const ProcedureName: string;
                                                  ProcedureUserNamesList: TStrings);
var
   TotalUsers: Integer;
   TempUserName: string;
   I: Integer;
begin
   ProcedureUserNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETPROCUSERNAMES);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalUsers);
         for I:=1 to TotalUsers do
            begin
            TempUserName[0]:=Char(Byte(Unpack(TempUserName[1])));
            ProcedureUserNamesList.Add(TempUserName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteEventNames(EventNamesList: TStrings);
var
   I: Integer;
   TotalEvents: Integer;
   TempEventName: string;
begin
   EventNamesList.Clear;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETEVENTNAMES);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalEvents);
         for I:=1 to TotalEvents do
            begin
            TempEventName[0]:=Char(Byte(Unpack(TempEventName[1])));
            EventNamesList.Add(TempEventName);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteEvent(const EventName: string; var EventDescription: string;
                                      var EventRunType: Byte;
                                      var EventStartDate: TDateTime;
                                      var EventEndDate: TDateTime;
                                      var EventStartTime: TDateTime;
                                      var EventEndTime: TDateTime;
                                      var EventInterval: Word;
                                      var EventDays: TConfigDays;
                                      var EventDayOfMonth: Byte;
                                      var EventDayOfWeek: Byte;
                                      var EventMonths: TConfigMonths;
                                      var EventLastRun: TDateTime);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETEVENT);
         BeginPack;
         Pack(EventName[1],Length(EventName));
         EndPack;
         SendReceive;
         CheckForException;
         EventDescription[0]:=Char(Byte(Unpack(EventDescription[1])));
         Unpack(EventRunType);
         Unpack(EventStartDate);
         Unpack(EventEndDate);
         Unpack(EventStartTime);
         Unpack(EventEndTime);
         Unpack(EventInterval);
         Unpack(EventDays);
         Unpack(EventDayOfMonth);
         Unpack(EventDayOfWeek);
         Unpack(EventMonths);
         Unpack(EventLastRun);
      finally
         EndRemoteRequest;
      end;
      end;
end;


procedure TDataSession.AddRemoteEvent(const EventName: string; const EventDescription: string;
                                      EventRunType: Byte;
                                      EventStartDate: TDateTime;
                                      EventEndDate: TDateTime;
                                      EventStartTime: TDateTime;
                                      EventEndTime: TDateTime;
                                      EventInterval: Word;
                                      EventDays: TConfigDays;
                                      EventDayOfMonth: Byte;
                                      EventDayOfWeek: Byte;
                                      EventMonths: TConfigMonths);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDEVENT);
         BeginPack;
         Pack(EventName[1],Length(EventName));
         Pack(EventDescription[1],Length(EventDescription));
         Pack(EventRunType,SizeOf(Byte));
         Pack(EventStartDate,SizeOf(TDateTime));
         Pack(EventEndDate,SizeOf(TDateTime));
         Pack(EventStartTime,SizeOf(TDateTime));
         Pack(EventEndTime,SizeOf(TDateTime));
         Pack(EventInterval,SizeOf(Word));
         Pack(EventDays,SizeOf(TConfigDays));
         Pack(EventDayOfMonth,SizeOf(Byte));
         Pack(EventDayOfWeek,SizeOf(Byte));
         Pack(EventMonths,SizeOf(TConfigMonths));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteEvent(const EventName: string; const EventDescription: string;
                                         EventRunType: Byte;
                                         EventStartDate: TDateTime;
                                         EventEndDate: TDateTime;
                                         EventStartTime: TDateTime;
                                         EventEndTime: TDateTime;
                                         EventInterval: Word;
                                         EventDays: TConfigDays;
                                         EventDayOfMonth: Byte;
                                         EventDayOfWeek: Byte;
                                         EventMonths: TConfigMonths);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYEVENT);
         BeginPack;
         Pack(EventName[1],Length(EventName));
         Pack(EventDescription[1],Length(EventDescription));
         Pack(EventRunType,SizeOf(Byte));
         Pack(EventStartDate,SizeOf(TDateTime));
         Pack(EventEndDate,SizeOf(TDateTime));
         Pack(EventStartTime,SizeOf(TDateTime));
         Pack(EventEndTime,SizeOf(TDateTime));
         Pack(EventInterval,SizeOf(Word));
         Pack(EventDays,SizeOf(TConfigDays));
         Pack(EventDayOfMonth,SizeOf(Byte));
         Pack(EventDayOfWeek,SizeOf(Byte));
         Pack(EventMonths,SizeOf(TConfigMonths));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.DeleteRemoteEvent(const EventName: string);
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEEVENT);
         BeginPack;
         Pack(EventName[1],Length(EventName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.GetRemoteConfig(var DenyLogins: Boolean; var MaxConnections: Word;
                                       var ConnectTimeout: Word; var DeadSessionInterval: Word;
                                       var DeadSessionExpires: Word; var MaxDeadSessions: Word;
                                       var TempDirectory: string;
                                       AuthorizedAddresses: TStrings;
                                       BlockedAddresses: TStrings);
var
   I: Integer;
   TempNumAddresses: Integer;
   TempAddress: string;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETCONFIG);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(DenyLogins);
         Unpack(MaxConnections);
         Unpack(ConnectTimeout);
         Unpack(DeadSessionInterval);
         Unpack(DeadSessionExpires);
         Unpack(MaxDeadSessions);
         TempDirectory[0]:=Char(Byte(Unpack(TempDirectory[1])));
         Unpack(TempNumAddresses);
         for I:=1 to TempNumAddresses do
            begin
            TempAddress[0]:=Char(Byte(Unpack(TempAddress[1])));
            AuthorizedAddresses.Add(TempAddress);
            end;
         Unpack(TempNumAddresses);
         for I:=1 to TempNumAddresses do
            begin
            TempAddress[0]:=Char(Byte(Unpack(TempAddress[1])));
            BlockedAddresses.Add(TempAddress);
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.ModifyRemoteConfig(DenyLogins: Boolean; MaxConnections: Word;
                                          ConnectTimeout: Word; DeadSessionInterval: Word;
                                          DeadSessionExpires: Word; MaxDeadSessions: Word;
                                          const TempDirectory: string;
                                          AuthorizedAddresses: TStrings;
                                          BlockedAddresses: TStrings);
var
   I: Integer;
   TempNumAddresses: Integer;
   TempAddress: string;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYCONFIG);
         BeginPack;
         Pack(DenyLogins,SizeOf(Boolean));
         Pack(MaxConnections,SizeOf(Word));
         Pack(ConnectTimeout,SizeOf(Word));
         Pack(DeadSessionInterval,SizeOf(Word));
         Pack(DeadSessionExpires,SizeOf(Word));
         Pack(MaxDeadSessions,SizeOf(Word));
         Pack(TempDirectory[1],Length(TempDirectory));
         TempNumAddresses:=AuthorizedAddresses.Count;
         Pack(TempNumAddresses,SizeOf(Integer));
         for I:=0 to TempNumAddresses-1 do
            begin
            TempAddress:=AuthorizedAddresses[I];
            Pack(TempAddress[1],Length(TempAddress));
            end;
         TempNumAddresses:=BlockedAddresses.Count;
         Pack(TempNumAddresses,SizeOf(Integer));
         for I:=0 to TempNumAddresses-1 do
            begin
            TempAddress:=BlockedAddresses[I];
            Pack(TempAddress[1],Length(TempAddress));
            end;
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteLogCount: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETLOGCOUNT);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteLogRecord(Number: Integer): TDataLogRecord;
begin
   FillChar(Result,SizeOf(TDataLogRecord),#0);
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETLOGRECORD);
         BeginPack;
         Pack(Number,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.StartRemoteServer;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_STARTSERVER);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.StopRemoteServer;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_STOPSERVER);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteEngineVersion: string;
begin
   Result:=PadRight(AnsiCurrToStr(FRemoteEngineVersion),4,'0')+
           ' Build '+IntToStr(FRemoteEngineBuildNumber);
end;

function TDataSession.GetRemoteDateTime: TDateTime;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETDATETIME);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteUTCDateTime: TDateTime;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETUTCDATETIME);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteUpTime: Int64;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETUPTIME);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteMemoryUsage: double;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETMEMORYUSAGE);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteServerName: string;
begin
   Result:='';
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETSERVERNAME);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Result[0]:=Char(Byte(Unpack(Result[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteServerDescription: string;
begin
   Result:='';
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETSERVERDESC);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Result[0]:=Char(Byte(Unpack(Result[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteMainAddress: string;
begin
   Result:='';
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETMAINADDRESS);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Result[0]:=Char(Byte(Unpack(Result[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteMainPort: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETMAINPORT);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteMainThreadCacheSize: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETMAINTHREADCACHESIZE);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteAdminAddress: string;
begin
   Result:='';
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETADMINADDRESS);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Result[0]:=Char(Byte(Unpack(Result[1])));
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteAdminPort: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETADMINPORT);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteAdminThreadCacheSize: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETADMINTHREADCACHESIZE);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteSessionCount: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETSESSIONS);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteSessionInfo(SessionNum: Integer;
                                           var SessionID: Integer;
                                           var CreatedOn: TDateTime;
                                           var LastConnectedOn: TDateTime;
                                           var UserName: string;
                                           var UserAddress: string;
                                           var IsEncryptedSession: Boolean;
                                           var LastAddress: string): Boolean;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETSESSIONINFO);
         BeginPack;
         Pack(SessionNum,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         if Result then
            begin
            Unpack(SessionID);
            Unpack(CreatedOn);
            Unpack(LastConnectedOn);
            UserName[0]:=Char(Byte(Unpack(UserName[1])));
            UserAddress[0]:=Char(Byte(Unpack(UserAddress[1])));
            Unpack(IsEncryptedSession);
            LastAddress[0]:=Char(Byte(Unpack(LastAddress[1])));
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.DisconnectRemoteSession(SessionID: Integer): Boolean;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DISCONNECTSESSION);
         BeginPack;
         Pack(SessionID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.RemoveRemoteSession(SessionID: Integer): Boolean;
begin
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_REMOVESESSION);
         BeginPack;
         Pack(SessionID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

function TDataSession.GetRemoteConnectedSessionCount: Integer;
begin
   Result:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETCONNECTEDSESSIONS);
         BeginPack;
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataSession.PackParameters(ParamCount: Word;
                                      const ParamDefinitions: array of pFieldDefinition;
                                      RecordBuffer: PChar);
var
   I: Integer;
begin
   Pack(ParamCount,SizeOf(Word));
   for I:=0 to (ParamCount-1) do
      Pack(ParamDefinitions[I]^,SizeOf(TFieldDefinition));
   for I:=0 to (ParamCount-1) do
      begin
      with ParamDefinitions[I]^ do
         begin
         if (DataType <> TYPE_BLOB) then
            Pack((RecordBuffer+Offset)^,(FLDCHG_DATA+DataSize))
         else
            begin
            Pack((RecordBuffer+Offset)^,(FLDCHG_DATA+DataSize));
            Pack(pBlobParam((RecordBuffer+FLDCHG_DATA+Offset))^.BlobBuffer^,
                 pBlobParam((RecordBuffer+FLDCHG_DATA+Offset))^.BlobLength);
            end;
         end;
      end;
end;

procedure TDataSession.UnpackParameters(out OutParamCount: Word;
                                        out OutParamDefinitions: array of pFieldDefinition;
                                        out OutRecordBuffer: PChar;
                                        out OutBlobCount: Word;
                                        out OutBlobBuffers: array of PChar);
var
   I: Integer;
   TempRecordBufferSize: Integer;
   TempBlobSize: Integer;
begin
   Unpack(OutParamCount);
   for I:=0 to (OutParamCount-1) do
      begin
      OutParamDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
      Unpack(OutParamDefinitions[I]^);
      end;
   TempRecordBufferSize:=0;
   for I:=0 to (OutParamCount-1) do
      begin
      with OutParamDefinitions[I]^ do
         Inc(TempRecordBufferSize,(FLDCHG_DATA+DataSize));
      end;
   OutBlobCount:=0;
   if (TempRecordBufferSize > 0) then
      OutRecordBuffer:=AllocMem(TempRecordBufferSize)
   else
      OutRecordBuffer:=nil;
   for I:=0 to (OutParamCount-1) do
      begin
      with OutParamDefinitions[I]^ do
         begin
         Unpack((OutRecordBuffer+Offset)^);
         if (DataType=TYPE_BLOB) then
            begin
            TempBlobSize:=pBlobParam((OutRecordBuffer+FLDCHG_DATA+Offset))^.BlobLength;
            OutBlobBuffers[OutBlobCount]:=AllocMem(TempBlobSize);
            Unpack(OutBlobBuffers[OutBlobCount]^);
            pBlobParam((OutRecordBuffer+FLDCHG_DATA+Offset))^.BlobBuffer:=
                                             OutBlobBuffers[OutBlobCount];
            Inc(OutBlobCount);
            end;
         end;
      end;
end;

function TDataSession.GetIsServer: Boolean;
begin
   Result:=DataEngine.IsServer and (not FInsideEngine);
end;

procedure TDataSession.SetInsideEngine(Value: Boolean);
begin
   if (Value <> FInsideEngine) then
      begin
      FInsideEngine:=Value;
      if FInsideEngine then
         SavePasswordCallbackData
      else
         RestorePasswordCallbackData;
      end;
end;

procedure TDataSession.ServerProcedure(const ProcedureName: string;
                                       InParamCount: Word;
                                       const InParamDefinitions: array of pFieldDefinition;
                                       InRecordBuffer: PChar;
                                       out OutParamCount: Word;
                                       out OutParamDefinitions: array of pFieldDefinition;
                                       out OutRecordBuffer: PChar;
                                       out OutBlobCount: Word;
                                       out OutBlobBuffers: array of PChar);
begin
   OutParamCount:=0;
   OutRecordBuffer:=nil;
   OutBlobCount:=0;
   DataEngine.ServerProcedure(Self,ProcedureName,
                              InParamCount,InParamDefinitions,
                              InRecordBuffer,
                              OutParamCount,OutParamDefinitions,
                              OutRecordBuffer,
                              OutBlobCount,OutBlobBuffers);
end;

procedure TDataSession.CallRemoteProcedure(const ProcedureName: string;
                                           InParamCount: Word;
                                           const InParamDefinitions: array of pFieldDefinition;
                                           InRecordBuffer: PChar;
                                           out OutParamCount: Word;
                                           out OutParamDefinitions: array of pFieldDefinition;
                                           out OutRecordBuffer: PChar;
                                           out OutBlobCount: Word;
                                           out OutBlobBuffers: array of PChar);
begin
   OutParamCount:=0;
   OutRecordBuffer:=nil;
   OutBlobCount:=0;
   if FIsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_PROCEDURE);
         BeginPack;
         Pack(ProcedureName[1],Length(ProcedureName));
         PackParameters(InParamCount,InParamDefinitions,InRecordBuffer);
         EndPack;
         SendReceive;
         CheckForException;
         UnpackParameters(OutParamCount,OutParamDefinitions,OutRecordBuffer,
                          OutBlobCount,OutBlobBuffers);
      finally
         EndRemoteRequest;
      end;
      end;
end;

{ TDataTableLocks }

constructor TDataTableLocks.Create(Owner: TDataDirectoryLocks);
begin
   FDataDirectoryLocks:=Owner;
end;

function TDataTableLocks.GetProperDataDirectoryName: string;
begin
   Result:=FDataDirectoryLocks.ProperDataDirectoryName;
end;

procedure TDataTableLocks.Read(Buffer: PChar);
begin
   FTableName[0]:=Buffer^;
   Move((Buffer+SizeOf(Byte))^,FTableName[1],Byte(Buffer^));
end;

procedure TDataTableLocks.Write(Buffer: PChar);
begin
   Buffer^:=FTableName[0];
   Move(FTableName[1],(Buffer+SizeOf(Byte))^,Length(FTableName));
end;

function TDataTableLocks.ReadLock: Boolean;
begin
   Result:=False;
   if (not ((lsReadLocked in FLockStates) or (lsWriteLocked in FLockStates) or
            (lsTransLocked in FLockStates))) then
      begin
      if (not FDataDirectoryLocks.ReadLock(FReadLockSlot,(DataEngine.ReadLockByte-(FTableID*DataEngine.ReadLockRange)),
                                           DataEngine.ReadLockRetries,DataEngine.ReadLockWaitTime)) then
         DataEngine.RaiseError(DBISAM_READLOCK,'','',ProperDataDirectoryName,FTableName);
      Include(FLockStates,lsReadLocked);
      Result:=True;
      end;
end;

procedure TDataTableLocks.ReadUnlock;
begin
   if (lsReadLocked in FLockStates) then
      begin
      if (not FDataDirectoryLocks.ReadUnlock(FReadLockSlot,(DataEngine.ReadLockByte-(FTableID*DataEngine.ReadLockRange)))) then
         DataEngine.RaiseError(DBISAM_READUNLOCK,'','',ProperDataDirectoryName,
                               FTableName);
      Exclude(FLockStates,lsReadLocked);
      end;
end;

function TDataTableLocks.WriteLock(TransLock: Boolean): Boolean;
begin
   Result:=False;
   if (not (lsWriteLocked in FLockStates)) then
      begin
      if TransLock and (not (lsTransLocked in FLockStates)) then
         begin
         if (not FDataDirectoryLocks.WriteLock((DataEngine.TransLockByte-FTableID),1,
                                                DataEngine.WriteLockRetries,DataEngine.WriteLockWaitTime)) then
            DataEngine.RaiseError(DBISAM_WRITELOCK,'','',ProperDataDirectoryName,FTableName);
         Include(FLockStates,lsTransLocked);
         Result:=True;
         end;
      if (not FDataDirectoryLocks.WriteLock((DataEngine.WriteLockByte-(FTableID*DataEngine.WriteLockRange)),
                                             DataEngine.WriteLockRange,DataEngine.WriteLockRetries,DataEngine.WriteLockWaitTime)) then
         begin
         if TransLock then
            begin
            FDataDirectoryLocks.WriteUnlock((DataEngine.TransLockByte-FTableID),1);
            Exclude(FLockStates,lsTransLocked);
            end;
         DataEngine.RaiseError(DBISAM_WRITELOCK,'','',ProperDataDirectoryName,FTableName);
         end;
      Include(FLockStates,lsWriteLocked);
      end;
end;

procedure TDataTableLocks.WriteUnlock(TransUnlock: Boolean);
begin
   if (lsWriteLocked in FLockStates) then
      begin
      if (not FDataDirectoryLocks.WriteUnlock((DataEngine.WriteLockByte-(FTableID*DataEngine.WriteLockRange)),
                                               DataEngine.WriteLockRange)) then
         DataEngine.RaiseError(DBISAM_WRITEUNLOCK,'','',ProperDataDirectoryName,FTableName);
      Exclude(FLockStates,lsWriteLocked);
      if TransUnlock and (lsTransLocked in FLockStates) then
         begin
         if (not FDataDirectoryLocks.WriteUnlock((DataEngine.TransLockByte-FTableID),1)) then
            DataEngine.RaiseError(DBISAM_WRITEUNLOCK,'','',ProperDataDirectoryName,FTableName);
         Exclude(FLockStates,lsTransLocked);
         end;
      end;
end;

function TDataTableLocks.TransLock: Boolean;
begin
   Result:=False;
   if (not (lsTransLocked in FLockStates)) then
      begin
      if (not FDataDirectoryLocks.WriteLock((DataEngine.TransLockByte-FTableID),1,
                                             DataEngine.TransLockRetries,DataEngine.TransLockWaitTime)) then
         DataEngine.RaiseError(DBISAM_TRANSLOCK,'','',ProperDataDirectoryName);
      Include(FLockStates,lsTransLocked);
      Result:=True;
      end;
end;

procedure TDataTableLocks.TransUnlock;
begin
   if (lsTransLocked in FLockStates) then
      begin
      if (not FDataDirectoryLocks.WriteUnlock((DataEngine.TransLockByte-FTableID),1)) then
         DataEngine.RaiseError(DBISAM_TRANSUNLOCK,'','',ProperDataDirectoryName);
      Exclude(FLockStates,lsTransLocked);
      end;
end;

{ TDataDirectoryLocks }

constructor TDataDirectoryLocks.Create(Owner: TDataDirectory);
begin
   FDataDirectory:=Owner;
   FLockFile:=TEngineFile.Create(Self);
   FDataTableLocksList:=TList.Create;
end;

destructor TDataDirectoryLocks.Destroy;
begin
   FreeDataTableLocks;
   FDataTableLocksList.Free;
   with FLockFile do
      begin
      CloseFile;
      Free;
      end;
   ResizeLockFileBuffer(0);
   inherited;
end;

procedure TDataDirectoryLocks.FreeDataTableLocks;
var
   I: Integer;
begin
   I:=0;
   while (I < FDataTableLocksList.Count) do
      begin
      TDataTableLocks(FDataTableLocksList[I]).Free;
      FDataTableLocksList.Delete(I);
      end;
end;

procedure TDataDirectoryLocks.ResizeLockFileBuffer(Value: Integer);
begin
   ResizeBuffer(Value,FLockFileBuffer,FLockFileBufferSize);
end;

function TDataDirectoryLocks.GetProperDataDirectoryName: string;
begin
   Result:=FDataDirectory.ProperDataDirectoryName;
end;

procedure TDataDirectoryLocks.Open;
var
   CurRetryCount: Word;
begin
   with FLockFile do
      begin
      FileName:=FDataDirectory.Directory+DataEngine.LockFileName;
      InMemory:=FDataDirectory.InMemory;
      Hidden:=True;
      if (not Exists) then
         begin
         try
            Exclusive:=True;
            CreateFile;
            try
               FUpdateCount:=0;
               PopulateDataTables;
               WriteDataTables;
            finally
               CloseFile;
            end;
         except
            { If there's a problem creating the file then just
              set the data directory to read-only for now and proceed
              with the open }
            Self.FReadOnly:=True;
         end;
         end;
      Exclusive:=False;
      if Exists then
         begin
         { If the file exists then keep trying to open it for a
           given number of retries - OS functions handle read-only
           issues and the only other reason for not being able
           to open the file would be that it's being created }
         CurRetryCount:=0;
         while Exists and (CurRetryCount <= FILE_OPEN_RETRIES) do
            begin
            try
               OpenFile;
               Self.FReadOnly:=MarkedReadOnly;
               { If there are no tables recorded then read them now }
               if (FDataTableLocksList.Count=0) then
                  begin
                  ReadLockFile;
                  try
                     ReadDataTables;
                  finally
                     ReadUnlockFile;
                  end;
                  end;
               Break;
            except
            end;
            Inc(CurRetryCount);
            Sleep(FILE_OPEN_WAIT);
            end;
         if (not IsOpen) then
            Self.FReadOnly:=True;
         end
      else
         Self.FReadOnly:=True;
      end;
end;

procedure TDataDirectoryLocks.CheckTableLimit;
begin
   if (FDataTableLocksList.Count >= MAX_NUM_TABLES) then
      DataEngine.RaiseError(DBISAM_DATABASEFULL,'','',ProperDataDirectoryName);
end;

procedure TDataDirectoryLocks.PopulateDataTables;
var
   I: Integer;
   TempDataTableLocks: TDataTableLocks;
   TempStrings: TStrings;
begin
   FreeDataTableLocks;
   TempStrings:=TStringList.Create;
   try
      FDataDirectory.ListTableNames(TempStrings);
      for I:=0 to TempStrings.Count-1 do
         begin
         TempDataTableLocks:=TDataTableLocks.Create(Self);
         FDataTableLocksList.Add(TempDataTableLocks);
         with TempDataTableLocks do
            begin
            TableID:=FDataTableLocksList.Count;
            TableName:=TempStrings[I];
            end;
         end;
   finally
      TempStrings.Free;
   end;
end;

procedure TDataDirectoryLocks.ReadLockFile;
begin
   if (not ReadLock(FLockSlot,(DataEngine.FileLockByte-DataEngine.FileLockRange),
                    FILE_LOCK_RETRIES,FILE_LOCK_WAIT)) then
      DataEngine.RaiseError(DBISAM_LOCKREADLOCK,'','',ProperDataDirectoryName);
end;

procedure TDataDirectoryLocks.ReadUnlockFile;
begin
   if (not ReadUnlock(FLockSlot,(DataEngine.FileLockByte-DataEngine.FileLockRange))) then
      DataEngine.RaiseError(DBISAM_LOCKREADUNLOCK,'','',ProperDataDirectoryName);
end;

procedure TDataDirectoryLocks.ReadDataTables;
var
   TempUpdateCount: Integer;
   TempSize: Integer;
   TempOffset: Integer;
   TempDataTableLocks: TDataTableLocks;
   I: Integer;
begin
   if FReadOnly then
      Exit;
   with FLockFile do
      begin
      LockFile;
      try
         Seek(0,FROM_BOF);
         Read(TempUpdateCount,SizeOf(Integer),False);
         if (TempUpdateCount <> FUpdateCount) then
            begin
            FUpdateCount:=TempUpdateCount;
            Read(TempSize,SizeOf(Integer),False);
            ResizeLockFileBuffer(TempSize-SizeOf(Integer));
            try
               Read(FLockFileBuffer^,(TempSize-SizeOf(Integer)),False);
               TempOffset:=0;
               I:=1;
               while (TempOffset < (TempSize-SizeOf(Integer))) do
                  begin
                  if (I > FDataTableLocksList.Count) then
                     begin
                     TempDataTableLocks:=TDataTableLocks.Create(Self);
                     FDataTableLocksList.Add(TempDataTableLocks);
                     with TempDataTableLocks do
                        begin
                        TableID:=I;
                        Read(FLockFileBuffer+TempOffset);
                        end;
                     end
                  else
                     TempDataTableLocks:=FDataTableLocksList[I-1];
                  Inc(TempOffset,(SizeOf(Byte)+Length(TempDataTableLocks.TableName)));
                  Inc(I);
                  end;
            finally
               ResizeLockFileBuffer(0);
            end;
            end;
      finally
         UnlockFile;
      end;
      end;
end;

procedure TDataDirectoryLocks.WriteDataTables;
var
   I: Integer;
   TempSize: Integer;
   TempOffset: Integer;
   TempDataTableLocks: TDataTableLocks;
begin
   if FReadOnly then
      Exit;
   with FLockFile do
      begin
      LockFile;
      try
         FUpdateCount:=WrapIncInteger(FUpdateCount);
         Seek(0,FROM_BOF);
         Write(FUpdateCount,SizeOf(Integer));
         { Calculate the size of the data }
         TempSize:=SizeOf(Integer);
         for I:=0 to FDataTableLocksList.Count-1 do
            Inc(TempSize,SizeOf(Byte)+
                         Length(TDataTableLocks(FDataTableLocksList[I]).TableName));
         ResizeLockFileBuffer(TempSize);
         try
            { Put the table data in the buffer }
            pInteger(FLockFileBuffer)^:=TempSize;
            TempOffset:=SizeOf(Integer);
            for I:=0 to FDataTableLocksList.Count-1 do
               begin
               TempDataTableLocks:=TDataTableLocks(FDataTableLocksList[I]);
               with TempDataTableLocks do
                  begin
                  Write(FLockFileBuffer+TempOffset);
                  Inc(TempOffset,(SizeOf(Byte)+Length(TableName)));
                  end;
               end;
            { Write it out }
            Write(FLockFileBuffer^,TempSize);
            Flush;
         finally
            ResizeLockFileBuffer(0);
         end;
      finally
         UnlockFile;
      end;
      end;
end;

procedure TDataDirectoryLocks.WriteLockFile;
begin
   if (not WriteLock((DataEngine.FileLockByte-DataEngine.FileLockRange),
                      DataEngine.FileLockRange,FILE_LOCK_RETRIES,FILE_LOCK_WAIT)) then
      DataEngine.RaiseError(DBISAM_LOCKWRITELOCK,'','',ProperDataDirectoryName);
end;

procedure TDataDirectoryLocks.WriteUnlockFile;
begin
   if (not WriteUnlock((DataEngine.FileLockByte-DataEngine.FileLockRange),
                        DataEngine.FileLockRange)) then
      DataEngine.RaiseError(DBISAM_LOCKWRITEUNLOCK,'','',ProperDataDirectoryName);
end;

function TDataDirectoryLocks.FindDataTable(const TableName: string): Integer;
var
   I: Integer;
begin
   Result:=-1;
   for I:=0 to FDataTableLocksList.Count-1 do
      begin
      if (OSCompareFileNames(TDataTableLocks(FDataTableLocksList[I]).TableName,
                             TableName)=0) then
         begin
         Result:=I;
         Break;
         end;
      end;
end;

function TDataDirectoryLocks.AddDataTable(const TableName: string): TDataTableLocks;
var
   TempPos: Integer;
begin
   WriteLockFile;
   try
      ReadDataTables;
      TempPos:=FindDataTable(TableName);
      if (TempPos <> -1) then
         Result:=FDataTableLocksList[TempPos]
      else
         begin
         CheckTableLimit;
         Result:=TDataTableLocks.Create(Self);
         FDataTableLocksList.Add(Result);
         Result.TableID:=FDataTableLocksList.Count;
         Result.TableName:=TableName;
         WriteDataTables;
         end;
   finally
      WriteUnlockFile;
   end;
end;

function TDataDirectoryLocks.ReadLock(var LockSlot: Word;
                                      BeginByte: Int64;
                                      Retries: Word; WaitTime: Word): Boolean;
var
   CurRetryCount: Word;
begin
   Result:=True;
   CurRetryCount:=0;
   LockSlot:=Random(High(Word));
   LockSlot:=MaximumWord(1,LockSlot);
   if FReadOnly then
      Exit;
   while (not FLockFile.LockRegion((BeginByte+LockSlot-1),1,True)) do
      begin
      Inc(CurRetryCount);
      if (CurRetryCount > Retries) then
         begin
         Result:=False;
         Exit;
         end;
      LockSlot:=Random(High(Word));
      LockSlot:=MaximumWord(1,LockSlot);
      Sleep(WaitTime);
      end;
end;

function TDataDirectoryLocks.ReadUnlock(LockSlot: Word;
                                        BeginByte: Int64): Boolean;
begin
   Result:=True;
   if FReadOnly then
      Exit;
   if (not FLockFile.LockRegion((BeginByte+LockSlot-1),1,False)) then
      begin
      Result:=False;
      Exit;
      end;
end;

function TDataDirectoryLocks.WriteLock(BeginByte: Int64; Range: Int64;
                                       Retries: Word; WaitTime: Word): Boolean;
var
   CurRetryCount: Word;
begin
   Result:=True;
   if FReadOnly then
      Exit;
   CurRetryCount:=0;
   while (not FLockFile.LockRegion(BeginByte,Range,True)) do
      begin
      Inc(CurRetryCount);
      if (CurRetryCount > Retries) then
         begin
         Result:=False;
         Exit;
         end;
      Sleep(WaitTime);
      end;
end;

function TDataDirectoryLocks.WriteUnlock(BeginByte: Int64; Range: Int64): Boolean;
begin
   Result:=True;
   if FReadOnly then
      Exit;
   { Unlock the entire read lock range }
   if (not FLockFile.LockRegion(BeginByte,Range,False)) then
      begin
      Result:=False;
      Exit;
      end;
end;

procedure TDataDirectoryLocks.TransLockDataDirectory;
var
   I: Integer;
begin
   if (not WriteLock((DataEngine.TransLockByte-DataEngine.TransLockRange),DataEngine.TransLockRange,
                      DataEngine.TransLockRetries,DataEngine.TransLockWaitTime)) then
      DataEngine.RaiseError(DBISAM_TRANSLOCK,'','',ProperDataDirectoryName);
   for I:=0 to FDataTableLocksList.Count-1 do
      begin
      with TDataTableLocks(FDataTableLocksList[I]) do
         Include(FLockStates,lsTransLocked);
      end;
end;

procedure TDataDirectoryLocks.TransUnlockDataDirectory;
var
   I: Integer;
begin
   if (not WriteUnlock((DataEngine.TransLockByte-DataEngine.TransLockRange),DataEngine.TransLockRange)) then
      DataEngine.RaiseError(DBISAM_TRANSUNLOCK,'','',ProperDataDirectoryName);
   for I:=FDataTableLocksList.Count-1 downto 0 do
      begin
      with TDataTableLocks(FDataTableLocksList[I]) do
         Exclude(FLockStates,lsTransLocked);
      end;
end;

procedure TDataDirectoryLocks.TransWriteLockDataDirectory;
var
   I: Integer;
begin
   if (not WriteLock((DataEngine.WriteLockByte-DataEngine.TransWriteLockRange),DataEngine.TransWriteLockRange,
                      DataEngine.WriteLockRetries,DataEngine.WriteLockWaitTime)) then
      DataEngine.RaiseError(DBISAM_TRANSLOCK,'','',ProperDataDirectoryName);
   for I:=0 to FDataTableLocksList.Count-1 do
      begin
      with TDataTableLocks(FDataTableLocksList[I]) do
         Include(FLockStates,lsWriteLocked);
      end;
end;

procedure TDataDirectoryLocks.TransWriteUnlockDataDirectory;
var
   I: Integer;
begin
   if (not WriteUnlock((DataEngine.WriteLockByte-DataEngine.TransWriteLockRange),DataEngine.TransWriteLockRange)) then
      DataEngine.RaiseError(DBISAM_TRANSUNLOCK,'','',ProperDataDirectoryName);
   for I:=FDataTableLocksList.Count-1 downto 0 do
      begin
      with TDataTableLocks(FDataTableLocksList[I]) do
         Exclude(FLockStates,lsWriteLocked);
      end;
end;

{ TDataDirectory }

constructor TDataDirectory.Create(Owner: TDataSession; const NewName: string;
                                  const NewDirectory: string);
begin
   inherited Create;
   FDataSession:=Owner;
   FName:=GetLeft(NewName,MAX_DATABASENAME_SIZE);
   FDirectory:=NewDirectory;
   if (not IsRemote) then
      begin
      FLocks:=TDataDirectoryLocks.Create(Self);
      FLocks.Open;
      FReadOnly:=FLocks.ReadOnly;
      end;
   FDataTableList:=TList.Create;
   FTransactionDataTableList:=TList.Create;
   FQueryStatementList:=TList.Create;
   FDataCursorList:=TList.Create;
end;

destructor TDataDirectory.Destroy;
begin
   if (not IsRemote) then
      RollbackTransaction(False);
   if (FQueryStatementList <> nil) then
      begin
      FreeQueryStatements;
      FQueryStatementList.Free;
      FQueryStatementList:=nil;
      end;
   if (FDataCursorList <> nil) then
      begin
      FreeDataCursors;
      FDataCursorList.Free;
      FDataCursorList:=nil;
      end;
   if (FTransactionDataTableList <> nil) then
      begin
      FTransactionDataTableList.Free;
      FTransactionDataTableList:=nil;
      end;
   if (FDataTableList <> nil) then
      begin
      FreeDataTables;
      FDataTableList.Free;
      FDataTableList:=nil;
      end;
   if (not IsRemote) then
      FLocks.Free;
   if (FCallbackDatabaseObject <> nil) then
      begin
      FCallbackDatabaseObject.Free;
      FCallbackDatabaseObject:=nil;
      end;
   inherited Destroy;
end;

procedure TDataDirectory.FreeDataTables;
var
   I: Integer;
begin
   I:=0;
   while (I < FDataTableList.Count) do
      begin
      TDataTable(FDataTableList[I]).Free;
      FDataTableList.Delete(I);
      end;
end;

procedure TDataDirectory.FreeDataCursors;
var
   I: Integer;
begin
   I:=0;
   while (I < FDataCursorList.Count) do
      TDataCursor(FDataCursorList[I]).Free;
end;

procedure TDataDirectory.FreeQueryStatements;
var
   I: Integer;
begin
   I:=0;
   while (I < FQueryStatementList.Count) do
      TQueryStatement(FQueryStatementList[I]).Free;
end;

procedure TDataDirectory.AddDataCursor(Cursor: TObject);
begin
   FDataCursorList.Add(Cursor);
end;

procedure TDataDirectory.RemoveDataCursor(Cursor: TObject);
var
   I: Integer;
begin
   I:=FDataCursorList.IndexOf(Cursor);
   if (I <> -1) then
      FDataCursorList.Delete(I);
end;

procedure TDataDirectory.AddQueryStatement(Statement: TObject);
begin
   FQueryStatementList.Add(Statement);
end;

procedure TDataDirectory.RemoveQueryStatement(Statement: TObject);
var
   I: Integer;
begin
   I:=FQueryStatementList.IndexOf(Statement);
   if (I <> -1) then
      FQueryStatementList.Delete(I);
end;

procedure TDataDirectory.CheckCallbacks(NewClientData: Integer);
var
   I: Integer;
begin
   if Assigned(FSteppedProgressCallback) then
      FSteppedProgressClientData:=NewClientData;
   for I:=0 to FDataCursorList.Count-1 do
      TDataCursor(FDataCursorList[I]).CheckCallbacks(NewClientData);
   for I:=0 to FQueryStatementList.Count-1 do
      TQueryStatement(FQueryStatementList[I]).CheckCallbacks(NewClientData);
end;

function TDataDirectory.GetProperDataDirectoryName: string;
begin
   if IsRemote or FDataSession.IsServer then
      Result:=FName
   else
      Result:=RemoveBS(FDirectory);
end;

function TDataDirectory.GetInMemory: Boolean;
begin
   Result:=(AnsiCompareText(INMEMORY_DATABASE_NAME,FName)=0);
end;

procedure TDataDirectory.SetRequestCode(Value: Word);
begin
   FDataSession.SetRequestCode(Value);
end;

procedure TDataDirectory.Send;
begin
   FDataSession.Send;
end;

procedure TDataDirectory.SendReceive;
var
   Reconnected: Boolean;
begin
   Reconnected:=False;
   while True do
      begin
      try
         Send;
         Receive;
         Break;
      except
         on E: Exception do
            begin
            if (not Reconnected) then
               begin
               FDataSession.HandleReconnect;
               Reconnected:=True;
               end
            else
               raise;
            end;
      end;
      end;
end;

procedure TDataDirectory.Receive;
var
   TempCallbackType: Word;
   TempPercentDone: Word;
   TempLogMessage: string;
   TempStep: string;
begin
   while True do
      begin
      FDataSession.Receive(TempCallbackType);
      if (FDataSession.GetResultCode=DBISAM_REMOTECALLBACK) then
         begin
         case TempCallbackType of
            CALLBACK_STEPPEDPROGRESS:
               begin
               TempStep[0]:=Char(Byte(Unpack(TempStep[1])));
               Unpack(TempPercentDone);
               DoSteppedProgress(TempStep,TempPercentDone);
               end;
            CALLBACK_LOG:
               begin
               TempLogMessage[0]:=Char(Byte(Unpack(TempLogMessage[1])));
               DoLog(TempLogMessage);
               end;
            else
               Break;
            end;
         end
      else
         Break;
      end;
end;

procedure TDataDirectory.StartRemoteRequest;
begin
   FDataSession.StartRemoteRequest;
end;

procedure TDataDirectory.EndRemoteRequest;
begin
   FDataSession.EndRemoteRequest;
end;

procedure TDataDirectory.BeginPack;
begin
   FDataSession.BeginPack;
end;

procedure TDataDirectory.Pack(const Buffer; BufferSize: Integer);
begin
   FDataSession.Pack(Buffer,BufferSize);
end;

procedure TDataDirectory.EndPack;
begin
   FDataSession.EndPack;
end;

function TDataDirectory.Unpack(var Buffer): Integer;
begin
   Result:=FDataSession.Unpack(Buffer);
end;

function TDataDirectory.GetIsRemote: Boolean;
begin
   Result:=FDataSession.IsRemote;
end;

function TDataDirectory.GetIsEncrypted: Boolean;
begin
   Result:=FDataSession.IsEncrypted;
end;

function TDataDirectory.GetConnected: Boolean;
begin
   Result:=FDataSession.Connected;
end;

procedure TDataDirectory.CheckForConnection;
begin
   FDataSession.CheckForConnection;
end;

procedure TDataDirectory.CheckForException;
begin
   FDataSession.CheckForException;
end;

procedure TDataDirectory.IncUseCount;
begin
   Inc(FUseCount);
end;

procedure TDataDirectory.DecUseCount;
begin
   if (FUseCount > 0) then
      Dec(FUseCount);
end;

procedure TDataDirectory.ListTableNames(TableNameList: TStrings;
                                        PartialDirectory: Boolean=False);
var
   I: Integer;
   TotalTables: Integer;
   TempString: string;
begin
   TableNameList.Clear;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETTABLENAMES);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(TotalTables);
         for I:=1 to TotalTables do
            begin
            TempString[0]:=Char(Byte(Unpack(TempString[1])));
            TableNameList.Add(TempString);
            end;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      { Version 5 }
      if PartialDirectory then
         DataEngine.GetFileNames(InMemory,AddBS(RemoveBS(FDirectory)+'*')+'*'+
                                 DataEngine.DataExtension,False,TableNameList)
      else
         DataEngine.GetFileNames(InMemory,FDirectory+'*'+
                                 DataEngine.DataExtension,False,TableNameList);
      { Version 5 }
      end;
end;

function TDataDirectory.GetHasOpenTables: Boolean;
begin
   Result:=(FDataTableList.Count > 0);
end;

function TDataDirectory.FindDataTable(const Value: string;
                                      var IndexPos: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   IndexPos:=0;
   if (FDataTableList.Count=0) then
      Exit;
   CompareResult:=CMP_EQUAL;
   Low:=0;
   High:=(FDataTableList.Count-1);
   while (Low <= High) do
      begin
      IndexPos:=((Low+High) div 2);
      CompareResult:=CompareDataTables(FDataTableList[IndexPos],Value);
      case CompareResult of
         CMP_GREATER: High:=(IndexPos-1);
         CMP_LESS: Low:=(IndexPos+1);
         CMP_EQUAL:
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
   { Adjust the buffer index for proper insertion }
   if (CompareResult=CMP_LESS) then
      begin
      if (IndexPos < FDataTableList.Count) then
         Inc(IndexPos);
      end;
end;

function TDataDirectory.CreateDataTable(const NewTableName: string;
                                        NewLocaleID: Integer;
                                        NewUserMajorVersion: Word;
                                        NewUserMinorVersion: Word;
                                        NewEncrypted: Boolean;
                                        NewPassword: string;
                                        NewDescription: string;
                                        NewIndexPageSize: Integer;
                                        NewBlobBlockSize: Integer;
                                        NewLastAutoIncID: Integer;
                                        NumberOfFields: Word;
                                        const FieldDefinitions: array of pFieldDefinition;
                                        NumberOfIndexes: Byte;
                                        const IndexDefinitions: array of pIndexDefinition;
                                        IsTemporary: Boolean): TDataTable;
var
   TempPos: Integer;
begin
   CheckNotReadOnly(NewTableName);
   if FindDataTable(NewTableName,TempPos) then
      begin
      Result:=TDataTable(FDataTableList[TempPos]);
      with Result do
         begin
         if (UseCount > 0) or InTransaction then
            DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,
                                    NewTableName)
         else
            begin
            Exclusive:=True;
            Temporary:=IsTemporary;
            CreateTable(NewLocaleID,
                        NewUserMajorVersion,NewUserMinorVersion,
                        NewEncrypted,NewPassword,
                        NewDescription,
                        NewIndexPageSize,NewBlobBlockSize,
                        NewLastAutoIncID,
                        NumberOfFields,FieldDefinitions,
                        NumberOfIndexes,IndexDefinitions);
            end;
         end;
      end
   else
      begin
      Result:=TDataTable.Create(Self);
      with Result do
         begin
         TableName:=NewTableName;
         Exclusive:=True;
         Temporary:=IsTemporary;
         end;
      try
         Result.CreateTable(NewLocaleID,
                            NewUserMajorVersion,NewUserMinorVersion,
                            NewEncrypted,NewPassword,
                            NewDescription,
                            NewIndexPageSize,NewBlobBlockSize,
                            NewLastAutoIncID,
                            NumberOfFields,FieldDefinitions,
                            NumberOfIndexes,IndexDefinitions);
         FDataTableList.Insert(TempPos,Result);
      except
         Result.Free;
         raise;
      end;
      end;
end;

function TDataDirectory.OpenDataTable(const ExistingTableName: string;
                                      const ExistingErrorTableName: string;
                                      IsExclusive: Boolean; IsTemporary: Boolean;
                                      IsResultSet: Boolean; IsSourceTable: Boolean;
                                      IsSystemOpen: Boolean; DoHeaderChecks: Boolean=True): TDataTable;
var
   TempPos: Integer;
begin
   if FindDataTable(ExistingTableName,TempPos) then
      begin
      Result:=TDataTable(FDataTableList[TempPos]);
      with Result do
         begin
         { Don't actually do anything if the table already
           exists and this is a system open (restricted transaction)
           since the result would be nothing anyways since system
           opens don't increment the usage count }
         if (not IsSystemOpen) then
            begin
            if (UseCount > 0) or InTransaction or FKeepTablesOpen then
               begin
               if (((not Exclusive) and (not IsExclusive)) or
                  ((UseCount=0) and InTransaction)) then
                  begin
                  OpenTable(False,DoHeaderChecks);
                  if (not (IsResultSet or IsSourceTable)) or
                     (IsResultSet and IsSourceTable) then
                     IncClientUseCount;
                  end
               else
                  DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,
                                          ExistingTableName);
               end
            else
               begin
               Exclusive:=IsExclusive;
               Temporary:=IsTemporary;
               OpenTable(False,DoHeaderChecks);
               if (not (IsResultSet or IsSourceTable)) or
                  (IsResultSet and IsSourceTable) then
                  IncClientUseCount;
               if Self.InTransaction and (not Self.RestrictedTransaction) and
                  (not IsResultSet) then
                  StartTransaction;
               end;
            end;
         end;
      end
   else
      begin
      Result:=TDataTable.Create(Self);
      with Result do
         begin
         TableName:=ExistingTableName;
         ErrorTableName:=ExistingErrorTableName;
         Exclusive:=IsExclusive;
         Temporary:=IsTemporary;
         ReadOnly:=Self.ReadOnly;
         end;
      try
         with Result do
            begin
            OpenTable(IsSystemOpen,DoHeaderChecks);
            if (not IsSystemOpen) and
               ((not (IsResultSet or IsSourceTable)) or
                (IsResultSet and IsSourceTable)) then
               IncClientUseCount;
            if Self.InTransaction and (not Self.RestrictedTransaction) and
               (not IsResultSet) then
               StartTransaction;
            end;
         FDataTableList.Insert(TempPos,Result);
      except
         Result.Free;
         raise;
      end;
      end;
end;

procedure TDataDirectory.CloseDataTable(ExistingDataTable: TDataTable;
                                        FreeIfTemporary: Boolean;
                                        IsResultSet: Boolean;
                                        IsSourceTable: Boolean;
                                        IsSystemOpen: Boolean);
var
   TempPos: Integer;
begin
   TempPos:=FDataTableList.IndexOf(ExistingDataTable);
   if (TempPos <> -1) then
      begin
      with ExistingDataTable do
         begin
         { Version 5 }
         if (not IsSystemOpen) then
            begin
            if (UseCount > 0) then
               CloseTable(FreeIfTemporary,False);
            { Only free the table if not in a transaction or KeepTablesOpen=True
              and the current table is *not* open exclusively }
            if (UseCount=0) and
               (not (InTransaction or (FKeepTablesOpen and (not Exclusive)))) then
               begin
               Free;
               FDataTableList.Delete(TempPos);
               end
            else
               begin
               if (not (IsResultSet or IsSourceTable)) or
                  (IsResultSet and IsSourceTable) then
                  DecClientUseCount;
               end;
            end
         else
            begin
            CloseTable(FreeIfTemporary,True);
            if (UseCount=0) then
               begin
               Free;
               FDataTableList.Delete(TempPos);
               end;
            end;
         { Version 5 }
         end;
      end
   else
      DataEngine.RaiseError(DBISAM_OSENOENT,'','',ProperDataDirectoryName,
                            ExistingDataTable.ErrorTableName);
end;

procedure TDataDirectory.RenameDataTable(const ExistingTableName: string;
                                         NewDataDirectory: TDataDirectory;
                                         const NewTableName: string;
                                         BackupExtensions: Boolean);
var
   TempDataTable: TDataTable;
   TempPos: Integer;
begin
   CheckNotReadOnly(ExistingTableName);
   if FindDataTable(ExistingTableName,TempPos) then
      begin
      TempDataTable:=TDataTable(FDataTableList[TempPos]);
      with TempDataTable do
         begin
         if (UseCount=0) then
            begin
            { Handle case of tables being held open }
            if FKeepTablesOpen then
               begin
               FKeepTablesOpen:=False;
               try
                  CloseTable(True,False);
               finally
                  FKeepTablesOpen:=True;
               end;
               end;
            RenameTable(NewDataDirectory,NewTableName,BackupExtensions);
            FDataTableList.Delete(TempPos);
            FindDataTable(NewTableName,TempPos);
            FDataTableList.Insert(TempPos,TempDataTable);
            end
         else
            DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,
                                  ExistingTableName);
         end;
      end
   else
      begin
      TempDataTable:=TDataTable.Create(Self);
      try
         with TempDataTable do
            begin
            TableName:=ExistingTableName;
            RenameTable(NewDataDirectory,NewTableName,BackupExtensions);
            end;
      finally
         TempDataTable.Free;
      end;
      end;
end;

procedure TDataDirectory.DeleteDataTable(const ExistingTableName: string);
var
   TempDataTable: TDataTable;
   TempPos: Integer;
begin
   CheckNotReadOnly(ExistingTableName);
   if FindDataTable(ExistingTableName,TempPos) then
      begin
      TempDataTable:=TDataTable(FDataTableList[TempPos]);
      with TempDataTable do
         begin
         if (UseCount=0) then
            begin
            { Handle case of tables being held open }
            if FKeepTablesOpen then
               begin
               FKeepTablesOpen:=False;
               try
                  CloseTable(True,False);
               finally
                  FKeepTablesOpen:=True;
               end;
               end;
            DeleteTable;
            Free;
            FDataTableList.Delete(TempPos);
            end
         else
            DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,
                                  ExistingTableName);
         end;
      end
   else
      begin
      TempDataTable:=TDataTable.Create(Self);
      try
         with TempDataTable do
            begin
            TableName:=ExistingTableName;
            DeleteTable;
            end;
      finally
         TempDataTable.Free;
      end;
      end;
end;

function TDataDirectory.DataTableExists(const SearchTableName: string;
                                        OpenOnly: Boolean;
                                        IsTemporary: Boolean): Boolean;
var
   TempPos: Integer;
   TempTableName: string;
begin
   if IsTemporary then
      TempTableName:=EnsureFileExt(SearchTableName,DataEngine.DataExtension,
                                   DataEngine.DataTempExtension)
   else
      TempTableName:=EnsureFileExt(SearchTableName,DataEngine.DataExtension,
                                   DataEngine.DataExtension);
   Result:=FindDataTable(TempTableName,TempPos);
   if (not Result) and (not OpenOnly) then
      begin
      { Don't worry about temporary tables, since they aren't created remotely }
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_TABLEEXISTS);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(SearchTableName[1],Length(SearchTableName));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(Result);
         finally
            EndRemoteRequest;
         end;
         end
      else
         Result:=DataEngine.FileExists(FDirectory+TempTableName,
                                       InMemory,False);
      end;
end;

function TDataDirectory.GetTempDataTableName: string;
var
   I: Word;
   ThreadID: string;
begin
   Result:='';
   I:=0;
   ThreadID:=Substr(IntToStr(Abs(OSGetThreadID)),1,5);
   while DataTableExists(ThreadID+IntToStr(I)+DataEngine.DataExtension,False,True) do
      Inc(I);
   Result:=ThreadID+IntToStr(I)+DataEngine.DataExtension;
end;

procedure TDataDirectory.CheckNotReadOnly(const TableName: string);
begin
   if FReadOnly then
      DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,TableName);
end;

procedure TDataDirectory.CheckTransaction;
begin
   if FInTransaction then
      CommitTransaction(True,True,False);
end;

procedure TDataDirectory.StartTransaction(NoRemoteCall: Boolean;
                                          TablesList: TStrings);
var
   I: Integer;
   J: Integer;
   TempTableCount: Integer;
   TempTableName: string;
begin
   if (FReadOnly or FInTransaction) then
      Exit;
   if IsRemote and (not NoRemoteCall) then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_STARTTRANS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         if (RemoteEngineVersion >= 4.06) then
            begin
            if (TablesList <> nil) then
               begin
               TempTableCount:=TablesList.Count;
               Pack(TempTableCount,SizeOf(Integer));
               for I:=0 to TempTableCount-1 do
                  begin
                  TempTableName:=TablesList[I];
                  Pack(TempTableName[1],Length(TempTableName));
                  end;
               end
            else
               begin
               TempTableCount:=0;
               Pack(TempTableCount,SizeOf(Integer));
               end;
            end;
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
   if (TablesList <> nil) and (TablesList.Count > 0) then
      begin
      FRestrictedTransaction:=True;
      { Open up any tables that need opened so that they
        can be locked during the start of the transaction } 
      for I:=0 to TablesList.Count-1 do
         begin
         if (not DataTableExists(TablesList[I],True,False)) then
            OpenDataTable(TablesList[I],TablesList[I],False,False,False,False,True);
         end;
      try
         { Sort the open data tables by TableID to ensure
           that the locking proceeds in the same order for
           each client, regardless of which tables are specified }
         with FTransactionDataTableList do
            begin
            Clear;
            for I:=0 to FDataTableList.Count-1 do
               begin
               for J:=0 to TablesList.Count-1 do
                  begin
                  { Only start transaction on tables specified }
                  if (OSCompareFileNames(GetLeft(StripFilePathAndExtension(TablesList[J],
                                                 DataEngine.DataExtension),
                                                 MAX_TABLENAME_SIZE),TDataTable(FDataTableList[I]).TableName)=0) then
                     Add(FDataTableList[I]);
                  end;
               end;
            Sort(CompareDataTableIDs);
            for I:=0 to Count-1 do
               TDataTable(Items[I]).StartTransaction;
            end;
         FInTransaction:=True;
      except
         { Unlock in reverse order }
         for I:=FTransactionDataTableList.Count-1 downto 0 do
            TDataTable(FTransactionDataTableList[I]).RollbackTransaction;
         FInTransaction:=False;
         raise;
      end;
      end
   else
      begin
      FRestrictedTransaction:=False;
      if (not IsRemote) then
         FLocks.TransLockDataDirectory;
      try
         for I:=0 to FDataTableList.Count-1 do
            TDataTable(FDataTableList[I]).StartTransaction;
         FInTransaction:=True;
      except
         for I:=0 to FDataTableList.Count-1 do
            TDataTable(FDataTableList[I]).RollbackTransaction;
         if (not IsRemote) then
            FLocks.TransUnlockDataDirectory;
         FInTransaction:=False;
         raise;
      end;
      end;
end;

procedure TDataDirectory.CommitTransaction(ForceFlush: Boolean;
                                           ReleaseLocks: Boolean;
                                           NoRemoteCall: Boolean);
var
   I: Integer;
begin
   if (FReadOnly or (not FInTransaction)) then
      Exit;
   if IsRemote and (not NoRemoteCall) then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_COMMITTRANS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(ReleaseLocks,SizeOf(Boolean));
         Pack(ForceFlush,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
   if FRestrictedTransaction then
      begin
      for I:=FTransactionDataTableList.Count-1 downto 0 do
         TDataTable(FTransactionDataTableList[I]).CommitTransaction(ForceFlush,ReleaseLocks);
      end
   else
      begin
      if (not IsRemote) then
         FLocks.TransWriteLockDataDirectory;
      try
         for I:=FDataTableList.Count-1 downto 0 do
            TDataTable(FDataTableList[I]).CommitTransaction(ForceFlush,ReleaseLocks);
      finally
         if (not IsRemote) then
            FLocks.TransWriteUnlockDataDirectory;
      end;
      if ReleaseLocks then
         begin
         if (not IsRemote) then
            FLocks.TransUnlockDataDirectory;
         end;
      end;
   if ReleaseLocks then
      begin
      FInTransaction:=False;
      CloseUnusedDataTables;
      end;
end;

procedure TDataDirectory.RollbackTransaction(NoRemoteCall: Boolean);
var
   I: Integer;
begin
   if (FReadOnly or (not FInTransaction)) then
      Exit;
   if IsRemote and (not NoRemoteCall) then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ROLLBACKTRANS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
   if FRestrictedTransaction then
      begin
      for I:=FTransactionDataTableList.Count-1 downto 0 do
         TDataTable(FTransactionDataTableList[I]).RollbackTransaction;
      end
   else
      begin
      for I:=FDataTableList.Count-1 downto 0 do
         TDataTable(FDataTableList[I]).RollbackTransaction;
      if (not IsRemote) then
         FLocks.TransUnlockDataDirectory;
      end;
   FInTransaction:=False;
   CloseUnusedDataTables;
end;

procedure TDataDirectory.CloseUnusedDataTables;
var
   I: Integer;
   TempDataTable: TDataTable;
begin
   for I:=FDataTableList.Count-1 downto 0 do
      begin
      TempDataTable:=TDataTable(FDataTableList[I]);
      if (TempDataTable.UseCount=0) then
         CloseDataTable(TempDataTable,True,False,False,False);
      end;
end;

function TDataDirectory.GetProgressPercent: Word;
begin
   Result:=FDataSession.ProgressPercent;
end;

function TDataDirectory.GetRemoteEngineVersion: Currency;
begin
   Result:=FDataSession.RemoteEngineVersion;
end;

{ Version 5 }
function TDataDirectory.GetRemoteEngineBuildNumber: Integer;
begin
   Result:=FDataSession.RemoteEngineBuildNumber;
end;
{ Version 5 }

function TDataDirectory.Backup(const BackupName: string;
                               const BackupDescription: string;
                               Compression: Byte;
                               BackupTables: TStrings;
                               SendProgress: Boolean;
                               SendLog: Boolean): Boolean;
var
   TempEngineFile: TEngineFile;
   TempDataTable: TDataTable;
   I: Integer;
   TempFileCount: Integer;
   TempFileName: string;
   TempBlobCount: Integer;
   TempFileSize: Int64;
   TempDateTime: TDateTime;
   TempVersionNum: Currency;
begin
   CheckTransaction;
   Result:=False;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_BACKUP);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(BackupName[1],Length(BackupName));
         Pack(BackupDescription[1],Length(BackupDescription));
         Pack(Compression,SizeOf(Byte));
         TempFileCount:=BackupTables.Count;
         Pack(TempFileCount,SizeOf(Integer));
         for I:=0 to TempFileCount-1 do
            Pack(BackupTables[I][1],Length(BackupTables[I]));
         Pack(SendProgress,SizeOf(Boolean));
         Pack(SendLog,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      DoLog('Backup of database '+ProperDataDirectoryName+' started at '+DateTimeToStr(Now));
      try
         FLocks.TransLockDataDirectory;
         try
            TempEngineFile:=TEngineFile.Create(Self);
            try
               with TempEngineFile do
                  begin
                  FileName:=BackupName;
                  Exclusive:=True;
                  CreateFile;
                  end;
               DoLog('Backup file '+BackupName+' created');
               try
                  try
                     with TempEngineFile do
                        begin
                        Write(DataEngine.SignatureDigest,SizeOf(TMD5Digest));
                        TempVersionNum:=ENGINE_VERSION_NUM;
                        Write(TempVersionNum,SizeOf(Currency));
                        TempDateTime:=Now;
                        Write(TempDateTime,SizeOf(TDateTime));
                        Write(BackupDescription[0],SizeOf(Byte));
                        Write(BackupDescription[1],Length(BackupDescription));
                        TempFileCount:=BackupTables.Count;
                        TempEngineFile.Write(TempFileCount,SizeOf(Integer));
                        end;
                     for I:=0 to TempFileCount-1 do
                        begin
                        TempFileName:=StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension);
                        with TempEngineFile do
                           begin
                           Write(TempFileName[0],SizeOf(Byte));
                           Write(TempFileName[1],Length(TempFileName));
                           end;
                        end;
                     for I:=0 to TempFileCount-1 do
                        begin
                        DoLog('Starting backup of table '+
                              StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension));
                        TempDataTable:=OpenDataTable(BackupTables[I],BackupTables[I],
                                                     False,False,False,False,False,True);
                        try
                           TempBlobCount:=TempDataTable.DataFile.BlobFieldCount;
                           with TempEngineFile do
                              begin
                              TempFileName:=ExtractFileName(TempDataTable.DataFile.FileName);
                              Write(TempFileName[0],SizeOf(Byte));
                              Write(TempFileName[1],Length(TempFileName));
                              Write(TempBlobCount,SizeOf(Integer));
                              TempFileSize:=TempDataTable.DataFile.FileSize;
                              Write(TempFileSize,SizeOf(Int64));
                              end;
                           DoLog('Backing up table '+
                                 StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension)+
                                 ' (data) '+IntToStr(TempFileSize)+' bytes');
                           TempDataTable.DataFile.CopyTo(TempEngineFile,
                                                         Compression,
                                                         Integer(Self),
                                                         @TDataDirectory.DoSteppedProgress,
                                                         ProgressPercent);
                           with TempEngineFile do
                              begin
                              TempFileName:=ExtractFileName(TempDataTable.IndexFile.FileName);
                              Write(TempFileName[0],SizeOf(Byte));
                              Write(TempFileName[1],Length(TempFileName));
                              TempFileSize:=TempDataTable.IndexFile.FileSize;
                              Write(TempFileSize,SizeOf(Int64));
                              end;
                           DoLog('Backing up table '+
                                 StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension)+
                                 ' (index) '+IntToStr(TempFileSize)+' bytes');
                           TempDataTable.IndexFile.CopyTo(TempEngineFile,
                                                          Compression,
                                                          Integer(Self),
                                                          @TDataDirectory.DoSteppedProgress,
                                                          ProgressPercent);
                           if (TempBlobCount > 0) then
                              begin
                              with TempEngineFile do
                                 begin
                                 TempFileName:=ExtractFileName(TempDataTable.BlobFile.FileName);
                                 Write(TempFileName[0],SizeOf(Byte));
                                 Write(TempFileName[1],Length(TempFileName));
                                 TempFileSize:=TempDataTable.BlobFile.FileSize;
                                 Write(TempFileSize,SizeOf(Int64));
                                 end;
                              DoLog('Backing up table '+
                                    StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension)+
                                    ' (BLOBs) '+IntToStr(TempFileSize)+' bytes');
                              TempDataTable.BlobFile.CopyTo(TempEngineFile,
                                                            Compression,
                                                            Integer(Self),
                                                            @TDataDirectory.DoSteppedProgress,
                                                            ProgressPercent);
                              end;
                           DoLog('Backup of table '+
                                 StripFilePathAndExtension(BackupTables[I],DataEngine.DataExtension)+
                                 ' completed');
                        finally
                           CloseDataTable(TempDataTable,False,False,False,False);
                        end;
                        end;
                  finally
                     TempEngineFile.CloseFile;
                  end;
               except
                  TempEngineFile.DeleteFile;
                  raise;
               end;
            finally
               TempEngineFile.Free;
            end;
            DoLog('Backup of database '+ProperDataDirectoryName+' completed at '+DateTimeToStr(Now));
            Result:=True;
         finally
            FLocks.TransUnlockDataDirectory;
         end;
      except
         on E: Exception do
            DoLog('Error during backup of database '+ProperDataDirectoryName+' - '+E.Message);
      end;
      end;
end;

function TDataDirectory.BackupInfo(const BackupName: string;
                                   var BackupDescription: string;
                                   var BackupDateTime: TDateTime;
                                   BackupTables: TStrings): Boolean;
var
   TempSourceEngineFile: TEngineFile;
   TempDestEngineFile: TEngineFile;
   TempSignature: TMD5Digest;
   I: Integer;
   TempFileCount: Integer;
   TempFileName: string;
   TempVersionNum: Currency;
begin
   Result:=False;
   BackupTables.Clear;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_BACKUPINFO);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(BackupName[1],Length(BackupName));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         BackupDescription[0]:=Char(Byte(Unpack(BackupDescription[1])));
         Unpack(BackupDateTime);
         Unpack(TempFileCount);
         for I:=1 to TempFileCount do
            begin
            TempFileName[0]:=Char(Byte(Unpack(TempFileName[1])));
            BackupTables.Add(TempFileName);
            end;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      try
         TempSourceEngineFile:=TEngineFile.Create(Self);
         TempDestEngineFile:=TEngineFile.Create(Self);
         try
            with TempSourceEngineFile do
               begin
               FileName:=BackupName;
               Exclusive:=True;
               OpenFile;
               end;
            try
               with TempSourceEngineFile do
                  begin
                  Read(TempSignature,SizeOf(TMD5Digest),False);
                  if (not MD5DigestCompare(TempSignature,DataEngine.SignatureDigest)) and
                     (not MD5DigestCompare(TempSignature,MD5String(DBISAM_SIGNATURE))) then
                     DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                                           BackupName);
                  Read(TempVersionNum,SizeOf(Currency),False);
                  Read(BackupDateTime,SizeOf(TDateTime),False);
                  Read(BackupDescription[0],SizeOf(Byte),False);
                  Read(BackupDescription[1],Length(BackupDescription),False);
                  Read(TempFileCount,SizeOf(Integer),False);
                  end;
               for I:=1 to TempFileCount do
                  begin
                  with TempSourceEngineFile do
                     begin
                     Read(TempFileName[0],SizeOf(Byte),False);
                     Read(TempFileName[1],Length(TempFileName),False);
                     end;
                  BackupTables.Add(TempFileName);
                  end;
               Result:=True;
            finally
               TempSourceEngineFile.CloseFile;
            end;
         finally
            TempDestEngineFile.Free;
            TempSourceEngineFile.Free;
         end;
      except
         { suppress any exceptions }
      end;
      end;
end;

function TDataDirectory.Restore(const BackupName: string;
                                BackupTables: TStrings;
                                SendProgress: Boolean;
                                SendLog: Boolean): Boolean;
var
   TempSourceEngineFile: TEngineFile;
   TempDestEngineFile: TEngineFile;
   TempSignature: TMD5Digest;
   I: Integer;
   J: Integer;
   TempFileCount: Integer;
   TempDateTime: TDateTime;
   TempDescription: string;
   TempFileName: string;
   TempBlobCount: Integer;
   TempFileSize: Int64;
   TempVersionNum: Currency;
   TablePos: Integer;
begin
   CheckTransaction;
   Result:=False;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_RESTORE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(BackupName[1],Length(BackupName));
         TempFileCount:=BackupTables.Count;
         Pack(TempFileCount,SizeOf(Integer));
         for I:=0 to TempFileCount-1 do
            Pack(BackupTables[I][1],Length(BackupTables[I]));
         Pack(SendProgress,SizeOf(Boolean));
         Pack(SendLog,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      DoLog('Restore of database '+ProperDataDirectoryName+' started at '+DateTimeToStr(Now));
      try
         FLocks.TransLockDataDirectory;
         try
            TempSourceEngineFile:=TEngineFile.Create(Self);
            TempDestEngineFile:=TEngineFile.Create(Self);
            try
               with TempSourceEngineFile do
                  begin
                  FileName:=BackupName;
                  Exclusive:=True;
                  OpenFile;
                  end;
               DoLog('Backup file '+BackupName+' read');
               try
                  FLocks.TransWriteLockDataDirectory;
                  try
                     with TempSourceEngineFile do
                        begin
                        Read(TempSignature,SizeOf(TMD5Digest),False);
                        if (not MD5DigestCompare(TempSignature,DataEngine.SignatureDigest)) and
                           (not MD5DigestCompare(TempSignature,MD5String(DBISAM_SIGNATURE))) then
                           DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                                                 BackupName);
                        Read(TempVersionNum,SizeOf(Currency),False);
                        Read(TempDateTime,SizeOf(TDateTime),False);
                        Read(TempDescription[0],SizeOf(Byte),False);
                        Read(TempDescription[1],Length(TempDescription),False);
                        Read(TempFileCount,SizeOf(Integer),False);
                        end;
                     for I:=1 to TempFileCount do
                        begin
                        with TempSourceEngineFile do
                           begin
                           Read(TempFileName[0],SizeOf(Byte),False);
                           Read(TempFileName[1],Length(TempFileName),False);
                           end;
                        end;
                     for I:=1 to TempFileCount do
                        begin
                        with TempSourceEngineFile do
                           begin
                           Read(TempFileName[0],SizeOf(Byte),False);
                           Read(TempFileName[1],Length(TempFileName),False);
                           Read(TempBlobCount,SizeOf(Integer),False);
                           Read(TempFileSize,SizeOf(Int64),False);
                           end;
                        TablePos:=-1;
                        for J:=0 to BackupTables.Count-1 do
                           begin
                           if (OSCompareFileNames(StripFilePathAndExtension(BackupTables[J],DataEngine.DataExtension),
                                                  StripFilePathAndExtension(TempFileName,DataEngine.DataExtension))=0) then
                              begin
                              TablePos:=J;
                              Break;
                              end;
                           end;
                        if (TablePos <> -1) then
                           begin
                           DoLog('Starting restore of table '+
                                 StripFilePathAndExtension(BackupTables[TablePos],DataEngine.DataExtension));
                           with TempDestEngineFile do
                              begin
                              FileName:=AddBS(FDirectory)+TempFileName;
                              Exclusive:=True;
                              InMemory:=Self.InMemory;
                              CreateFile;
                              end;
                           try
                              DoLog('Restoring table '+
                                    StripFilePathAndExtension(BackupTables[TablePos],DataEngine.DataExtension)+
                                    ' (data) '+IntToStr(TempFileSize)+' bytes');
                              TempDestEngineFile.CopyFrom(TempSourceEngineFile,
                                                          TempFileSize,
                                                          Integer(Self),
                                                          @TDataDirectory.DoSteppedProgress,
                                                          ProgressPercent);
                           finally
                              TempDestEngineFile.CloseFile;
                           end;
                           with TempSourceEngineFile do
                              begin
                              Read(TempFileName[0],SizeOf(Byte),False);
                              Read(TempFileName[1],Length(TempFileName),False);
                              Read(TempFileSize,SizeOf(Int64),False);
                              end;
                           with TempDestEngineFile do
                              begin
                              FileName:=AddBS(FDirectory)+TempFileName;
                              Exclusive:=True;
                              InMemory:=Self.InMemory;
                              CreateFile;
                              end;
                           try
                              DoLog('Restoring table '+
                                    StripFilePathAndExtension(BackupTables[TablePos],DataEngine.DataExtension)+
                                    ' (indexes) '+IntToStr(TempFileSize)+' bytes');
                              TempDestEngineFile.CopyFrom(TempSourceEngineFile,
                                                          TempFileSize,
                                                          Integer(Self),
                                                          @TDataDirectory.DoSteppedProgress,
                                                          ProgressPercent);
                           finally
                              TempDestEngineFile.CloseFile;
                           end;
                           if (TempBlobCount > 0) then
                              begin
                              with TempSourceEngineFile do
                                 begin
                                 Read(TempFileName[0],SizeOf(Byte),False);
                                 Read(TempFileName[1],Length(TempFileName),False);
                                 Read(TempFileSize,SizeOf(Int64),False);
                                 end;
                              with TempDestEngineFile do
                                 begin
                                 FileName:=AddBS(FDirectory)+TempFileName;
                                 Exclusive:=True;
                                 InMemory:=Self.InMemory;
                                 CreateFile;
                                 end;
                              try
                                 DoLog('Restoring table '+
                                       StripFilePathAndExtension(BackupTables[TablePos],DataEngine.DataExtension)+
                                       ' (BLOBs) '+IntToStr(TempFileSize)+' bytes');
                                 TempDestEngineFile.CopyFrom(TempSourceEngineFile,
                                                             TempFileSize,
                                                             Integer(Self),
                                                             @TDataDirectory.DoSteppedProgress,
                                                             ProgressPercent);
                              finally
                                 TempDestEngineFile.CloseFile;
                              end;
                              end;
                           DoLog('Restore of table '+
                                 StripFilePathAndExtension(BackupTables[TablePos],DataEngine.DataExtension)+
                                 ' completed');
                           end
                        else
                           begin
                           TempDestEngineFile.SkipFrom(TempSourceEngineFile,
                                                       TempFileSize);
                           with TempSourceEngineFile do
                              begin
                              Read(TempFileName[0],SizeOf(Byte),False);
                              Read(TempFileName[1],Length(TempFileName),False);
                              Read(TempFileSize,SizeOf(Int64),False);
                              end;
                           TempDestEngineFile.SkipFrom(TempSourceEngineFile,
                                                       TempFileSize);
                           if (TempBlobCount > 0) then
                              begin
                              with TempSourceEngineFile do
                                 begin
                                 Read(TempFileName[0],SizeOf(Byte),False);
                                 Read(TempFileName[1],Length(TempFileName),False);
                                 Read(TempFileSize,SizeOf(Int64),False);
                                 end;
                              TempDestEngineFile.SkipFrom(TempSourceEngineFile,
                                                          TempFileSize);
                              end;
                           end;
                        end;
                  finally
                     FLocks.TransWriteUnlockDataDirectory;
                  end;
               finally
                  TempSourceEngineFile.CloseFile;
               end;
            finally
               TempDestEngineFile.Free;
               TempSourceEngineFile.Free;
            end;
            DoLog('Restore of database '+ProperDataDirectoryName+' completed at '+DateTimeToStr(Now));
            Result:=True;
         finally
            FLocks.TransUnlockDataDirectory;
         end;
      except
         on E: Exception do
            DoLog('Error during restore of database '+ProperDataDirectoryName+' - '+E.Message);
      end;
      end;
end;

procedure TDataDirectory.SetSteppedProgressCallback(ClientData: Integer;
                                                     SteppedProgressCallback: pSteppedProgressCallback);
begin
   FSteppedProgressClientData:=ClientData;
   FSteppedProgressCallback:=pSteppedProgressCallback(@SteppedProgressCallback);
end;

procedure TDataDirectory.SetLogCallback(ClientData: Integer;
                                              LogCallback: pLogCallback);
begin
   FLogClientData:=ClientData;
   FLogCallback:=pLogCallback(@LogCallback);
end;

procedure TDataDirectory.DoSteppedProgress(const Step: string;
                                           PercentDone: Word);
var
   TempString: string;
begin
   if Assigned(FSteppedProgressCallback) then
      begin
      if IsRemote then
         FSteppedProgressCallback(FSteppedProgressClientData,
                                  Step,PercentDone)
      else
         begin
         TempString:=ExtractFileName(Step);
         if (OSCompareFileNames(ExtractFileExt(TempString),DataEngine.DataExtension)=0) then
            FSteppedProgressCallback(FSteppedProgressClientData,
                                    ExtractFileRoot(TempString,DataEngine.DataExtension)+' (data)',PercentDone)
         else if (OSCompareFileNames(ExtractFileExt(TempString),DataEngine.IndexExtension)=0) then
            FSteppedProgressCallback(FSteppedProgressClientData,
                                    ExtractFileRoot(TempString,DataEngine.IndexExtension)+' (indexes)',PercentDone)
         else if (OSCompareFileNames(ExtractFileExt(TempString),DataEngine.BlobExtension)=0) then
            FSteppedProgressCallback(FSteppedProgressClientData,
                                    ExtractFileRoot(TempString,DataEngine.BlobExtension)+' (BLOBs)',PercentDone);
         end;
      end;
end;

procedure TDataDirectory.DoLog(const LogMessage: string);
begin
   if Assigned(FLogCallback) then
      FLogCallback(FLogClientData,LogMessage);
end;

{ TDataTable }

constructor TDataTable.Create(Owner: TDataDirectory);
begin
   FDataDirectory:=Owner;
   FDataPassword:=TDataPassword.Create(DataSession);
   FRecordLocks:=TRecordsBitmap.Create;
   FRecordLocks.NumOfBits:=DEFAULT_RECORD_LOCK_BUFFER_COUNT;
   FTransactionRecordLocks:=TRecordsBitmap.Create;
   FTransactionRecordLocks.NumOfBits:=DEFAULT_RECORD_LOCK_BUFFER_COUNT;
   FSemaphoreLocks:=TRecordsBitmap.Create;
   FSemaphoreLocks.NumOfBits:=DataEngine.SemaphoreLockRange;
   FDataFile:=TDataFile.Create(Self);
   FIndexFile:=TIndexFile.Create(Self);
   FBlobFile:=TBlobFile.Create(Self);
end;

destructor TDataTable.Destroy;
begin
   CloseTable(True,False);
   FBlobFile.Free;
   FIndexFile.Free;
   FDataFile.Free;
   FSemaphoreLocks.Free;
   FTransactionRecordLocks.Free;
   FRecordLocks.Free;
   FDataPassword.Free;
   inherited Destroy;
end;

function TDataTable.GetProperTableName: string;
begin
   if (FErrorTableName <> '') then
      Result:=FErrorTableName
   else
      Result:=FTableName;
end;

function TDataTable.GetDataSession: TDataSession;
begin
   Result:=FDataDirectory.DataSession;
end;

function TDataTable.Unpack(var Buffer): Integer;
begin
   Result:=DataSession.Unpack(Buffer);
end;

function TDataTable.GetIsRemote: Boolean;
begin
   Result:=DataSession.IsRemote;
end;

function TDataTable.GetConnected: Boolean;
begin
   Result:=DataSession.Connected;
end;

function TDataTable.GetProperDataDirectoryName: string;
begin
   Result:=FDataDirectory.ProperDataDirectoryName;
end;

procedure TDataTable.IncUseCount;
begin
   Inc(FUseCount);
end;

procedure TDataTable.DecUseCount;
begin
   if (FUseCount > 0) then
      Dec(FUseCount);
end;

procedure TDataTable.IncClientUseCount;
begin
   Inc(FClientUseCount);
end;

procedure TDataTable.DecClientUseCount;
begin
   if (FClientUseCount > 0) then
      Dec(FClientUseCount);
end;

procedure TDataTable.UnpackStaticTableInfo;
begin
   Unpack(FReadOnly);
   Unpack(FMarkedReadOnly);
   if (not FReadOnly) and FMarkedReadOnly then
      FReadOnly:=True;
   FDataFile.UnpackStaticTableInfo;
   FIndexFile.UnpackStaticTableInfo;
   FBlobFile.UnpackStaticTableInfo;
end;

procedure TDataTable.UnpackVariableTableInfo;
begin
   FDataFile.UnpackVariableTableInfo;
end;

procedure TDataTable.LocalUnpackVariableTableInfo(DataCursor: TDataCursor);
begin
   FDataFile.LocalUnpackVariableTableInfo(DataCursor);
end;

procedure TDataTable.AssignTableParams(UseTemporaryFlag: Boolean);
begin
   with FDataFile do
      begin
      if Self.Temporary then
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.DataTempExtension)
      else
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.DataExtension);
      Exclusive:=Self.Exclusive;
      ReadOnly:=Self.ReadOnly;
      InMemory:=Self.DataDirectory.InMemory;
      if UseTemporaryFlag then
         Temporary:=Self.Temporary
      else
         Temporary:=False;
      end;
   with FIndexFile do
      begin
      if Self.Temporary then
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.IndexTempExtension)
      else
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.IndexExtension);
      Exclusive:=Self.Exclusive;
      ReadOnly:=Self.ReadOnly;
      InMemory:=Self.DataDirectory.InMemory;
      if UseTemporaryFlag then
         Temporary:=Self.Temporary
      else
         Temporary:=False;
      end;
   with FBlobFile do
      begin
      if Self.Temporary then
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.BlobTempExtension)
      else
         FileName:=FDataDirectory.Directory+EnsureFileExt(FTableName,
                           DataEngine.DataExtension,DataEngine.BlobExtension);
      Exclusive:=Self.Exclusive;
      ReadOnly:=Self.ReadOnly;
      InMemory:=Self.DataDirectory.InMemory;
      if UseTemporaryFlag then
         Temporary:=Self.Temporary
      else
         Temporary:=False;
      end;
end;

procedure TDataTable.OpenTable(SystemOpen: Boolean;
                               DoHeaderChecks: Boolean=True);
var
   TempCode: Word;
begin
   if (not SystemOpen) then
      IncUseCount;
   if FIsOpen then
      Exit;
   try
      if IsRemote then
         FIsOpen:=True
      else
         begin
         FMissingIndex:=False;
         FIsOpen:=True;
         AssignTableParams(True);
         FDataFile.OpenFile;

         { Allow opening of a table with a missing index, and if it's missing just
           create it }
         try
            FIndexFile.OpenFile;
         except
            on E: Exception do
               begin
               TempCode:=DataEngine.ConvertExceptionToCode(E);
               { Version 5 }
               if (TempCode=DBISAM_OSENOENT) or
                  (TempCode=DBISAM_READERR) then
               { Version 5 }
                  begin
                  FMissingIndex:=True;
                  with FIndexFile do
                     begin
                     CloseFile;
                     CreateFile;
                     WriteHeader(True);
                     WriteIndexes(True);
                     CloseFile;
                     OpenFile;
                     end;
                  end
               else
                  raise;
               end;
         end;

         if (FDataFile.BlobFieldCount > 0) then
            FBlobFile.OpenFile;

         { Be sure to handle the OS read-only file permissions }
         FReadOnly:=(FDataFile.ReadOnly or FIndexFile.ReadOnly or
                     FBlobFile.ReadOnly);

         { Be sure to handle the OS read-only file attribute flags }
         FMarkedReadOnly:=(FDataFile.MarkedReadOnly or FIndexFile.MarkedReadOnly or
                           FBlobFile.MarkedReadOnly);

         if (not FReadOnly) and FMarkedReadOnly then
            FReadOnly:=True;

         { Now add the data table to the lock file and get the locks
           object, but only if the table is not opened exclusively }
         if (not (FExclusive or FMarkedReadOnly)) then
            begin
            FDataTableLocks:=FDataDirectory.Locks.AddDataTable(FTableName);
            end
         else
            FDataTableLocks:=nil;

         { Version 5 }
         if (FDataTableLocks <> nil) then
            FDataTableLocks.ReadLock;
         try
            ReadHeaders;
            if DoHeaderChecks then
               CheckHeaders;
         finally
            if (FDataTableLocks <> nil) then
               FDataTableLocks.ReadUnlock;
         end;
         { Version 5 }
         end;

   except
      CloseTable(True,SystemOpen);
      raise;
   end;
end;

{ Version 5 }
procedure TDataTable.CloseTable(FreeIfTemporary: Boolean;
                                SystemOpen: Boolean);
{ Version 5 }
begin
   if (not FIsOpen) then
      Exit;
   { Version 5 }
   if (not SystemOpen) then
      DecUseCount;
   if FInTransaction or
      (FDataDirectory.KeepTablesOpen and (not (FExclusive or SystemOpen))) then
      Exit;
   { Version 5 }
   if (FUseCount=0) then
      begin
      try
         RollbackTransaction;
      except
      end;
      if IsRemote then
         UnlockAll(False)
      else
         begin
         if FExclusive and (not FReadOnly) then
            begin
            if FTemporary and FreeIfTemporary then
               FreeBuffers(True,False,False)
            else
               FlushBuffers(True,False,False,False,False);
            end;
         UnlockAll(False);
         UnlockAllSemaphores;
         ReadUnlockTable;
         WriteUnlockTable;
         if FIndexFile.IsOpen then
            FIndexFile.CloseFile;
         if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
            FBlobFile.CloseFile;
         if FDataFile.IsOpen then
            FDataFile.CloseFile;
         FMissingIndex:=False;
         FWrittenTo:=False;
         end;
      FIsOpen:=False;
      end;
end;

procedure TDataTable.CreateTable(NewLocaleID: Integer;
                                 NewUserMajorVersion: Word;
                                 NewUserMinorVersion: Word;
                                 NewEncrypted: Boolean;
                                 NewPassword: string;
                                 NewDescription: string;
                                 NewIndexPageSize: Integer;
                                 NewBlobBlockSize: Integer;
                                 NewLastAutoIncID: Integer;
                                 NumberOfFields: Word;
                                 const FieldDefinitions: array of pFieldDefinition;
                                 NumberOfIndexes: Byte;
                                 const IndexDefinitions: array of pIndexDefinition);
var
   I: Integer;
   TempDigest: TMD5Digest;
begin
   IncUseCount;
   FIsOpen:=True;
   if (not IsRemote) then
      begin
      AssignTableParams(False);
      try
         with FDataFile do
            begin
            CreateFile;
            { Handle default last autoinc value }
            if (NewLastAutoIncID = -1) then
               NewLastAutoIncID:=0;
            if NewEncrypted then
               begin
               DataSession.AddPassword(NewPassword);
               TempDigest:=GetDigestForPassword(NewPassword);
               end
            else
               FillChar(TempDigest,SizeOf(TMD5Digest),#0);
            UpdateHeader(NewLocaleID,
                         NewUserMajorVersion,NewUserMinorVersion,
                         NewEncrypted,TempDigest,
                         NewDescription,
                         NewIndexPageSize,NewBlobBlockSize,
                         NewLastAutoIncID);
            AddFields(NumberOfFields,FieldDefinitions);
            WriteHeader(True);
            WriteFields;
            end;
         with FIndexFile do
            begin
            CreateFile;
            for I:=0 to NumberOfIndexes do
               begin
               if (I=0) then
                  AddPrimaryIndex(IndexDefinitions[I])
               else
                  AddSecondaryIndex(IndexDefinitions[I]);
               end;
            SetIndexDefinition(TEXT_INDEX_POS,IndexDefinitions[TEXT_INDEX_POS]);
            WriteHeader(True);
            WriteIndexes(True);
            end;
         if (FDataFile.BlobFieldCount > 0) then
            begin
            with FBlobFile do
               begin
               CreateFile;
               WriteHeader(True);
               end;
            end;
      except
         with FDataFile do
            begin
            if Exists then
               begin
               CloseFile;
               DeleteFile;
               end;
            end;
         with FIndexFile do
            begin
            if Exists then
               begin
               CloseFile;
               DeleteFile;
               end;
            end;
         with FBlobFile do
            begin
            if Exists then
               begin
               CloseFile;
               DeleteFile;
               end;
            end;
         raise;
      end;
      end;
end;

procedure TDataTable.DeleteTable;
begin
   if (not IsRemote) then
      begin
      AssignTableParams(True);
      FDataFile.DeleteFile;
      FIndexFile.DeleteFile;
      with FBlobFile do
         begin
         if Exists then
            DeleteFile;
         end;
      end;
end;

procedure TDataTable.RenameTable(NewDataDirectory: TDataDirectory;
                                 const NewTableName: string; BackupExtensions: Boolean);
var
   TempName: string;
begin
   if (not IsRemote) then
      begin
      AssignTableParams(True);
      TempName:=NewDataDirectory.Directory+
                ExtractFileRoot(ExtractFileName(NewTableName),DataEngine.DataExtension);
      with FDataFile do
         begin
         if BackupExtensions then
            begin
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.DataBackupExtension);
            if DataEngine.FileExists(TempName,NewDataDirectory.InMemory,False) then
               DataEngine.DeleteFile(TempName,NewDataDirectory.InMemory);
            end
         else
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.DataExtension);
         if Exists then
            RenameFile(TempName);
         end;
      TempName:=NewDataDirectory.Directory+
                ExtractFileRoot(ExtractFileName(NewTableName),DataEngine.DataExtension);
      with FIndexFile do
         begin
         if BackupExtensions then
            begin
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.IndexBackupExtension);
            if DataEngine.FileExists(TempName,NewDataDirectory.InMemory,False) then
               DataEngine.DeleteFile(TempName,NewDataDirectory.InMemory);
            end
         else
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.IndexExtension);
         if Exists then
            RenameFile(TempName);
         end;
      TempName:=NewDataDirectory.Directory+
                ExtractFileRoot(ExtractFileName(NewTableName),DataEngine.DataExtension);
      with FBlobFile do
         begin
         if BackupExtensions then
            begin
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.BlobBackupExtension);
            if DataEngine.FileExists(TempName,NewDataDirectory.InMemory,False) then
               DataEngine.DeleteFile(TempName,NewDataDirectory.InMemory);
            end
         else
            TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                                    DataEngine.BlobExtension);
         if Exists then
            RenameFile(TempName);
         end;
      end;
end;

procedure TDataTable.EmptyTable;
begin
   ClearHeaders;
   FreeBuffers(True,False,False);
end;

procedure TDataTable.EmptyIndex;
begin
   with FIndexFile do
      begin
      ClearHeader;
      FreeBuffers;
      end;
end;

procedure TDataTable.InternalBackupIndex(TempDataDirectory: TDataDirectory);
var
   TempName: string;
begin
   FlushBuffers(False,False,False,False,False);
   TempName:=TempDataDirectory.Directory+FTableName;
   TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                           DataEngine.IndexBackupExtension);
   FIndexFile.CopyToFile(TempName,0,0,nil,0);
end;

procedure TDataTable.InternalRestoreIndex(TempDataDirectory: TDataDirectory;
                                          RemoveOnly: Boolean; RemoveBackup: Boolean);
var
   TempName: string;
   NewTempName: string;
   NewEngineFile: TEngineFile;
begin
   TempName:=TempDataDirectory.Directory+FTableName;
   TempName:=EnsureFileExt(TempName,DataEngine.DataExtension,
                           DataEngine.IndexBackupExtension);
   if (not RemoveOnly) then
      FIndexFile.CopyFromFile(TempName,0,nil,0);
   if RemoveBackup then
      begin
      if DataEngine.FileExists(TempName,TempDataDirectory.InMemory,False) then
         DataEngine.DeleteFile(TempName,TempDataDirectory.InMemory);
      end
   else
      begin
      if (TempDataDirectory <> FDataDirectory) then
         begin
         NewEngineFile:=TEngineFile.Create(Self);
         try
            with NewEngineFile do
               begin
               NewTempName:=FDataDirectory.Directory+FTableName;
               NewTempName:=EnsureFileExt(NewTempName,DataEngine.DataExtension,
                                          DataEngine.IndexBackupExtension);
               InMemory:=TempDataDirectory.InMemory;
               Exclusive:=True;
               FileName:=TempName;
               if Exists then
                  begin
                  OpenFile;
                  try
                     CopyToFile(NewTempName,0,0,nil,0);
                  finally
                     CloseFile;
                     DeleteFile;
                  end;
                  end;                  
               end;
         finally
            NewEngineFile.Free;
         end;
         end;
      end;
end;

function TDataTable.PerformChangeDetection: Boolean;
begin
   Result:=False;
   { Version 5 }
   if FDataFile.CheckForChanges then
      begin
      Result:=True;
      FDataFile.FreeBuffers;
      FIndexFile.ReadHeader;
      FIndexFile.FreeBuffers;
      if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
         begin
         FBlobFile.ReadHeader;
         FBlobFile.FreeBuffers;
         end;
      end;
   { Version 5 }
end;

function TDataTable.CheckForRecordLock(RecordNum: Integer): Boolean;
begin
   if (RecordNum <= FRecordLocks.NumOfBits) then
      Result:=FRecordLocks.IsBitSet(RecordNum)
   else
      Result:=False;
end;

function TDataTable.CheckForTransactionRecordLock(RecordNum: Integer): Boolean;
begin
   if (RecordNum <= FTransactionRecordLocks.NumOfBits) then
      Result:=FTransactionRecordLocks.IsBitSet(RecordNum)
   else
      Result:=False;
end;

function TDataTable.LockRecord(RecordToLock: Integer): Boolean;
var
   CurRetryCount: Byte;
begin
   Result:=False;
   if (not (FTableLock or FTransactionTableLock)) then
      begin
      if (RecordToLock=0) or CheckForRecordLock(RecordToLock) then
         DataEngine.RaiseError(DBISAM_RECLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
      if (not CheckForTransactionRecordLock(RecordToLock)) then
         begin
         if (not IsRemote) then
            begin
            if (not DataSession.StrictChangeDetection) then
               Result:=ReadLockTable;
            CurRetryCount:=0;
            while (not FDataFile.LockRecord(RecordToLock)) do
               begin
               ReadUnlockTable;
               Inc(CurRetryCount);
               if (CurRetryCount > DataSession.LockRetries) then
                  DataEngine.RaiseError(DBISAM_RECLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
               Sleep(DataSession.LockWait);
               if (not Result) then
                  Result:=ReadLockTable
               else
                  ReadLockTable;
               end;
            end;
         end;
      with FRecordLocks do
         begin
         if (RecordToLock > NumOfBits) then
            NumOfBits:=RecordToLock;
         SetBit(RecordToLock);
         end;
      with FTransactionRecordLocks do
         begin
         if (RecordToLock > NumOfBits) then
            NumOfBits:=RecordToLock;
         ClearBit(RecordToLock);
         end;
      end;
end;

procedure TDataTable.UnlockRecord(RecordToUnlock: Integer);
begin
   if (not (FTableLock or FTransactionTableLock)) then
      begin
      if (RecordToUnlock=0) or
         (not (CheckForRecordLock(RecordToUnlock) or
              (CheckForTransactionRecordLock(RecordToUnlock)))) then
         DataEngine.RaiseError(DBISAM_UNLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
      if FInTransaction then
         FTransactionRecordLocks.SetBit(RecordToUnlock)
      else
         begin
         if (not IsRemote) then
            begin
            if (not FDataFile.UnlockRecord(RecordToUnlock)) then
               DataEngine.RaiseError(DBISAM_UNLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
            end;
         FTransactionRecordLocks.ClearBit(RecordToUnlock);
         end;
      FRecordLocks.ClearBit(RecordToUnlock);
      end;
end;

procedure TDataTable.UnlockAll(TransactionLocks: Boolean);
var
   TempRecordNumber: Integer;
begin
   if TransactionLocks then
      begin
      with FTransactionRecordLocks do
         begin
         TempRecordNumber:=0;
         while GetNextBitsSet(TempRecordNumber,1) do
            UnlockRecord(TempRecordNumber);
         end;
      if FTransactionTableLock then
         UnlockTable;
      end
   else
      begin
      with FRecordLocks do
         begin
         TempRecordNumber:=0;
         while GetNextBitsSet(TempRecordNumber,1) do
            UnlockRecord(TempRecordNumber);
         end;
      if FTableLock then
         UnlockTable;
      end;
end;

procedure TDataTable.UnlockAllSemaphores;
var
   TempSemaphoreNumber: Integer;
begin
   with FSemaphoreLocks do
      begin
      TempSemaphoreNumber:=0;
      while GetNextBitsSet(TempSemaphoreNumber,1) do
         UnlockSemaphore(TempSemaphoreNumber);
      end;
end;

function TDataTable.LockTable: Boolean;
var
   CurRetryCount: Byte;
begin
   Result:=False;
   if FTableLock or
      (FRecordLocks.GetTotalBitsSet > 0) or (FTransactionRecordLocks.GetTotalBitsSet > 0) then
      DataEngine.RaiseError(DBISAM_LOCKED,'','',ProperDataDirectoryName,ProperTableName);
   if (not FTransactionTableLock) then
      begin
      if (not IsRemote) then
         begin
         CurRetryCount:=0;
         while (not FDataFile.LockTable) do
            begin
            Inc(CurRetryCount);
            if (CurRetryCount > DataSession.LockRetries) then
               DataEngine.RaiseError(DBISAM_LOCKED,'','',ProperDataDirectoryName,ProperTableName);
            Sleep(DataSession.LockWait);
            end;
         end;
      if (not IsRemote) then
         begin
         if (not ((lsReadLocked in FDataTableLocks.LockStates) or
                  (lsWriteLocked in FDataTableLocks.FLockStates) or
                  (lsTransLocked in FDataTableLocks.FLockStates))) then
            Result:=PerformChangeDetection;
         end;
      end;
   FTableLock:=True;
end;

procedure TDataTable.UnlockTable;
begin
   if (not (FTableLock or FTransactionTableLock)) then
      DataEngine.RaiseError(DBISAM_UNLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
   if FInTransaction then
      FTransactionTableLock:=True
   else
      begin
      if (not IsRemote) then
         begin
         if (not FDataFile.UnlockTable) then
            DataEngine.RaiseError(DBISAM_UNLOCKFAILED,'','',ProperDataDirectoryName,ProperTableName);
         end;
      FTransactionTableLock:=False;
      end;
   FTableLock:=False;
end;

function TDataTable.LockSemaphore(SemaphoreToLock: Integer): Boolean;
var
   CurRetryCount: Byte;
begin
   Result:=False;
   CurRetryCount:=0;
   if (SemaphoreToLock < 1) or (SemaphoreToLock > DataEngine.SemaphoreLockRange) then
      Exit;
   while (not FDataFile.LockSemaphore(SemaphoreToLock)) do
      begin
      Inc(CurRetryCount);
      if (CurRetryCount > DataSession.LockRetries) then
         Exit;
      Sleep(DataSession.LockWait);
      end;
   FSemaphoreLocks.SetBit(SemaphoreToLock);
   Result:=True;
end;

function TDataTable.UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
begin
   Result:=False;
   if (SemaphoreToUnlock < 1) or (SemaphoreToUnlock > DataEngine.SemaphoreLockRange) then
      Exit;
   if (not FDataFile.UnlockSemaphore(SemaphoreToUnlock)) then
      Exit;
   FSemaphoreLocks.ClearBit(SemaphoreToUnlock);
   Result:=True;
end;

function TDataTable.ReadLockTable: Boolean;
begin
   Result:=False;
   if (FDataTableLocks <> nil) and (not FTableLock) then
      begin
      if FDataTableLocks.ReadLock then
         Result:=PerformChangeDetection;
      end;
end;

procedure TDataTable.ReadUnlockTable;
begin
   if (FDataTableLocks <> nil) and (not FTableLock) then
      FDataTableLocks.ReadUnlock;
end;

function TDataTable.WriteLockTable: Boolean;
begin
   Result:=False;
   if (FDataTableLocks <> nil) and (not FTableLock) then
      begin
      if FDataTableLocks.WriteLock((not FInTransaction)) then
         Result:=PerformChangeDetection;
      end;
end;

procedure TDataTable.WriteUnlockTable;
begin
   if (FDataTableLocks <> nil) and (not FTableLock) then
      FDataTableLocks.WriteUnlock((not FInTransaction));
end;

function TDataTable.GetRecordCount: Integer;
begin
   Result:=FDataFile.RecordCount;
end;

procedure TDataTable.SetRecordCount(Value: Integer);
begin
   FDataFile.RecordCount:=Value;
end;

function TDataTable.GetFieldCount: Word;
begin
   Result:=FDataFile.FieldCount;
end;

function TDataTable.GetBlobFieldCount: Word;
begin
   Result:=FDataFile.BlobFieldCount;
end;

procedure TDataTable.IncRecordCount;
begin
   FDataFile.IncRecordCount;
end;

procedure TDataTable.DecRecordCount;
begin
   FDataFile.DecRecordCount;
end;

function TDataTable.GetIndexCount: Byte;
begin
   Result:=FIndexFile.IndexCount;
end;

procedure TDataTable.SetIndexCount(Value: Byte);
begin
   FIndexFile.IndexCount:=Value;
end;

function TDataTable.GetAutoPrimaryIndex: Boolean;
begin
   Result:=FIndexFile.AutoPrimaryIndex;
end;

function TDataTable.GetRecordSize: Word;
begin
   Result:=FDataFile.IOBlockSize;
end;

function TDataTable.GetRecordBufferSize: Word;
begin
   Result:=FDataFile.BufferSize;
end;

function TDataTable.GetBlobBlockSize: Integer;
begin
   Result:=FDataFile.BlobBlockSize;
end;

function TDataTable.GetBlobBlockBufferSize: Integer;
begin
   Result:=FBlobFile.BufferSize;
end;

function TDataTable.GetIndexPageSize: Integer;
begin
   Result:=FDataFile.IndexPageSize;
end;

function TDataTable.GetIndexPageBufferSize: Integer;
begin
   Result:=FIndexFile.BufferSize;
end;

function TDataTable.GetLocaleID: Integer;
begin
   Result:=FDataFile.LocaleID;
end;

function TDataTable.GetUserMajorVersion: Word;
begin
   Result:=FDataFile.UserMajorVersion;
end;

function TDataTable.GetUserMinorVersion: Word;
begin
   Result:=FDataFile.UserMinorVersion;
end;

function TDataTable.GetVersionNum: Byte;
begin
   Result:=FDataFile.VersionNum;
end;

function TDataTable.GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
begin
   Result:=FDataFile.GetFieldDefinitionByPos(FieldIndex);
end;

procedure TDataTable.UpdateFieldDefinitionByPos(FieldIndex: Word;
                                                Buffer: pFieldDefinition);
begin
   FDataFile.UpdateFieldDefinitionByPos(FieldIndex,Buffer);
end;

function TDataTable.GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
begin
   Result:=FDataFile.GetFieldDefinitionByNumber(FieldNum);
end;

function TDataTable.GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
begin
   Result:=FDataFile.GetFieldDefinitionByName(NameOfField);
end;

function TDataTable.GetFieldNumber(NameOfField: string): Word;
begin
   Result:=FDataFile.GetFieldNumber(NameOfField);      
end;

function TDataTable.GetIndexDefinition(CurIndexPos: Byte): pIndexDefinition;
begin
   Result:=FIndexFile.GetIndexDefinition(CurIndexPos);
end;

procedure TDataTable.SetIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
begin
   FIndexFile.SetIndexDefinition(CurIndexPos,Buffer);
end;

procedure TDataTable.UpdateIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
begin
   FIndexFile.UpdateIndexDefinition(CurIndexPos,Buffer);
end;

function TDataTable.IndexExists(const NewName: string): Boolean;
begin
   Result:=FIndexFile.IndexExists(NewName);
end;

procedure TDataTable.AddPrimaryIndex(NewIndexDefinition: pIndexDefinition);
begin
   FIndexFile.AddPrimaryIndex(NewIndexDefinition);
end;

procedure TDataTable.AddSecondaryIndex(NewIndexDefinition: pIndexDefinition);
begin
   FIndexFile.AddSecondaryIndex(NewIndexDefinition);
end;

procedure TDataTable.DeleteIndex(CurIndexPos: Byte; AdjustIndexDefinitions: Boolean);
begin
   FIndexFile.DeleteIndex(CurIndexPos,AdjustIndexDefinitions);
end;

function TDataTable.GetLastDataUpdateStamp: Integer;
begin
   Result:=FDataFile.GetLastUpdateStamp;
end;

function TDataTable.GetLastIndexUpdateStamp: Integer;
begin
   Result:=FIndexFile.GetLastUpdateStamp;
end;

function TDataTable.GetLastBlobUpdateStamp: Integer;
begin
   if (FDataFile.BlobFieldCount > 0) then
      Result:=FBlobFile.GetLastUpdateStamp
   else
      Result:=0;
end;

function TDataTable.GetDataCacheHits: Integer;
begin
   Result:=FDataFile.CacheHits;
end;

function TDataTable.GetDataCacheMisses: Integer;
begin
   Result:=FDataFile.CacheMisses;
end;

function TDataTable.GetDataReads: Integer;
begin
   Result:=FDataFile.Reads;
end;

function TDataTable.GetDataWrites: Integer;
begin
   Result:=FDataFile.Writes;
end;

function TDataTable.GetIndexCacheHits: Integer;
begin
   Result:=FIndexFile.CacheHits;
end;

function TDataTable.GetIndexCacheMisses: Integer;
begin
   Result:=FIndexFile.CacheMisses;
end;

function TDataTable.GetIndexReads: Integer;
begin
   Result:=FIndexFile.Reads;
end;

function TDataTable.GetIndexWrites: Integer;
begin
   Result:=FIndexFile.Writes;
end;

function TDataTable.GetBlobCacheHits: Integer;
begin
   Result:=FBlobFile.CacheHits;
end;

function TDataTable.GetBlobCacheMisses: Integer;
begin
   Result:=FBlobFile.CacheMisses;
end;

function TDataTable.GetBlobReads: Integer;
begin
   Result:=FBlobFile.Reads;
end;

function TDataTable.GetBlobWrites: Integer;
begin
   Result:=FBlobFile.Writes;
end;

procedure TDataTable.StartTransaction;
begin
   if (FReadOnly or FInTransaction) then
      Exit;
   if (not IsRemote) then
      begin
      if FExclusive then
         FlushBuffers(False,False,False,False,False);
      { If executing a restricted transaction, then we need
        to lock the table here }
      if FDataDirectory.RestrictedTransaction then
         begin
         if (FDataTableLocks <> nil) then
            begin
            if FDataTableLocks.TransLock then
               PerformChangeDetection;
            end;
         end
      else
         begin
         { Be sure to include the transaction lock state for
           tables that could possibly be opened mid-transaction,
           the actual physical locking is already done, however }
         if (FDataTableLocks <> nil) then
            Include(FDataTableLocks.FLockStates,lsTransLocked);
         PerformChangeDetection;
         end;
      end;
   FInTransaction:=True;
end;

procedure TDataTable.RollbackTransaction;
begin
   if (FReadOnly or (not FInTransaction)) then
      Exit;
   FInTransaction:=False;
   if (not IsRemote) then
      FreeBuffers(True,True,False);
   UnlockAll(True);
   if (not IsRemote) then
      begin
      { If executing a restricted transaction, then we need
        to unlock the table here }
      if FDataDirectory.RestrictedTransaction then
         begin
         if (FDataTableLocks <> nil) then
            FDataTableLocks.TransUnlock;
         end
      end;
end;

procedure TDataTable.CommitTransaction(ForceFlush: Boolean;
                                       ReleaseLocks: Boolean);
begin
   if (FReadOnly or (not FInTransaction)) then
      Exit;
   if ReleaseLocks then
      begin
      FInTransaction:=False;
      if (not IsRemote) then
         begin
         if FDataDirectory.RestrictedTransaction then
            begin
            { If executing a restricted transaction, then we need
              to write lock the table before flushing }
            if (FDataTableLocks <> nil) then
               FDataTableLocks.WriteLock(False);
            try
               FlushBuffers(True,False,False,False,ForceFlush);
            finally
               if (FDataTableLocks <> nil) then
                  begin
                  FDataTableLocks.WriteUnlock(False);
                  FDataTableLocks.TransUnlock;
                  end;
            end;
            end
         else
            FlushBuffers(True,False,False,False,ForceFlush);
         end;
      end
   else
      begin
      FInTransaction:=False;
      try
         if (not IsRemote) then
            begin
            if FDataDirectory.RestrictedTransaction then
               begin
               { If executing a restricted transaction, then we need
                 to write lock the table before flushing }
               if (FDataTableLocks <> nil) then
                  FDataTableLocks.WriteLock(False);
               try
                  FlushBuffers(False,False,False,False,ForceFlush);
               finally
                  if (FDataTableLocks <> nil) then
                     FDataTableLocks.WriteUnlock(False);
               end;
               end
            else
               FlushBuffers(False,False,False,False,ForceFlush);
            end;
      finally
         FInTransaction:=True;
      end;
      end;
   UnlockAll(True);
end;

function TDataTable.GetPhysicalRecordsUsed: Integer;
begin
   Result:=FDataFile.IOBlocksUsed;
end;

function TDataTable.GetPhysicalPagesUsed: Integer;
begin
   Result:=FIndexFile.IOBlocksUsed;
end;

function TDataTable.GetPhysicalBlocksUsed: Integer;
begin
   Result:=FBlobFile.IOBlocksUsed;
end;

procedure TDataTable.FlushBuffers(AdjustBuffers: Boolean;
                                  ForceDataHeader: Boolean;
                                  ForceIndexHeader: Boolean;
                                  ForceBlobHeader: Boolean;
                                  ForceOSFlush: Boolean);
var
   DataBufferResult: Boolean;
   IndexBufferResult: Boolean;
   BlobBufferResult: Boolean;
   DataHeaderResult: Boolean;
   IndexHeaderResult: Boolean;
   BlobHeaderResult: Boolean;
   FieldsResult: Boolean;
   IndexesResult: Boolean;
begin
   if FReadOnly then Exit;
   if (not FInTransaction) then
      begin
      DataHeaderResult:=False;
      IndexHeaderResult:=False;
      BlobHeaderResult:=False;
      if FDataFile.IsOpen then
         begin
         DataBufferResult:=FDataFile.FlushBuffers;
         DataHeaderResult:=FDataFile.WriteHeader((ForceDataHeader or DataBufferResult));
         FieldsResult:=FDataFile.WriteFields;
         if (DataBufferResult or DataHeaderResult or FieldsResult) then
            begin
            if ForceOSFlush or DataSession.ForceBufferFlush then
               FDataFile.Flush;
            end;
         if AdjustBuffers then
            FDataFile.AdjustBuffers;
         end;
      if FIndexFile.IsOpen then
         begin
         IndexBufferResult:=FIndexFile.FlushBuffers;
         IndexHeaderResult:=FIndexFile.WriteHeader((ForceIndexHeader or IndexBufferResult));
         IndexesResult:=FIndexFile.WriteIndexes(False);
         if (IndexBufferResult or IndexHeaderResult or IndexesResult) then
            begin
            if ForceOSFlush or DataSession.ForceBufferFlush then
               FIndexFile.Flush;
            end;
         if AdjustBuffers then
            FIndexFile.AdjustBuffers;
         end;
      if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
         begin
         BlobBufferResult:=FBlobFile.FlushBuffers;
         BlobHeaderResult:=FBlobFile.WriteHeader((ForceBlobHeader or BlobBufferResult));
         if (BlobBufferResult or BlobHeaderResult) then
            begin
            if ForceOSFlush or DataSession.ForceBufferFlush then
               FBlobFile.Flush;
            end;
         if AdjustBuffers then
            FBlobFile.AdjustBuffers;
         end;
      if FDataFile.IsOpen then
         begin
         if ((not DataHeaderResult) and
             (IndexHeaderResult or BlobHeaderResult)) then
            begin
            FDataFile.WriteHeader(True);
            if ForceOSFlush or DataSession.ForceBufferFlush then
               FDataFile.Flush;
            end;
         end;
      end
   else
      UpdateHeaderStamps(ForceDataHeader,ForceIndexHeader,ForceBlobHeader);
end;


procedure TDataTable.UpdateHeaderStamps(UpdateDataHeader: Boolean;
                                        UpdateIndexHeader: Boolean;
                                        UpdateBlobHeader: Boolean);
begin
   if FDataFile.IsOpen and UpdateDataHeader then
      FDataFile.UpdateHeaderStamp;
   if FIndexFile.IsOpen and UpdateIndexHeader then
      FIndexFile.UpdateHeaderStamp;
   if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen and
      UpdateBlobHeader then
      FBlobFile.UpdateHeaderStamp;
end;

procedure TDataTable.FreeBuffers(AdjustBuffers: Boolean; ReadHeaders: Boolean;
                                 ReadIndexes: Boolean);
begin
   if FDataFile.IsOpen then
      begin
      FDataFile.FreeBuffers;
      if AdjustBuffers then
         FDataFile.AdjustBuffers;
      if ReadHeaders then
         FDataFile.ReadHeader;
      end;
   if FIndexFile.IsOpen then
      begin
      FIndexFile.FreeBuffers;
      if AdjustBuffers then
         FIndexFile.AdjustBuffers;
      if ReadHeaders then
         FIndexFile.ReadHeader;
      if ReadIndexes then
         FIndexFile.ReadIndexes;
      end;
   if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
      begin
      FBlobFile.FreeBuffers;
      if AdjustBuffers then
         FBlobFile.AdjustBuffers;
      if ReadHeaders then
         FBlobFile.ReadHeader;
      end;
end;

procedure TDataTable.FlushOSBuffers;
begin
   if FReadOnly or DataSession.ForceBufferFlush then
      Exit;
   if FDataFile.IsOpen then
      FDataFile.Flush;
   if FIndexFile.IsOpen then
      FIndexFile.Flush;
   if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
      FBlobFile.Flush;
end;

function TDataTable.RecordIsLocked(RecordNum: Integer): Boolean;
begin
   Result:=False;
   if (RecordNum <> 0) then
      Result:=CheckForRecordLock(RecordNum);
end;

function TDataTable.TableIsLocked: Boolean;
begin
   Result:=FTableLock;
end;

function TDataTable.GetDescription: string;
begin
   Result:=FDataFile.Description;
end;

function TDataTable.GetLastUpdated: TDateTime;
begin
   Result:=FDataFile.LastUpdated;
end;

function TDataTable.GetEncrypted: Boolean;
begin
   Result:=FDataFile.Encrypted;
end;

function TDataTable.GetPassword: string;
begin
   Result:='';
   if (FDataPassword <> nil) then
      Result:=FDataPassword.Password;
end;

procedure TDataTable.VerifyDigest(Value: TMD5Digest);
var
   TempPassword: TDataPassword;
begin
   while True do
      begin
      TempPassword:=CheckForDigest(Value);
      if (TempPassword=nil) then
         begin
         if (not AskForPassword) then
            DataEngine.RaiseError(DBISAM_NOTSUFFTABLERIGHTS,'','',
                                  ProperDataDirectoryName,ProperTableName);
         end
      else
         begin
         FDataPassword.Copy(TempPassword);
         Break;
         end;
      end;
end;

function TDataTable.AskForPassword: Boolean;
begin
   Result:=DataSession.AskForPassword;
end;

function TDataTable.GetDataPassword(const Value: string): TDataPassword;
begin
   Result:=DataSession.GetDataPassword(Value);
end;

function TDataTable.CheckForDigest(Value: TMD5Digest): TDataPassword;
begin
   Result:=DataSession.CheckForDigest(Value);
end;

function TDataTable.GetDigestForPassword(const Value: string): TMD5Digest;
var
   TempPassword: TDataPassword;
begin
   FillChar(Result,SizeOf(TMD5Digest),#0);
   while True do
      begin
      TempPassword:=GetDataPassword(Value);
      if (TempPassword=nil) then
         begin
         if (not AskForPassword) then
            DataEngine.RaiseError(DBISAM_NOTSUFFTABLERIGHTS,'','',
                                  ProperDataDirectoryName,ProperTableName);
         end
      else
         begin
         FDataPassword.Copy(TempPassword);
         Break;
         end;
      end;
   Move(FDataPassword.Digest,Result,SizeOf(TMD5Digest));
   DataEngine.Encrypt(FDataPassword.Data,PChar(@Result),SizeOf(TMD5Digest));
end;

procedure TDataTable.Encrypt(Buffer: PChar; BufferSize: Integer);
begin
   DataEngine.Encrypt(FDataPassword.Data,Buffer,BufferSize);
end;

procedure TDataTable.Decrypt(Buffer: PChar; BufferSize: Integer);
begin
   DataEngine.Decrypt(FDataPassword.Data,Buffer,BufferSize);
end;

procedure TDataTable.RepairHeaders(DataCursor: TDataCursor; VerifyOnly: Boolean;
                                   var DataValid: Boolean; var IndexValid: Boolean;
                                   var BlobValid: Boolean);
begin
   DataValid:=FDataFile.RepairHeader(DataCursor,VerifyOnly);
   IndexValid:=FIndexFile.RepairHeader(DataCursor,VerifyOnly);
   if (FDataFile.BlobFieldCount > 0) then
      BlobValid:=FBlobFile.RepairHeader(DataCursor,VerifyOnly)
   else
      BlobValid:=True;
end;

{ Version 5 }
procedure TDataTable.ReadHeaders;
begin
   FDataFile.ReadHeader;
   FIndexFile.ReadHeader;
   if (FDataFile.BlobFieldCount > 0) then
      FBlobFile.ReadHeader;
end;
{ Version 5 }

procedure TDataTable.CheckHeaders;
begin
   FDataFile.CheckHeader;
   if (not FMissingIndex) then
      FIndexFile.CheckHeader;
   if (FDataFile.BlobFieldCount > 0) then
      FBlobFile.CheckHeader;
end;

procedure TDataTable.ClearIndexHeader;
begin
   FIndexFile.ClearHeader;
end;

procedure TDataTable.UpdateDataHeader(NewLocaleID: Integer;
                                      NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                      NewEncrypted: Boolean; const NewPassword: string;
                                      const NewDescription: string;
                                      NewIndexPageSize: Integer;
                                      NewBlobBlockSize: Integer;
                                      NewLastAutoIncID: Integer);
var
   TempDigest: TMD5Digest;
begin
   if NewEncrypted then
      TempDigest:=GetDigestForPassword(NewPassword)
   else
      FillChar(TempDigest,SizeOf(TMD5Digest),#0);
   FDataFile.UpdateHeader(NewLocaleID,
                          NewUserMajorVersion,NewUserMinorVersion,
                          NewEncrypted,TempDigest,
                          NewDescription,
                          NewIndexPageSize,NewBlobBlockSize,
                          NewLastAutoIncID);
end;

procedure TDataTable.GetDataHeader(var Header: TDataHeader);
begin
   FDataFile.GetHeader(Header);
end;

procedure TDataTable.GetIndexHeader(var Header: TIndexHeader);
begin
   FIndexFile.GetHeader(Header);
end;

procedure TDataTable.GetBlobHeader(var Header: TBlobHeader);
begin
   if (FDataFile.BlobFieldCount > 0) then
      FBlobFile.GetHeader(Header);
end;

procedure TDataTable.ClearHeaders;
begin
   if FDataFile.IsOpen then
      FDataFile.ClearHeader;
   if FIndexFile.IsOpen then
      FIndexFile.ClearHeader;
   if (FDataFile.BlobFieldCount > 0) and FBlobFile.IsOpen then
      FBlobFile.ClearHeader;
end;

function TDataTable.GetRootPageNumber(IndexPos: Byte): Integer;
begin
   Result:=FIndexFile.GetRootPageNumber(IndexPos);
end;

procedure TDataTable.SetRootPageNumber(IndexPos: Byte; Value: Integer);
begin
   FIndexFile.SetRootPageNumber(IndexPos,Value);
end;

function TDataTable.GetDataRootPageNumber(IndexPos: Byte): Integer;
begin
   Result:=FIndexFile.GetDataRootPageNumber(IndexPos);
end;

procedure TDataTable.SetDataRootPageNumber(IndexPos: Byte; Value: Integer);
begin
   FIndexFile.SetDataRootPageNumber(IndexPos,Value);
end;

function TDataTable.GetNextFreePageNumber: Integer;
begin
   Result:=FIndexFile.GetNextFreePageNumber;
end;

procedure TDataTable.SetNextFreePageNumber(Value: Integer);
begin
   FIndexFile.SetNextFreePageNumber(Value);
end;

function TDataTable.GetPage(DataCursor: TDataCursor; DefinitionPos: Byte;
                            PageNum: Integer; var PageToGet: TPage): Boolean;
begin
   Result:=FIndexFile.GetBuffer(DataCursor,DefinitionPos,PageNum,False,READ_CURRENT,
                                TBuffer(PageToGet));
end;

procedure TDataTable.PutPage(PageToRelease: TPage);
begin
   FIndexFile.PutBuffer(PageToRelease);
end;

function TDataTable.CreatePage(IndexPos: Byte): TPage;
begin
   Result:=TPage.Create(FIndexFile);
   Result.Initialize(IndexPos);
end;

procedure TDataTable.FreePage(var ExistingPage: TPage);
begin
   ExistingPage.Free;
end;

function TDataTable.CreateRecord: TRecord;
begin
   Result:=TRecord.Create(FDataFile);
   Result.Initialize;
end;

procedure TDataTable.FreeRecord(var ExistingRecord: TRecord);
begin
   ExistingRecord.Free;
end;

function TDataTable.GetLastRecordID: Integer;
begin
   Result:=FDataFile.GetLastRecordID;
end;

procedure TDataTable.SetLastRecordID(Value: Integer);
begin
   FDataFile.SetLastRecordID(Value);
end;

function TDataTable.GetNextRecordID: Integer;
begin
   Result:=FDataFile.GetNextRecordID;
end;

function TDataTable.GetLastAutoIncID: Integer;
begin
   Result:=FDataFile.GetLastAutoIncID;
end;

procedure TDataTable.SetLastAutoIncID(Value: Integer);
begin
   FDataFile.SetLastAutoIncID(Value);
end;

procedure TDataTable.SetLastBlobSignature(Value: Integer);
begin
   FDataFile.SetLastBlobSignature(Value);
end;

function TDataTable.GetLastBlobSignature: Integer;
begin
   Result:=FDataFile.GetLastBlobSignature;
end;

function TDataTable.GetNextBlobSignature: Integer;
begin
   Result:=FDataFile.GetNextBlobSignature;
end;

function TDataTable.GetNextFreeRecordNumber: Integer;
begin
   Result:=FDataFile.GetNextFreeRecordNumber;
end;

procedure TDataTable.SetNextFreeRecordNumber(Value: Integer);
begin
   FDataFile.SetNextFreeRecordNumber(Value);
end;

function TDataTable.GetRecord(DataCursor: TDataCursor; RecordNum: Integer;
                              ReadAhead: Boolean; Direction: Byte;
                              var RecordToGet: TRecord): Boolean;
begin
   Result:=FDataFile.GetBuffer(DataCursor,0,RecordNum,ReadAhead,
                               Direction,TBuffer(RecordToGet));
end;

procedure TDataTable.PutRecord(RecordToRelease: TRecord);
begin
   FDataFile.PutBuffer(RecordToRelease);
end;

function TDataTable.GetNextFreeBlockNumber: Integer;
begin
   Result:=FBlobFile.GetNextFreeBlockNumber;
end;

procedure TDataTable.SetNextFreeBlockNumber(Value: Integer);
begin
   FBlobFile.SetNextFreeBlockNumber(Value);
end;

function TDataTable.GetBlock(DataCursor: TDataCursor; BlockNum: Integer;
                             ReadAhead: Boolean; Direction: Byte;
                             var BlockToGet: TBlock): Boolean;
begin
   Result:=FBlobFile.GetBuffer(DataCursor,0,BlockNum,ReadAhead,
                               Direction,TBuffer(BlockToGet));
end;

procedure TDataTable.PutBlock(BlockToRelease: TBlock);
begin
   FBlobFile.PutBuffer(BlockToRelease);
end;

function TDataTable.GetDataFileSize: Int64;
begin
   Result:=FDataFile.FileSize;
end;

function TDataTable.GetIndexFileSize: Int64;
begin
   Result:=FIndexFile.FileSize;
end;

function TDataTable.GetBlobFileSize: Int64;
begin
   if (FDataFile.BlobFieldCount > 0) then
      Result:=FBlobFile.FileSize
   else
      Result:=0;
end;

{ TFilter object }

constructor TFilter.Create(Owner: TDataCursor;
                           NextToken: TExpToken;
                           FreeTokens: Boolean;
                           UseExisting: Boolean;
                           CalculateCosts: Boolean;
                           ClientFilterData: Integer;
                           CallbackFilterFunction: pFilterFunction);
begin
   FDataCursor:=TDataCursor(Owner);
   if (not Assigned(CallbackFilterFunction)) then
      begin
      FIsCallbackFilter:=False;
      FCallbackFunction:=nil;
      FClientData:=0;
      FFreeFilterTokens:=FreeTokens;
      FFilterTokens:=NextToken;
      if (not FDataCursor.IsRemote) then
         begin
         FOptimizeLevel:=FDataCursor.GetExpressionOptimizeLevel(FFilterTokens,
                                                                CalculateCosts);
         { If the filter expression is rewritten, then we need to recalculate
           the optimization level and costs }
         FRewritten:=FDataCursor.RewriteExpression(FFilterTokens,CalculateCosts);
         if FRewritten then
            FOptimizeLevel:=FDataCursor.GetExpressionOptimizeLevel(FFilterTokens,
                                                                   CalculateCosts);
         end
      else
         FOptimizeLevel:=olNone;
      end
   else
      begin
      FIsCallbackFilter:=True;
      FCallbackFunction:=pFilterFunction(@CallbackFilterFunction);
      FClientData:=ClientFilterData;
      FFreeFilterTokens:=False;
      FFilterTokens:=nil;
      FOptimizeLevel:=olNone;
      end;
   if (not FDataCursor.IsRemote) then
      FFilterBitmap:=TRecordsBitmap.Create;
   FUseExistingBitmaps:=UseExisting;
   FIsActive:=False;
end;

destructor TFilter.Destroy;
begin
   if FFreeFilterTokens then
      FreeExpressionTokens(FFilterTokens);
   if (not FDataCursor.IsRemote) then
      FFilterBitmap.Free;
   FIsActive:=False;
   FOptimizeLevel:=olNone;
   inherited Destroy;
end;

procedure TFilter.Activate;
begin
   FIsActive:=True;
end;

procedure TFilter.Deactivate;
begin
   FIsActive:=False;
end;

{ Version 5 }
procedure TFilter.Update(UpperOperator: TExpOperator);
begin
   if FIsCallbackFilter then
      begin
      FOptimizeLevel:=olNone;
      BuildNonIndexedBitmap(FFilterBitmap,nil,UpperOperator,
                            FClientData,@FCallbackFunction);
      end
   else
      EvaluateFilter(FFilterBitmap,FFilterTokens,UpperOperator);
end;
{ Version 5 }

{ Version 5 }
function TFilter.VerifyRecord(RecordToVerify: Integer; RecordBuffer: PChar): Boolean;
begin
   FFilterBitmap.NumOfBits:=FDataCursor.PhysicalRecordsUsed;
   FFilterBitmap.SetBit(RecordToVerify);
   if FIsCallbackFilter then
      Result:=FDataCursor.EvaluateFilterForRecord(RecordBuffer,RecordToVerify,
                                                  FFilterBitmap,nil,FClientData,
                                                  pFilterFunction(@FCallbackFunction))
   else
      Result:=FDataCursor.EvaluateFilterForRecord(RecordBuffer,RecordToVerify,
                                                  FFilterBitmap,FFilterTokens,0,nil);
end;
{ Version 5 }

procedure TFilter.UpdateRecord(RecordToUpdate: Integer; RecordBuffer: PChar);
begin
   FFilterBitmap.NumOfBits:=FDataCursor.PhysicalRecordsUsed;
   FFilterBitmap.SetBit(RecordToUpdate);
   { Version 5 }
   if FIsCallbackFilter then
      FDataCursor.EvaluateFilterForRecord(RecordBuffer,RecordToUpdate,
                                          FFilterBitmap,nil,FClientData,
                                          pFilterFunction(@FCallbackFunction))
   else
      FDataCursor.EvaluateFilterForRecord(RecordBuffer,RecordToUpdate,
                                          FFilterBitmap,FFilterTokens,0,nil);
   { Version 5 }
end;

procedure TFilter.DeleteRecord(RecordDeleted: Integer);
begin
   FFilterBitmap.ClearBit(RecordDeleted);
end;

procedure TFilter.ResetFilterExpression(RecordBuffer: PChar;
                                        ClientData: Integer;
                                        FieldCallback: pEvaluateFieldCallback;
                                        LocaleID: Integer);
begin
   ResetNextFilterToken(FFilterTokens,RecordBuffer,
                        ClientData,FieldCallback,LocaleID);
end;

procedure TFilter.ResetNextFilterToken(NextToken: TExpToken;
                                       RecordBuffer: PChar;
                                       ClientData: Integer;
                                       FieldCallback: pEvaluateFieldCallback;
                                       LocaleID: Integer);
var
   I: Integer;
   TempResultToken: TExpToken;
begin
   with NextToken do
      begin
      case TokenType of
         etUNARY:
            ResetNextFilterToken(LeftExpToken,RecordBuffer,
                                 ClientData,FieldCallback,LocaleID);
         etBINARY:
            begin
            ResetNextFilterToken(LeftExpToken,RecordBuffer,
                                 ClientData,FieldCallback,LocaleID);
            ResetNextFilterToken(RightExpToken,RecordBuffer,
                                  ClientData,FieldCallback,LocaleID);
            end;
         etEXTBINARY,etFUNC:
            begin
            for I:=0 to ArgumentExpTokens.Count-1 do
               ResetNextFilterToken(ArgumentExpToken[I],RecordBuffer,
                                    ClientData,FieldCallback,LocaleID);
            end;
         etCONST:
            begin
            { If there are expression tokens to re-evaluate, do so here }
            if (ParamExpToken <> nil) then
               begin
               TempResultToken:=EvaluateConstant(NextToken,ParamExpToken,
                                                 nil,ClientData,FieldCallback,
                                                 LocaleID);
               CopyValue(TempResultToken);
               TempResultToken.Free;               
               end;
            end;
         end;
      end;
end;

procedure TFilter.EvaluateFilter(Bitmap: TRecordsBitmap;
                                 NextToken: TExpToken;
                                 UpperFilterOperator: TExpOperator);
var
   LeftBitmap: TRecordsBitmap;
   RightBitmap: TRecordsBitmap;
   UseCaseInsensitive: Boolean;
   TempFieldToken: TExpToken;
   CurIndexPos: Byte;
   I: Integer;
begin
   if (Bitmap.NumOfBits=0) then
      Exit;
   { If the expression is all constants, then just evaluate it once }
   if (not ContainsFields(NextToken)) then
      begin
      EvaluateExpressionToken(NextToken,nil,0,nil,FDataCursor.LocaleID);
      { Version 5 }
      if (not VerifyWordBool(pWordBool(NextToken.Value)^)) then
         Bitmap.ClearBits
      else
         begin
         if (UpperFilterOperator <> eoAND) then
            begin
            Bitmap.SetBits;
            BuildNonDeletedBitmap(Bitmap);
            end;
         end;
      { Version 5 }
      end
   else
      begin
      with NextToken do
         begin
         case TokenType of
            etUNARY:
               begin
               case TokenOperator of
                  eoNOT:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        LeftBitmap:=TRecordsBitmap.Create;
                        try
                           LeftBitmap.Assign(Bitmap);
                           EvaluateFilter(LeftBitmap,LeftExpToken,TokenOperator);
                           Bitmap.Assign(LeftBitmap);
                           Bitmap.NotBits;
                           BuildNonDeletedBitmap(Bitmap);
                        finally
                           LeftBitmap.Free;
                        end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  eoPLUS,eoMINUS:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        LeftBitmap:=TRecordsBitmap.Create;
                        try
                           LeftBitmap.Assign(Bitmap);
                           EvaluateFilter(LeftBitmap,LeftExpToken,TokenOperator);
                           Bitmap.Assign(LeftBitmap);
                        finally
                           LeftBitmap.Free;
                        end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  end;
               end;
            etBINARY:
               begin
               case TokenOperator of
                  eoAND:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        LeftBitmap:=TRecordsBitmap.Create;
                        try
                           RightBitmap:=TRecordsBitmap.Create;
                           try
                              { Evaluate first condition }
                              LeftBitmap.Assign(Bitmap);
                              EvaluateFilter(LeftBitmap,LeftExpToken,
                                             TokenOperator);
                              LeftBitmap.AndBits(Bitmap);
                              RightBitmap.Assign(LeftBitmap);
                              { Evaluate second condition }
                              EvaluateFilter(RightBitmap,RightExpToken,
                                             TokenOperator);
                              RightBitmap.AndBits(LeftBitmap);
                              Bitmap.Assign(RightBitmap);
                           finally
                              RightBitmap.Free;
                           end;
                        finally
                           LeftBitmap.Free;
                        end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  eoOR:
                     begin
                     if (OptimizeLevel=olFull) then
                        begin
                        LeftBitmap:=TRecordsBitmap.Create;
                        try
                           RightBitmap:=TRecordsBitmap.Create;
                           try
                              { Evaluate first condition }
                              LeftBitmap.Assign(Bitmap);
                              EvaluateFilter(LeftBitmap,LeftExpToken,TokenOperator);
                              RightBitmap.Assign(LeftBitmap);
                              RightBitmap.SetBits;
                              { Evaluate second condition }
                              EvaluateFilter(RightBitmap,RightExpToken,TokenOperator);
                              RightBitmap.OrBits(LeftBitmap);
                              Bitmap.Assign(RightBitmap);
                           finally
                              RightBitmap.Free;
                           end;
                        finally
                           LeftBitmap.Free;
                        end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  eoEQ,eoNE,eoLT,eoGT,eoLE,eoGE:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        if (not IsTextSearchFunc(LeftExpToken)) then 
                           begin
                           CurIndexPos:=FDataCursor.IndexPos;
                           try
                              if CaseInsensitive then
                                 TempFieldToken:=LeftExpToken.ArgumentExpToken[0]
                              else
                                 TempFieldToken:=LeftExpToken;
                              FDataCursor.ChangeToIndexForFields(TempFieldToken.FieldNumber,
                                                                CaseInsensitive,False);
                              BuildIndexedBitmap(Bitmap,TokenOperator,TempFieldToken,
                                                 RightExpToken,0);
                           finally
                              FDataCursor.InternalSetIndexPos(CurIndexPos);
                           end;
                           end
                        else
                           begin
                           CurIndexPos:=FDataCursor.IndexPos;
                           try
                              FDataCursor.InternalSetIndexPos(TEXT_INDEX_POS);
                              BuildTextSearchBitmap(Bitmap,
                                                    LeftExpToken.ArgumentExpToken[1].FieldNumber,
                                                    LeftExpToken.ArgumentExpToken[1].FieldName,
                                                    LeftExpToken.ArgumentExpToken[0].Value,
                                                    LeftExpToken.ArgumentExpToken[0].DataSize-1);
                           finally
                              FDataCursor.InternalSetIndexPos(CurIndexPos);
                           end;
                           end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  end;
               end;
            etEXTBINARY:
               begin
               case TokenOperator of
                  eoLIKE,eoNOTLIKE:
                     BuildNonIndexedBitmap(Bitmap,NextToken,
                                           UpperFilterOperator,
                                           0,nil);
                  eoBETWEEN,eoNOTBETWEEN:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        CurIndexPos:=FDataCursor.IndexPos;
                        try
                           if CaseInsensitive then
                              TempFieldToken:=ArgumentExpToken[0].ArgumentExpToken[0]
                           else
                              TempFieldToken:=ArgumentExpToken[0];
                           FDataCursor.ChangeToIndexForFields(TempFieldToken.FieldNumber,
                                                             CaseInsensitive,False);
                           BuildIndexedRangeBitmap(Bitmap,TokenOperator,TempFieldToken,
                                                   ArgumentExpToken[1],ArgumentExpToken[2]);
                        finally
                           FDataCursor.InternalSetIndexPos(CurIndexPos);
                        end;
                        end
                     else
                        begin
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                        end;
                     end;
                  eoIN,eoNOTIN:
                     begin
                     if (OptimizeLevel <> olNone) then
                        begin
                        CurIndexPos:=FDataCursor.IndexPos;
                        try
                           if CaseInsensitive then
                              TempFieldToken:=ArgumentExpToken[0].ArgumentExpToken[0]
                           else
                              TempFieldToken:=ArgumentExpToken[0];
                           FDataCursor.ChangeToIndexForFields(TempFieldToken.FieldNumber,
                                                             CaseInsensitive,False);
                           RightBitmap:=TRecordsBitmap.Create;
                           try
                              RightBitmap.Assign(Bitmap);
                              if (TokenOperator=eoIN) then
                                 begin
                                 for I:=1 to ArgumentExpTokens.Count-1 do
                                    begin
                                    BuildIndexedBitmap(RightBitmap,eoEQ,TempFieldToken,
                                                       ArgumentExpToken[I],0);
                                    if (I > 1) then
                                       Bitmap.OrBits(RightBitmap)
                                    else
                                       Bitmap.Assign(RightBitmap);
                                    end;
                                 end
                              else
                                 begin
                                 for I:=1 to ArgumentExpTokens.Count-1 do
                                    begin
                                    BuildIndexedBitmap(RightBitmap,eoNE,TempFieldToken,
                                                       ArgumentExpToken[I],0);
                                    if (I > 1) then
                                       Bitmap.AndBits(RightBitmap)
                                    else
                                       Bitmap.Assign(RightBitmap);
                                    end;
                                 end;
                           finally
                              RightBitmap.Free;
                           end;
                        finally
                           FDataCursor.InternalSetIndexPos(CurIndexPos);
                        end;
                        end
                     else
                        BuildNonIndexedBitmap(Bitmap,NextToken,
                                              UpperFilterOperator,
                                              0,nil);
                     end;
                  end;
               end;
            etCOMPARE:
               begin
               if (OptimizeLevel <> olNone) then
                  begin
                  CurIndexPos:=FDataCursor.IndexPos;
                  try
                     if CaseInsensitive and
                        IsCaseInsensitiveField(LeftExpToken) then
                        begin
                        UseCaseInsensitive:=True;
                        TempFieldToken:=LeftExpToken.ArgumentExpToken[0];
                        end
                     else
                        begin
                        UseCaseInsensitive:=CaseInsensitive;
                        TempFieldToken:=LeftExpToken;
                        end;
                     FDataCursor.ChangeToIndexForFields(TempFieldToken.FieldNumber,
                                                       UseCaseInsensitive,False);
                     BuildIndexedBitmap(Bitmap,TokenOperator,TempFieldToken,
                                        RightExpToken,PartialLength);
                  finally
                     FDataCursor.InternalSetIndexPos(CurIndexPos);
                  end;
                  end
               else
                  BuildNonIndexedBitmap(Bitmap,NextToken,
                                        UpperFilterOperator,
                                        0,nil);
               end;
            end;
         end;
      end;
end;

procedure TFilter.BuildTextSearchBitmap(Bitmap: TRecordsBitmap;
                                        FieldNum: Word;
                                        const FieldName: string;
                                        WordBuffer: PChar;
                                        WordBufferSize: Integer);
var
   TempWordsList: TLocaleStringList;
   StopWordPos: Integer;
   I: Integer;
   FirstKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   SecondKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   RightBitmap: TRecordsBitmap;
   TempPartialLength: Word;
   { Version 5 }
   FoundOne: Boolean;
   { Version 5 }
begin
   TempWordsList:=TLocaleStringList.Create;
   try
      with TempWordsList do
         begin
         SetLocaleID(FDataCursor.LocaleID);
         Duplicates:=dupIgnore;
         Sorted:=True;
         end;
      FDataCursor.CreateWordsList(FDataCursor.TableName,FieldName,
                                  WordBuffer,WordBufferSize,TempWordsList,True);
      RightBitmap:=TRecordsBitmap.Create;
      try
         Bitmap.ClearBits;
         RightBitmap.Assign(Bitmap);
         { Version 5 }
         FoundOne:=False;
         for I:=0 to TempWordsList.Count-1 do
            begin
            if (not FDataCursor.TextStopWords.Find(TempWordsList[I],StopWordPos)) then
               begin
               FillChar(FirstKeyBuffer,SizeOf(FirstKeyBuffer),#0);
               FillChar(SecondKeyBuffer,SizeOf(SecondKeyBuffer),#0);
               Boolean(FirstKeyBuffer[0]):=True;
               FlipWordBits(FieldNum,@FirstKeyBuffer[FLDCHG_DATA]);
               Move(TempWordsList[I][1],FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                    Length(TempWordsList[I]));
               OSUpperString(FDataCursor.LocaleID,
                             @FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
               if (StrLen(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]) > 0) then
                  begin
                  if ((StrEnd(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1)^=PARSE_ASTERISK) then
                     begin
                     TempPartialLength:=StrLen(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1;
                     (StrEnd(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1)^:=#0;
                     end
                  else
                     TempPartialLength:=0;
                  end
               else
                  TempPartialLength:=0;
               FDataCursor.BuildRangeFromConstant(eoEQ,TYPE_ZSTRING,
                                                  TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE,
                                                  TempPartialLength,
                                                  @FirstKeyBuffer,
                                                  @SecondKeyBuffer,False,False);
               FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                                  RightBitmap);
               if FoundOne then
                  Bitmap.AndBits(RightBitmap)
               else
                  begin
                  FoundOne:=True;
                  Bitmap.Assign(RightBitmap);
                  end;
               end;
            end;
         { Version 5 }
      finally
         RightBitmap.Free;
      end;
   finally
      TempWordsList.Free;
   end;
end;

procedure TFilter.BuildIndexedBitmap(Bitmap: TRecordsBitmap;
                                     Operator: TExpOperator;
                                     FieldToken: TExpToken;
                                     ConstantToken: TExpToken;
                                     PartialLength: Word);
var
   FirstKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   SecondKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   ThirdKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   FourthKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempFieldDefinition: pFieldDefinition;
   TempOperator: TExpOperator;
   TempBitmap: TRecordsBitmap;
begin
   FillChar(FirstKeyBuffer,MAX_KEYLEN,#0);
   FillChar(SecondKeyBuffer,MAX_KEYLEN,#0);
   FillChar(ThirdKeyBuffer,MAX_KEYLEN,#0);
   FillChar(FourthKeyBuffer,MAX_KEYLEN,#0);
   TempFieldDefinition:=FDataCursor.GetPhysicalFieldDefinition(FieldToken.FieldNumber);
   TempOperator:=Operator;
   if (ConstantToken <> nil) and (not ConstantToken.IsNull) then
      begin
      FirstKeyBuffer[0]:=#1;
      PrepareDataForIndex(TempFieldDefinition,ConstantToken.Value,
                          @FirstKeyBuffer,
                          FDataCursor.KeyCaseInsensitive,
                          FDataCursor.LocaleID);
      end
   else
      begin
      { Handle special case of a < or > NULL expression }
      if ((TempFieldDefinition^.DataType <> TYPE_ZSTRING) and
          (Operator in [eoLT,eoGT])) or
         ((TempFieldDefinition^.DataType=TYPE_ZSTRING) and
          (Operator=eoLT)) then
         begin
         Bitmap.ClearBits;
         Exit;
         end;
      end;
   if (TempOperator=eoNE) and (FirstKeyBuffer[0] <> #0) then
      begin
      { Version 5 }
      { Only use the optimized ranges if the partial length is not set }
      if (PartialLength=0) then
      { Version 5 }
         begin
         Move(FirstKeyBuffer,ThirdKeyBuffer,MAX_KEYLEN);
         FDataCursor.BuildRangeFromConstant(eoLT,TempFieldDefinition^.DataType,
                                            GetIndexedSize(TempFieldDefinition),
                                            PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                                            (FirstKeyBuffer[0]=#0),True);
         FDataCursor.BuildRangeFromConstant(eoGT,TempFieldDefinition^.DataType,
                                            GetIndexedSize(TempFieldDefinition),
                                            PartialLength,@ThirdKeyBuffer,@FourthKeyBuffer,
                                            (ThirdKeyBuffer[0]=#0),True);
         TempBitmap:=TRecordsBitmap.Create;
         try
            TempBitmap.Assign(Bitmap);
            { Version 5 }
            FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                               Bitmap);
            FDataCursor.NavigateIndexedRecords(@ThirdKeyBuffer,@FourthKeyBuffer,
                                               TempBitmap);
            Bitmap.OrBits(TempBitmap);
            { Version 5 }
         finally
            TempBitmap.Free;
         end;
         end
      else
         begin
         { Version 5}
         FDataCursor.BuildRangeFromConstant(TempOperator,TempFieldDefinition^.DataType,
                                            GetIndexedSize(TempFieldDefinition),
                                            PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                                            (FirstKeyBuffer[0]=#0),False);
         FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                            Bitmap);
         Bitmap.NotBits;
         FDataCursor.NavigateNonDeletedRecords(Bitmap);
         end;
       { Version 5 }
      end
   else
      begin
      FDataCursor.BuildRangeFromConstant(TempOperator,TempFieldDefinition^.DataType,
                                         GetIndexedSize(TempFieldDefinition),
                                         PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                                         (FirstKeyBuffer[0]=#0),False);
      { Version 5 }
      FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                         Bitmap);
      { Version 5 }
      end;
end;

procedure TFilter.BuildIndexedRangeBitmap(Bitmap: TRecordsBitmap;
                                          Operator: TExpOperator;
                                          FieldToken: TExpToken;
                                          FirstConstantToken: TExpToken;
                                          SecondConstantToken: TExpToken);
var
   FirstKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   SecondKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   ThirdKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   FourthKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempFieldDefinition: pFieldDefinition;
   TempBitmap: TRecordsBitmap;
begin
   FillChar(FirstKeyBuffer,MAX_KEYLEN,#0);
   FillChar(SecondKeyBuffer,MAX_KEYLEN,#0);
   FillChar(ThirdKeyBuffer,MAX_KEYLEN,#0);
   FillChar(FourthKeyBuffer,MAX_KEYLEN,#0);
   TempFieldDefinition:=FDataCursor.GetPhysicalFieldDefinition(FieldToken.FieldNumber);
   if (FirstConstantToken <> nil) and (not FirstConstantToken.IsNull) then
      begin
      FirstKeyBuffer[0]:=#1;
      PrepareDataForIndex(TempFieldDefinition,FirstConstantToken.Value,
                          @FirstKeyBuffer,
                          FDataCursor.KeyCaseInsensitive,
                          FDataCursor.LocaleID);
      end;
   if (SecondConstantToken <> nil) and (not SecondConstantToken.IsNull) then
      begin
      SecondKeyBuffer[0]:=#1;
      PrepareDataForIndex(TempFieldDefinition,SecondConstantToken.Value,
                          @SecondKeyBuffer,
                          FDataCursor.KeyCaseInsensitive,
                          FDataCursor.LocaleID);
      end;
   { Handle special case of NULL mismatches }
   if (TempFieldDefinition^.DataType <> TYPE_ZSTRING) and
      (((FirstKeyBuffer[0]=#0) or (SecondKeyBuffer[0]=#0)) and
       (not ((FirstKeyBuffer[0]=#0) and (SecondKeyBuffer[0]=#0)))) then
      begin
      Bitmap.ClearBits;
      Exit;
      end;
   if (Operator=eoNOTBETWEEN) then
      begin
      Move(SecondKeyBuffer,ThirdKeyBuffer,MAX_KEYLEN);
      FDataCursor.BuildRangeFromConstant(eoLT,TempFieldDefinition^.DataType,
                                         GetIndexedSize(TempFieldDefinition),0,
                                         @FirstKeyBuffer,@SecondKeyBuffer,
                                         (FirstKeyBuffer[0]=#0),True);
      FDataCursor.BuildRangeFromConstant(eoGT,TempFieldDefinition^.DataType,
                                         GetIndexedSize(TempFieldDefinition),0,
                                         @ThirdKeyBuffer,@FourthKeyBuffer,
                                         (ThirdKeyBuffer[0]=#0),True);
      TempBitmap:=TRecordsBitmap.Create;
      try
         TempBitmap.Assign(Bitmap);
         { Version 5 }
         FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                            Bitmap);
         FDataCursor.NavigateIndexedRecords(@ThirdKeyBuffer,@FourthKeyBuffer,
                                            TempBitmap);
         Bitmap.OrBits(TempBitmap);
         { Version 5 }
      finally
         TempBitmap.Free;
      end;
      end
   else
      begin
      FDataCursor.BuildRangeFromConstant(Operator,TempFieldDefinition^.DataType,
                                         GetIndexedSize(TempFieldDefinition),0,
                                         @FirstKeyBuffer,@SecondKeyBuffer,
                                         (FirstKeyBuffer[0]=#0) and (SecondKeyBuffer[0]=#0),False);
      { Version 5 }
      FDataCursor.NavigateIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer,
                                         Bitmap);
      { Version 5 }
      end;
end;

procedure TFilter.BuildNonIndexedBitmap(Bitmap: TRecordsBitmap;
                                        NextToken: TExpToken;
                                        UpperFilterOperator: TExpOperator;
                                        ClientFilterData: Integer;
                                        CallbackFilterFunction: pFilterFunction);
begin
   FDataCursor.NavigateNonIndexedRecords(Bitmap,NextToken,
                                         UpperFilterOperator,
                                         ClientFilterData,CallbackFilterFunction);
end;

procedure TFilter.BuildNonDeletedBitmap(Bitmap: TRecordsBitmap);
begin
   FDataCursor.NavigateNonDeletedRecords(Bitmap);
end;

{ TDataCursor }

constructor TDataCursor.Create(Owner: TDataDirectory; NoRemoteCall: Boolean);
begin
   inherited Create;
   FDataDirectory:=Owner;
   FDataDirectory.AddDataCursor(Self);
   FFilters:=TList.Create;
   FFilterExpressionParser:=TExpressionParser.Create(Self);
   FFilterExpressionVerifier:=TExpressionVerifier.Create(Self);
   FTextStopWords:=TLocaleStringList.Create;
   with FTextStopWords do
      begin
      Duplicates:=dupIgnore;
      Sorted:=True;
      end;
   FRecordsToRead:=1;
   if IsRemote then
      begin
      if (not NoRemoteCall) then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_CREATECURSOR);
            BeginPack;
            Pack(FDataDirectory.RemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(FRemoteID);
         finally
            EndRemoteRequest;
         end;
         end
      else
         FRemoteID:=0;
      end
   else
      begin
      FTextParamsDirty:=False;
      FTextParamsRead:=False;
      FFilterBitmap:=TRecordsBitmap.Create;
      FRangeBitmap:=TRecordsBitmap.Create;
      FFilterKeys:=TList.Create;
      FLastDataUpdateStamp:=0;
      FLastIndexUpdateStamp:=0;
      FLastBlobUpdateStamp:=0;
      FRecordIDList:=TList.Create;
      end;
   FBlobBuffers:=TList.Create;
   FServerSynched:=True;
end;

destructor TDataCursor.Destroy;
begin
   CloseCursor(True);
   FDataDirectory.RemoveDataCursor(Self);
   if IsRemote then
      begin
      if (not FResultSet) then
         begin
         try
            StartRemoteRequest;
            try
               CheckForConnection;
               SetRequestCode(REQUEST_FREECURSOR);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               EndPack;
               SendReceive;
               CheckForException;
            finally
               EndRemoteRequest;
            end;
         except
         end;
         end;
      end
   else
      begin
      FFilterBitmap.Free;
      FRangeBitmap.Free;
      FFilterKeys.Free;
      FRecordIDList.Free;
      end;
   FBlobBuffers.Free;
   FTextStopWords.Free;
   FFilterExpressionParser.Free;
   FFilterExpressionVerifier.Free;
   FFilters.Free;
   ResizeLocalReceiveBuffer(0);
   inherited Destroy;
end;

procedure TDataCursor.SetTableName(const Value: string);
begin
   CheckNotOpen;
   if (Value <> FTableName) then
      FTableName:=GetLeft(StripFilePathAndExtension(Value,DataEngine.DataExtension),
                          MAX_TABLENAME_SIZE);
end;

procedure TDataCursor.SetErrorTableName(const Value: string);
begin
   if (Value <> FErrorTableName) then
      FErrorTableName:=GetLeft(StripFilePathAndExtension(Value,DataEngine.DataExtension),
                               MAX_TABLENAME_SIZE);
end;

function TDataCursor.GetProperTableName: string;
begin
   if (FErrorTableName <> '') then
      Result:=FErrorTableName
   else
      Result:=FTableName;
end;

function TDataCursor.GetDataSession: TDataSession;
begin
   Result:=FDataDirectory.DataSession;
end;

function TDataCursor.GetLastRequestCode: Word;
begin
   Result:=FLastRequestHeader.RequestCode;
end;

procedure TDataCursor.SetRequestCode(Value: Word);
begin
   DataSession.SetRequestCode(Value);
end;

function TDataCursor.GetResultCode: Word;
begin
   Result:=DataSession.GetResultCode;
end;

procedure TDataCursor.Send;
begin
   DataSession.Send;
   case DataSession.GetRequestCode of
      REQUEST_CALLBACKRESPONSE,
      REQUEST_TEXTINDEXPARAMS,REQUEST_GETDATAHEADER,
      REQUEST_FLUSHBUFFERS,REQUEST_FLUSHOSBUFFERS,
      REQUEST_UNLOCKRECORD,REQUEST_UNLOCKTABLE,
      REQUEST_LOCKSEMAPHORE,REQUEST_UNLOCKSEMAPHORE,
      REQUEST_ADDCALLBACKFILTER,REQUEST_ADDEXPRFILTER,
      REQUEST_OPENBLOB,REQUEST_FREEBLOB,
      REQUEST_FREEALLBLOBS,REQUEST_GETBLOB,REQUEST_PUTBLOB,
      REQUEST_TRUNCATEBLOB,REQUEST_GETBLOBSIZE:
      { Do nothing }         
   else
      Move(DataSession.GetSendBuffer^,
           FLastRequestHeader,SizeOf(TRequestHeader));
   end;
end;

procedure TDataCursor.SendReceive;
var
   Reconnected: Boolean;
begin
   Reconnected:=False;
   while True do
      begin
      try
         Send;
         Receive;
         Break;
      except
         on E: Exception do
            begin
            if (not Reconnected) then
               begin
               DataSession.HandleReconnect;
               Reconnected:=True;
               end
            else
               raise;
            end;
      end;
      end;
end;

procedure TDataCursor.Receive;
var
   TempCallbackType: Word;
   I: Integer;
   TempFilterPos: Integer;
   TempResult: Boolean;
   TempRecordBuffer: PChar;
   TempOldRecordBuffer: PChar;
   TempRecordNum: Integer;
   TempStep: string;
   TempPercentDone: Word;
   TempLogMessage: string;
   TempCause: Byte;
   TempContextInfo: string;
   TempContinue: Boolean;
   TempStopAsking: Boolean;
   TempOperation: Byte;
   TempRetrying: Boolean;
   TempResponse: Byte;
begin
   while True do
      begin
      DataSession.Receive(TempCallbackType);
      if (GetResultCode=DBISAM_REMOTECALLBACK) then
         begin
         case TempCallbackType of
            CALLBACK_FILTER:
               begin
               TempRecordBuffer:=AllocMem(FRecordSize);
               try
                  TempFilterPos:=-1;
                  for I:=0 to FFilters.Count-1 do
                     begin
                     if TFilter(FFilters[I]).IsCallbackFilter then
                        begin
                        TempFilterPos:=I;
                        Break;
                        end;
                     end;
                  if (TempFilterPos <> -1) then
                     begin
                     Unpack(TempRecordBuffer^);
                     Unpack(TempRecordNum);
                     with TFilter(FFilters[TempFilterPos]) do
                        TempResult:=CallbackFunction(ClientData,FRecordSize,
                                                     TempRecordBuffer,TempRecordNum);
                     end
                  else
                     TempResult:=False;
                  SetRequestCode(REQUEST_CALLBACKRESPONSE);
                  BeginPack;
                  Pack(TempResult,SizeOf(Boolean));
                  EndPack;
                  Send;
               finally
                  DeAllocMem(TempRecordBuffer);
               end;
               end;
            CALLBACK_STEPPEDPROGRESS:
               begin
               TempStep[0]:=Char(Byte(Unpack(TempStep[1])));
               Unpack(TempPercentDone);
               DoSteppedProgress(TempStep,TempPercentDone);
               end;
            CALLBACK_PROGRESS:
               begin
               Unpack(TempPercentDone);
               DoProgress(TempPercentDone);
               end;
            CALLBACK_DATALOST:
               begin
               Unpack(TempCause);
               TempContextInfo[0]:=Char(Byte(Unpack(TempContextInfo[1])));
               Unpack(TempContinue);
               Unpack(TempStopAsking);
               DoDataLost(TempCause,TempContextInfo,TempContinue,
                          TempStopAsking);
               SetRequestCode(REQUEST_CALLBACKRESPONSE);
               BeginPack;
               Pack(TempContinue,SizeOf(Boolean));
               Pack(TempStopAsking,SizeOf(Boolean));
               EndPack;
               Send;
               end;
            CALLBACK_LOG:
               begin
               TempLogMessage[0]:=Char(Byte(Unpack(TempLogMessage[1])));
               DoLog(TempLogMessage);
               end;
            CALLBACK_CACHEERROR:
               begin
               TempRecordBuffer:=AllocMem(FRecordSize);
               TempOldRecordBuffer:=AllocMem(FRecordSize);
               try
                  Unpack(TempRecordBuffer^);
                  Unpack(TempOldRecordBuffer^);
                  Unpack(TempRecordNum);
                  Unpack(TempOperation);
                  if (RemoteEngineVersion >= 4.19) then
                     Unpack(TempRetrying)
                  else
                     TempRetrying:=False;
                  TempResponse:=ERROR_RESPONSE_FAIL;
                  try
                     UnpackException;
                  except
                     on E: Exception do
                        CacheError(TempRecordNum,TempRecordBuffer,
                                   TempOldRecordBuffer,E,TempOperation,
                                   TempRetrying,TempResponse);
                  end;
                  SetRequestCode(REQUEST_CALLBACKRESPONSE);
                  BeginPack;
                  Pack(TempResponse,SizeOf(Byte));
                  EndPack;
                  Send;
               finally
                  DeAllocMem(TempOldRecordBuffer);
                  DeAllocMem(TempRecordBuffer);
               end;
               end;
            else
               Break;
            end;
         end
      else
         Break;
      end;
end;

procedure TDataCursor.SaveReceiveBuffer;
begin
   ResizeLocalReceiveBuffer(DataSession.ReceiveBufferSize);
   Move(DataSession.GetReceiveBuffer^,FLocalReceiveBuffer^,
        DataSession.ReceiveBufferSize);
   Move(FLocalReceiveBuffer^,FLocalReplyHeader,SizeOf(TReplyHeader));
   FLocalUnpackPos:=SizeOf(TReplyHeader);
end;

procedure TDataCursor.StartRemoteRequest;
begin
   DataSession.StartRemoteRequest;
end;

procedure TDataCursor.EndRemoteRequest;
begin
   DataSession.EndRemoteRequest;
end;

procedure TDataCursor.BeginPack;
begin
   DataSession.BeginPack;
end;

procedure TDataCursor.Pack(const Buffer; BufferSize: Integer);
begin
   DataSession.Pack(Buffer,BufferSize);
end;

procedure TDataCursor.EndPack;
begin
   DataSession.EndPack;
end;

procedure TDataCursor.ResizeLocalReceiveBuffer(Value: Integer);
begin
   ResizeBuffer(Value,FLocalReceiveBuffer,FLocalReceiveBufferSize,True);
end;

function TDataCursor.Unpack(var Buffer): Integer;
begin
   Result:=DataSession.Unpack(Buffer);
end;

function TDataCursor.LocalUnpack(var Buffer): Integer;
begin
   if ((FLocalUnpackPos+SizeOf(Integer)) > FLocalReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FLocalReceiveBuffer+FLocalUnpackPos)^,Result,SizeOf(Integer));
   Inc(FLocalUnpackPos,SizeOf(Integer));
   if ((FLocalUnpackPos+Result) > FLocalReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FLocalReceiveBuffer+FLocalUnpackPos)^,Buffer,Result);
   Inc(FLocalUnpackPos,Result);
end;

function TDataCursor.SkipLocalUnpack: Integer;
begin
   if ((FLocalUnpackPos+SizeOf(Integer)) > FLocalReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Move((FLocalReceiveBuffer+FLocalUnpackPos)^,Result,SizeOf(Integer));
   Inc(FLocalUnpackPos,SizeOf(Integer));
   if ((FLocalUnpackPos+Result) > FLocalReplyHeader.TotalReplySize) then
      DataEngine.RaiseError(DBISAM_UNCOMPRESS);
   Inc(FLocalUnpackPos,Result);
end;

function TDataCursor.RemainingLocalReplySize: Integer;
begin
   Result:=(FLocalReplyHeader.TotalReplySize-FLocalUnpackPos);
end;

function TDataCursor.GetIsRemote: Boolean;
begin
   Result:=DataSession.IsRemote;
end;

function TDataCursor.GetIsEncrypted: Boolean;
begin
   Result:=DataSession.IsEncrypted;
end;

function TDataCursor.GetProperDataDirectoryName: string;
begin
   Result:=FDataDirectory.ProperDataDirectoryName;
end;

function TDataCursor.GetConnected: Boolean;
begin
   Result:=DataSession.Connected;
end;

procedure TDataCursor.CheckForConnection;
begin
   DataSession.CheckForConnection;
end;

procedure TDataCursor.UnpackException;
begin
   DataSession.UnpackException;
end;

procedure TDataCursor.CheckForException;
begin
   DataSession.CheckForException;
end;

function TDataCursor.GetIsPhysicalNavigation: Boolean;
begin
   Result:=(FIndexPos=PHYSICAL_INDEX_POS);
end;

procedure TDataCursor.ForceRefresh;
begin
   SynchLastUpdateStamps;
   RefreshRangeAndFilters;
   RepositionCurrentRecord;
end;

procedure TDataCursor.Refresh;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_REFRESH);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      ReadLockTable;
      ReadUnlockTable;
      end;
end;

procedure TDataCursor.GetPhysicalFields;
var
   I: Integer;
begin
   FHasValidityChecks:=False;
   FHasDefaultValues:=False;
   FHasExpressionFields:=False;
   FHasAutoIncFields:=False;

   { Populate the field definitions from the base data table }
   for I:=1 to PhysicalFieldCount do
      begin
      FFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
      FFieldDefinitions[I]^:=GetPhysicalFieldDefinitionByPos(I)^;
      with FFieldDefinitions[I]^ do
         begin
         if (DataType=TYPE_INT32) and (SubType=SUBTYPE_AUTOINC) then
            FHasAutoIncFields:=True;
         if Required or (Minimum <> '') or (Maximum <> '') then
            FHasValidityChecks:=True;
         if (Default <> '') then
            FHasDefaultValues:=True;
         if (not FResultSet) then
            begin
            FieldOrigin:=FTableName+PARSE_ALIAS_QUALIFIER+FieldName;
            OriginFieldNum:=FieldNum;
            if DataSession.IsServer then
               FieldDatabaseOrigin:=FDataDirectory.Name
            else
               FieldDatabaseOrigin:=FDataDirectory.Directory;
            end
         else if (not FSourceTable) then
            OriginFieldNum:=FieldNum;
         end;
      end;
end;

function TDataCursor.GetProgressPercent: Word;
begin
   Result:=DataSession.ProgressPercent;
end;

function TDataCursor.GetRemoteEngineVersion: Currency;
begin
   Result:=FDataDirectory.RemoteEngineVersion;
end;

{ Version 5 }
function TDataCursor.GetRemoteEngineBuildNumber: Integer;
begin
   Result:=FDataDirectory.RemoteEngineBuildNumber;
end;
{ Version 5 }

procedure TDataCursor.UnpackStaticTableInfo;
begin
   FDataTable.UnpackStaticTableInfo;
end;

procedure TDataCursor.UnpackVariableTableInfo;
begin
   FDataTable.UnpackVariableTableInfo;
end;

procedure TDataCursor.LocalUnpackVariableTableInfo;
begin
   FDataTable.LocalUnpackVariableTableInfo(Self);
end;


procedure TDataCursor.PackTextIndexParams(StopWords: TStrings;
                                          SpaceChars: TCharSet;
                                          IncludeChars: TCharSet);
var
   I: Integer;
   TempString: string;
begin
   if (StopWords <> nil) then
      begin
      I:=StopWords.Count;
      Pack(I,SizeOf(Integer));
      for I:=0 to StopWords.Count-1 do
         Pack(StopWords[I][1],Length(StopWords[I]));
      end
   else
      begin
      I:=-1;
      Pack(I,SizeOf(Integer));
      end;
   TempString:=CharSetToString(SpaceChars);
   Pack(TempString[1],Length(TempString));
   TempString:=CharSetToString(IncludeChars);
   Pack(TempString[1],Length(TempString));
end;

procedure TDataCursor.UnpackTextIndexParams;
var
   I: Integer;
   TempCount: Integer;
   TempString: string;
begin
   FTextStopWords.Clear;
   Unpack(TempCount);
   for I:=0 to TempCount-1 do
      begin
      TempString[0]:=Char(Byte(Unpack(TempString[1])));
      FTextStopWords.Add(TempString);
      end;
   TempString[0]:=Char(Byte(Unpack(TempString[1])));
   FTextSpaceChars:=StringToCharSet(TempString);
   TempString[0]:=Char(Byte(Unpack(TempString[1])));
   FTextIncludeChars:=StringToCharSet(TempString);
end;

procedure TDataCursor.UnpackCursorInfo;
begin
   Unpack(FSequenceNumber);
   Unpack(FCurRecordNumber);
   Unpack(FRecordCount);
   UnpackVariableTableInfo;
   Unpack(FBookmarkBuffer);
   Unpack(FBOF);
   Unpack(FEOF);
end;

procedure TDataCursor.LocalUnpackCursorInfo;
begin
   LocalUnpack(FSequenceNumber);
   LocalUnpack(FCurRecordNumber);
   LocalUnpack(FRecordCount);
   LocalUnpackVariableTableInfo;
   LocalUnpack(FBookmarkBuffer);
   LocalUnpack(FBOF);
   LocalUnpack(FEOF);
end;

procedure TDataCursor.UnpackResultSetInfo;
begin
   Unpack(FRemoteID);
   FTableName[0]:=Char(Byte(Unpack(FTableName[1])));
   Unpack(FExclusive);
   Unpack(FTemporary);
   Unpack(FResultSet);
   Unpack(FSourceTable);
end;

procedure TDataCursor.UnpackResultSetFields;
var
   I: Word;
   TempFieldCount: Word;
   TempFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   TempExpTokenSize: Integer;
   TempExpTokenBuffer: PChar;
begin
   FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
   Unpack(TempFieldCount);
   try
      for I:=1 to TempFieldCount do
         begin
         TempFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
         Unpack(TempFieldDefinitions[I]^);
         if TempFieldDefinitions[I]^.ExpressionField then
            begin
            Unpack(TempExpTokenSize);
            TempExpTokenBuffer:=AllocMem(TempExpTokenSize);
            try
               TExpToken(TempFieldDefinitions[I]^.ExpressionTokens):=nil;
               Unpack(TempExpTokenBuffer^);
               UnpackExpressionTokens(TempExpTokenBuffer,
                                      TExpToken(TempFieldDefinitions[I]^.ExpressionTokens));
               if (RemoteEngineVersion <= 4.05) then
                  UntranslateExpressionTokens(TExpToken(TempFieldDefinitions[I]^.ExpressionTokens));
            finally
               DeAllocMem(TempExpTokenBuffer);
            end;
            end;
         end;
      SetFieldMapping(TempFieldCount,TempFieldDefinitions);
   finally
      for I:=1 to TempFieldCount do
         DeAllocMem(TempFieldDefinitions[I]);
   end;
end;

procedure TDataCursor.UnpackResultSetCursorInfo;
var
   TempIndexPos: Byte;
begin
   UnpackCursorInfo;
   Unpack(TempIndexPos);
   InternalSetIndexPos(TempIndexPos);
end;

procedure TDataCursor.OpenCursor(NoRemoteCall: Boolean);
var
   TempIndexPos: Byte;
begin
   if FIsOpen then
      Exit;

   { Clear out the field definitions and the index position }
   FillChar(FFieldDefinitions,SizeOf(FFieldDefinitions),#0);
   FIndexPos:=NULL_INDEX_POS;

   { Version 5 }
   FDataTable:=FDataDirectory.OpenDataTable(FTableName,FErrorTableName,FExclusive,FTemporary,
                                            FResultSet,FSourceTable,FSystemOpen,
                                            (not (FRepairing or FAlteringStructure)));
   { Version 5 }

   FIsOpen:=True;

   try

      if IsRemote then
         begin
         if (not NoRemoteCall) then
            StartRemoteRequest;
         try

            if (not NoRemoteCall) then
               begin
               CheckForConnection;
               SetRequestCode(REQUEST_OPENCURSOR);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               Pack(FTableName[1],Length(FTableName));
               Pack(FExclusive,SizeOf(Boolean));
               Pack(FReadOnly,SizeOf(Boolean));
               EndPack;
               SendReceive;
               CheckForException;
               end;

            if (not (FResultSet or FSourceTable)) or
               (FResultSet and FSourceTable) then
               begin
               if (FDataTable.ClientUseCount=1) then
                  UnpackStaticTableInfo;
               end
            else
               UnpackStaticTableInfo;

            if FDataTable.ReadOnly then
               FReadOnly:=True;
            FMarkedReadOnly:=FDataTable.MarkedReadOnly;
            if FMarkedReadOnly then
               FReadOnly:=True;

            UnpackCursorInfo;
            Unpack(TempIndexPos);

         finally
            if (not NoRemoteCall) then
               EndRemoteRequest;
         end;

         FLocaleID:=FDataTable.LocaleID;
         FFieldCount:=FDataTable.FieldCount;
         FRecordSize:=FDataTable.RecordSize;

         GetPhysicalFields;

         FFiltersInEffect:=False;
         FRangeInEffect:=False;

         InternalSetIndexPos(TempIndexPos);
         end
      else
         begin

         if FDataTable.ReadOnly then
            FReadOnly:=True;

         FMarkedReadOnly:=FDataTable.MarkedReadOnly;
         if FMarkedReadOnly then
            FReadOnly:=True;

         { Set the basic data cursor parameters }
         FLocaleID:=FDataTable.LocaleID;
         FCharMap:=DataEngine.GetLocaleCharMap(FLocaleID);
         FFieldCount:=FDataTable.FieldCount;
         FRecordSize:=FDataTable.RecordSize;

         SynchLastUpdateStamps;

         GetPhysicalFields;

         { Create the current record and page objects for maintaining
           current position information }

         FCurrentRecord:=CreateRecord;
         FLastRecord:=CreateRecord;
         FScratchRecord:=CreateRecord;
         FHashRecord:=CreateRecord;
         FCurrentPage:=CreatePage;

         { Initialize the sequence number and range sequence numbers to 0 }
         FCurKeyCounter:=1;
         FSequenceNumber:=1;
         FBeginSequenceNumber:=1;
         FEndSequenceNumber:=TotalRecordCount;

         { Allocate memory for the range buffers }
         FRangeInEffect:=False;
         FillChar(FBeginBuffer,MAX_KEYLEN,#0);
         FillChar(FEndBuffer,MAX_KEYLEN,#0);

         { Set filter flags }
         FFiltersInEffect:=False;
         FFilterRecordCount:=0;
         FFilterKeyPos:=0;

         { Initialize begin of file and end of file flags to false }
         FBOF:=False;
         FEOF:=False;

         { Check to see if we need to update the indexes since
           the index file did not exist at open time }
         if FDataTable.MissingIndex then
            begin
            RebuildMissingIndex;
            { Reset the sequence numbers since the actual record
              count would have changed }
            FBeginSequenceNumber:=1;
            FEndSequenceNumber:=TotalRecordCount;
            end;

         { Check to see if we're opening the file to do repairs, if so,
           don't try to navigate the index to the first key }
         if (not FRepairing) then
            begin

            { If we're opening up an SQL source table, then open it in physical
              order }
            if FSourceTable then
               InternalSetIndexPos(PHYSICAL_INDEX_POS)
            else
               InternalSetIndexPos(0);

            RefreshRangeAndFilters;
            SetToBegin;
            end;
         end;
   except
      CloseCursor(True);
      raise;
   end;
end;

procedure TDataCursor.GetTextIndexParams;
begin
   if (not FTextParamsRead) then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_TEXTINDEXPARAMS);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            UnpackTextIndexParams;
         finally
            EndRemoteRequest;
         end;
         end
      else
         ReadTextIndexParams;
      FTextParamsRead:=True;
      end
end;

procedure TDataCursor.ReadTextIndexParams;
var
   CurDataPage: TPage;
   I: Integer;
   TotalStopWords: Integer;
   StopWordSize: Integer;
   CurPos: Integer;
   TempStopWord: string;
   CharSetSize: Integer;
begin
   with FTextStopWords do
      begin
      SetLocaleID(FLocaleID);
      Clear;
      end;
   FTextSpaceChars:=[];
   FTextIncludeChars:=[];
   try
      if GetDataRootPage(CurDataPage) then
         begin
         try
            { First load the stop words }
            if (CurDataPage.Buffer=nil) or
               (CurDataPage.PageType <> DATA_NODE) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
            CurPos:=0;
            TotalStopWords:=pInteger(CurDataPage.Buffer+CurPos)^;
            Inc(CurPos,SizeOf(Integer));
            if (TotalStopWords < 0) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
            for I:=0 to TotalStopWords-1 do
               begin
               CheckForNextDataPage(SizeOf(Integer),CurPos,CurDataPage);
               StopWordSize:=pInteger(CurDataPage.Buffer+CurPos)^;
               Inc(CurPos,SizeOf(Integer));
               CheckForNextDataPage(StopWordSize,CurPos,CurDataPage);
               TempStopWord[0]:=Char(Byte(StopWordSize));
               Move((CurDataPage.Buffer+CurPos)^,TempStopWord[1],StopWordSize);
               Inc(CurPos,StopWordSize);
               FTextStopWords.Add(TempStopWord);
               end;
            { Now load the space chars }
            CheckForNextDataPage(SizeOf(Integer),CurPos,CurDataPage);
            CharSetSize:=pInteger(CurDataPage.Buffer+CurPos)^;
            Inc(CurPos,SizeOf(Integer));
            CheckForNextDataPage(CharSetSize,CurPos,CurDataPage);
            Move((CurDataPage.Buffer+CurPos)^,FTextSpaceChars,CharSetSize);
            Inc(CurPos,CharSetSize);
            { Now load the include chars }
            CheckForNextDataPage(SizeOf(Integer),CurPos,CurDataPage);
            CharSetSize:=pInteger(CurDataPage.Buffer+CurPos)^;
            Inc(CurPos,SizeOf(Integer));
            CheckForNextDataPage(CharSetSize,CurPos,CurDataPage);
            Move((CurDataPage.Buffer+CurPos)^,FTextIncludeChars,CharSetSize);
         finally
            PutPage(CurDataPage);
         end;
         end
      else
         DataEngine.GetDefaultTextIndexParams(FTextStopWords,FTextSpaceChars,FTextIncludeChars);
   finally
      ReadUnlockTable;
   end;
   FTextParamsDirty:=False;
end;

procedure TDataCursor.CheckForNextDataPage(SizeToRead: Integer; var CurPos: Integer;
                                           var CurPage: TPage);
var
   NextPage: TPage;
begin
   if (SizeToRead < 0) or (SizeToRead > IndexPageBufferSize) then
      DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
   if ((CurPos+SizeToRead) > IndexPageBufferSize) then
      begin
      if (CurPage.RightNumber > 0) then
         begin
         while True do
            begin
            if GetDataPage(CurPage.RightNumber,NextPage) then
               Break;
            end;
         PutPage(CurPage);
         CurPage:=NextPage;
         CurPos:=0;
         if (CurPage.Buffer=nil) or
            (CurPage.PageType <> DATA_NODE) then
            DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
         end
      else
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
      end;
end;

procedure TDataCursor.SetTextIndexParams(StopWords: TStrings; SpaceChars: TCharSet;
                                         IncludeChars: TCharSet);
begin
   if (StopWords <> nil) then
      FTextStopWords.Assign(StopWords)
   else
      FTextStopWords.Clear;
   FTextSpaceChars:=SpaceChars;
   FTextIncludeChars:=IncludeChars;
   FTextParamsDirty:=True;
end;

procedure TDataCursor.WriteTextIndexParams;
var
   CurDataPage: TPage;
   I: Integer;
   TotalStopWords: Integer;
   StopWordSize: Integer;
   CurPos: Integer;
   TempStopWord: string;
   CharSetSize: Integer;
begin
   if FTextParamsDirty then
      begin
      if (not GetDataRootPage(CurDataPage)) then
         begin
         GetNextFreeDataPage(CurDataPage);
         SetDataRootPageNumber(CurDataPage.Number);
         with CurDataPage do
            begin
            PageType:=DATA_NODE;
            AllocateBuffer;
            end;
         end;
      CurDataPage.IsDirty:=True;
      try
         { First save the stop words }
         CurPos:=0;
         TotalStopWords:=FTextStopWords.Count;
         pInteger(CurDataPage.Buffer+CurPos)^:=TotalStopWords;
         Inc(CurPos,SizeOf(Integer));
         for I:=0 to TotalStopWords-1 do
            begin
            CheckForNewDataPage(SizeOf(Integer),CurPos,CurDataPage);
            TempStopWord:=FTextStopWords[I];
            StopWordSize:=MinimumInteger(Length(TempStopWord),IndexPageBufferSize);
            pInteger(CurDataPage.Buffer+CurPos)^:=StopWordSize;
            Inc(CurPos,SizeOf(Integer));
            CheckForNewDataPage(StopWordSize,CurPos,CurDataPage);
            Move(TempStopWord[1],(CurDataPage.Buffer+CurPos)^,StopWordSize);
            Inc(CurPos,StopWordSize);
            end;
         { Now save the space chars }
         CheckForNewDataPage(SizeOf(Integer),CurPos,CurDataPage);
         CharSetSize:=MinimumInteger(SizeOf(FTextSpaceChars),IndexPageBufferSize);
         pInteger(CurDataPage.Buffer+CurPos)^:=CharSetSize;
         Inc(CurPos,SizeOf(Integer));
         CheckForNewDataPage(CharSetSize,CurPos,CurDataPage);
         Move(FTextSpaceChars,(CurDataPage.Buffer+CurPos)^,CharSetSize);
         Inc(CurPos,CharSetSize);
         { Now save the include chars }
         CheckForNewDataPage(SizeOf(Integer),CurPos,CurDataPage);
         CharSetSize:=MinimumInteger(SizeOf(FTextIncludeChars),IndexPageBufferSize);
         pInteger(CurDataPage.Buffer+CurPos)^:=CharSetSize;
         Inc(CurPos,SizeOf(Integer));
         CheckForNewDataPage(CharSetSize,CurPos,CurDataPage);
         Move(FTextIncludeChars,(CurDataPage.Buffer+CurPos)^,CharSetSize);
      finally
         PutPage(CurDataPage);
      end;
      end;
end;

procedure TDataCursor.CheckForNewDataPage(SizeToWrite: Integer; var CurPos: Integer;
                                          var CurPage: TPage);
var
   NextPage: TPage;
begin
   if ((CurPos+SizeToWrite) > IndexPageBufferSize) then
      begin
      if (CurPage.RightNumber > 0) then
         GetDataPage(CurPage.RightNumber,NextPage)
      else
         begin
         GetNextFreeDataPage(NextPage);
         with NextPage do
            begin
            PageType:=DATA_NODE;
            AllocateBuffer;
            end;
         end;
      NextPage.IsDirty:=True;
      CurPage.RightNumber:=NextPage.Number;
      PutPage(CurPage);
      CurPage:=NextPage;
      CurPos:=0;
      end;
end;

function TDataCursor.GetTextStopWords: TLocaleStringList;
begin
   GetTextIndexParams;
   Result:=FTextStopWords;
end;

function TDataCursor.GetTextSpaceChars: TCharSet;
begin
   GetTextIndexParams;
   Result:=FTextSpaceChars;
end;

function TDataCursor.GetTextIncludeChars: TCharSet;
begin
   GetTextIndexParams;
   Result:=FTextIncludeChars;
end;

procedure TDataCursor.CloseCursor(FreeIfTemporary: Boolean);
begin
   if (not FIsOpen) then
      Exit;
   { Be sure to kill any cached update cursors first }
   FreeCachedUpdates;
   if IsRemote then
      begin
      if (not FResultSet) then
         begin
         try
            StartRemoteRequest;
            try
               CheckForConnection;
               SetRequestCode(REQUEST_CLOSECURSOR);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               EndPack;
               SendReceive;
               CheckForException;
            finally
               EndRemoteRequest;
            end;
         except
         end;
         end;
      FreeAllBlobs(True,True);
      DropAllFilters;
      FFiltersInEffect:=False;
      FRangeInEffect:=False;
      end
   else
      begin
      FreeAllBlobs(True,False);
      DropAllFilters;
      FFiltersInEffect:=False;
      FreeFilterKeys;
      FRangeInEffect:=False;
      FillChar(FBeginBuffer,MAX_KEYLEN,#0);
      FillChar(FEndBuffer,MAX_KEYLEN,#0);
      FreeRecord(FCurrentRecord);
      FreeRecord(FLastRecord);
      FreeRecord(FScratchRecord);
      FreeRecord(FHashRecord);
      FreePage(FCurrentPage);
      FCurKeyCounter:=0;
      FSequenceNumber:=0;
      FBeginSequenceNumber:=0;
      FEndSequenceNumber:=0;
      FFilterRecordCount:=0;
      FBOF:=False;
      FEOF:=False;
      { Write out any text indexing parameters that have changed }
      WriteTextIndexParams;
      { Destroy any trigger or error objects }
      if (FCallbackRecordObject <> nil) then
         begin
         FCallbackRecordObject.Free;
         FCallbackRecordObject:=nil;
         end;
      { Destroy any cache error objects }
      if (FCacheCallbackRecordObject <> nil) then
         begin
         FCacheCallbackRecordObject.Free;
         FCacheCallbackRecordObject:=nil;
         end;
      end;
   if (FDataTable <> nil) then
      begin
      FDataDirectory.CloseDataTable(FDataTable,FreeIfTemporary,
                                    FResultSet,FSourceTable,FSystemOpen);
      FDataTable:=nil;
      end;
   FLocaleID:=LOCALE_ANSI_STD;
   FreeFieldDefinitions;
   FFieldCount:=0;
   FRecordSize:=0;
   FHasValidityChecks:=False;
   FHasDefaultValues:=False;
   FHasExpressionFields:=False;
   FHasAutoIncFields:=False;
   FSteppedProgressCallback:=nil;
   FSteppedProgressClientData:=0;
   FLogCallback:=nil;
   FLogClientData:=0;
   FProgressCallback:=nil;
   FProgressClientData:=0;
   FDataLostCallback:=nil;
   FDataLostClientData:=0;
   FIsOpen:=False;
end;

procedure TDataCursor.FreeFieldDefinitions;
var
   I: Word;
begin
   if (FFieldCount > 0) and (FFieldCount <= MAX_NUM_FIELDS) then
      begin
      for I:=1 to FFieldCount do
         begin
         if IsRemote then
            begin
            if FFieldDefinitions[I]^.ExpressionField then
               FreeExpressionTokens(TExpToken(FFieldDefinitions[I]^.ExpressionTokens));
            end;
         DeAllocMem(FFieldDefinitions[I]);
         end;
      end;
end;

procedure TDataCursor.FreeFilterKeys;
var
   I: Integer;
   TempPtr: pFilterKeyBuffer;
begin
   for I:=FFilterKeys.Count-1 downto 0 do
      begin
      TempPtr:=FFilterKeys[I];
      DeAllocMem(TempPtr);
      FFilterKeys.Delete(I);
      end;
end;

function TDataCursor.SearchFilterKeys(KeyBuffer: PChar; var BufferIndex: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
   TempKeyBuffer: TFilterKeyBuffer;
begin
   Result:=False;
   BufferIndex:=0;
   if (FFilterKeys.Count=0) then
      Exit;
   TempKeyBuffer.Cursor:=Self;
   Move(KeyBuffer^,TempKeyBuffer.KeyBuffer,FKeySize);
   CompareResult:=CMP_EQUAL;
   Low:=0;
   High:=(FFilterKeys.Count-1);
   while (Low <= High) do
      begin
      BufferIndex:=((Low+High) div 2);
      CompareResult:=CompareFilterKeys(FFilterKeys[BufferIndex],@TempKeyBuffer);
      case CompareResult of
         CMP_GREATER: High:=(BufferIndex-1);
         CMP_LESS: Low:=(BufferIndex+1);
         CMP_EQUAL:
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
   { Adjust the buffer index for proper insertion }
   if (CompareResult=CMP_LESS) then
      begin
      if (BufferIndex < FFilterKeys.Count) then
         Inc(BufferIndex);
      end;
end;

procedure TDataCursor.SynchLastUpdateStamps;
begin
   FLastDataUpdateStamp:=FDataTable.GetLastDataUpdateStamp;
   FLastIndexUpdateStamp:=FDataTable.GetLastIndexUpdateStamp;
   FLastBlobUpdateStamp:=FDataTable.GetLastBlobUpdateStamp;
end;

procedure TDataCursor.CheckForCursorChanges;
begin
   if (not FNoCursorChangeDetection) and PerformChangeDetection then
      begin
      SynchLastUpdateStamps;
      RefreshRangeAndFilters;
      RepositionCurrentRecord;
      end;
end;

procedure TDataCursor.CheckForChangeDetection;
begin
   if DataSession.StrictChangeDetection then
      ReadLockTable
   else
      CheckForCursorChanges;
end;

function TDataCursor.PerformChangeDetection: Boolean;
begin
   Result:=False;
   if (FExclusive or FMarkedReadOnly) then
      Exit;
   if (FLastDataUpdateStamp <> FDataTable.GetLastDataUpdateStamp) or
      (FLastIndexUpdateStamp <> FDataTable.GetLastIndexUpdateStamp) or
      (FLastBlobUpdateStamp <> FDataTable.GetLastBlobUpdateStamp) then
      Result:=True;
end;

function TDataCursor.GetNextFreePageNumber: Integer;
begin
   Result:=FDataTable.GetNextFreePageNumber;
end;

procedure TDataCursor.SetNextFreePageNumber(Value: Integer);
begin
   FDataTable.SetNextFreePageNumber(Value);
end;

procedure TDataCursor.GetNextFreePage(var NewPage: TPage);
begin
   GetPage(GetNextFreePageNumber,NewPage);
   SetNextFreePageNumber(NewPage.RightNumber);
   NewPage.Initialize(FIndexPos);
end;

procedure TDataCursor.GetNextFreeDataPage(var NewDataPage: TPage);
begin
   GetDataPage(GetNextFreePageNumber,NewDataPage);
   SetNextFreePageNumber(NewDataPage.RightNumber);
   NewDataPage.Initialize(TEXT_INDEX_POS);
end;

procedure TDataCursor.SetNextFreePage(EmptyPage: TPage);
begin
   if (GetNextFreePageNumber <> (PhysicalPagesUsed+1)) then
      EmptyPage.RightNumber:=GetNextFreePageNumber
   else
      EmptyPage.RightNumber:=0;
   EmptyPage.NumberOfKeys:=0;
   SetNextFreePageNumber(EmptyPage.Number);
end;

function TDataCursor.GetRootPageNumber: Integer;
begin
   Result:=FDataTable.GetRootPageNumber(FIndexPos);
end;

procedure TDataCursor.SetRootPageNumber(Value: Integer);
begin
   FDataTable.SetRootPageNumber(FIndexPos,Value);
end;

function TDataCursor.GetDataRootPageNumber: Integer;
begin
   Result:=FDataTable.GetDataRootPageNumber(TEXT_INDEX_POS);
end;

procedure TDataCursor.SetDataRootPageNumber(Value: Integer);
begin
   FDataTable.SetDataRootPageNumber(TEXT_INDEX_POS,Value);
end;

function TDataCursor.GetRootPage(var RootPage: TPage;
                                 var FoundChanges: Boolean): Boolean;
begin
   Result:=False;
   RootPage:=nil;
   if (GetRootPageNumber <> 0) then
      begin
      FoundChanges:=(not GetPage(GetRootPageNumber,RootPage));
      if (not FoundChanges) then
         begin
         Result:=True;
         if (RootPage.PageType <> ROOT_NODE) and (RootPage.PageType <> BOTH_NODE) or
            (RootPage.NumberOfKeys=0) then
            DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
         end;
      end
   else
      FoundChanges:=False;
end;

function TDataCursor.GetDataRootPage(var DataRootPage: TPage): Boolean;
var
   FoundChanges: Boolean;
begin
   Result:=False;
   while True do
      begin
      if (GetDataRootPageNumber <> 0) then
         begin
         FoundChanges:=(not GetDataPage(GetDataRootPageNumber,DataRootPage));
         if (not FoundChanges) then
            begin
            Result:=True;
            if (DataRootPage.PageType <> DATA_NODE) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
            end
         else
            DataRootPage:=nil;
         end
      else
         begin
         FoundChanges:=False;
         DataRootPage:=nil;
         end;
      if (not FoundChanges) then
         Break;
      end;
end;

function TDataCursor.GetPage(PageNum: Integer; var PageToGet: TPage): Boolean;
begin
   Result:=FDataTable.GetPage(Self,FIndexPos,PageNum,PageToGet);
end;

function TDataCursor.GetDataPage(PageNum: Integer; var PageToGet: TPage): Boolean;
begin
   Result:=FDataTable.GetPage(Self,TEXT_INDEX_POS,PageNum,PageToGet);
end;

procedure TDataCursor.PutPage(PageToRelease: TPage);
begin
   FDataTable.PutPage(PageToRelease);
end;

function TDataCursor.CreatePage: TPage;
begin
   Result:=FDataTable.CreatePage(FIndexPos);
end;

procedure TDataCursor.FreePage(var ExistingPage: TPage);
begin
   FDataTable.FreePage(ExistingPage);
end;

function TDataCursor.GetIndexKeyCounter: Integer;
begin
   Result:=FIndexKeyCounters[FCurIndexLevel];
end;

procedure TDataCursor.SetIndexKeyCounter(KeyCounter: Integer);
begin
   FIndexKeyCounters[FCurIndexLevel]:=KeyCounter;
end;

procedure TDataCursor.ClearIndexKeyCounters;
begin
   FillChar(FIndexKeyCounters,SizeOf(FIndexKeyCounters),#0);
end;

function TDataCursor.GetParentNumber: Integer;
begin
   Result:=FParentPages[FCurIndexLevel];
end;

procedure TDataCursor.SetParentNumber(PageNum: Integer);
begin
   FParentPages[FCurIndexLevel]:=PageNum;
end;

procedure TDataCursor.ClearParentNumbers;
begin
   FillChar(FParentPages,SizeOf(FParentPages),#0);
end;

procedure TDataCursor.IncCurIndexLevel;
begin
   Inc(FCurIndexLevel);
end;

procedure TDataCursor.DecCurIndexLevel;
begin
   if (FCurIndexLevel > 1) then
      Dec(FCurIndexLevel);
end;

function TDataCursor.CreateRecord: TRecord;
begin
   Result:=FDataTable.CreateRecord;
end;

procedure TDataCursor.FreeRecord(var ExistingRecord: TRecord);
begin
   FDataTable.FreeRecord(ExistingRecord);
end;

function TDataCursor.GetLastRecordID: Integer;
begin
   Result:=FDataTable.GetLastRecordID
end;

procedure TDataCursor.SetLastRecordID(Value: Integer);
begin
   FDataTable.SetLastRecordID(Value);
end;

function TDataCursor.GetNextRecordID: Integer;
begin
   Result:=FDataTable.GetNextRecordID;
end;

function TDataCursor.GetLastAutoIncID: Integer;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.GetLastAutoIncID
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.LastAutoIncID;
      end;
end;

procedure TDataCursor.SetLastAutoIncID(Value: Integer);
begin
   FDataTable.SetLastAutoIncID(Value);
end;

function TDataCursor.GetRecordStatus(RecordBuffer: PChar): Byte;
begin
   Result:=Byte(RecordBuffer^);
end;

procedure TDataCursor.PutRecordStatus(RecordStatus: Byte; RecordBuffer: PChar);
begin
   Byte(RecordBuffer^):=RecordStatus;
end;

function TDataCursor.GetRecordNo(RecordBuffer: PChar): Integer;
begin
   Result:=pRecordHeader(RecordBuffer)^.NextFreeNumber;
end;

procedure TDataCursor.PutRecordNo(Value: Integer; RecordBuffer: PChar);
begin
   pRecordHeader(RecordBuffer)^.NextFreeNumber:=Value;
end;

function TDataCursor.GetRecordID(RecordBuffer: PChar): Integer;
begin
   Result:=pRecordHeader(RecordBuffer)^.ID;
end;

procedure TDataCursor.PutRecordID(Value: Integer; RecordBuffer: PChar);
begin
   pRecordHeader(RecordBuffer)^.ID:=Value;
end;

function TDataCursor.GetRecordHash(RecordBuffer: PChar): TMD5Digest;
begin
   Result:=pRecordHeader(RecordBuffer)^.Hash;
end;

procedure TDataCursor.PutRecordHash(Value: TMD5Digest; RecordBuffer: PChar);
begin
   pRecordHeader(RecordBuffer)^.Hash:=Value;
end;

procedure TDataCursor.SetLastBlobSignature(Value: Integer);
begin
   FDataTable.SetLastBlobSignature(Value);
end;

function TDataCursor.GetLastBlobSignature: Integer;
begin
   Result:=FDataTable.GetLastBlobSignature;
end;

function TDataCursor.GetNextBlobSignature: Integer;
begin
   Result:=FDataTable.GetNextBlobSignature;
end;

function TDataCursor.GetBlobSignature(FieldNum: Word; RecordBuffer: PChar;
                                      UsePhysicalFields: Boolean): Integer;
var
   TempFieldDefinition: pFieldDefinition;
begin
   Result:=0;
   if UsePhysicalFields then
      TempFieldDefinition:=GetPhysicalFieldDefinition(FieldNum)
   else
      TempFieldDefinition:=GetFieldDefinition(FieldNum);
   Move((RecordBuffer+TempFieldDefinition^.Offset+FLDCHG_DATA+BLOBBLOCK_SIZE)^,Result,
        SIGNATURE_SIZE);
end;

procedure TDataCursor.PutBlobSignature(FieldNum: Word; RecordBuffer: PChar;
                                       BlobSignature: Integer; UsePhysicalFields: Boolean);
var
   TempFieldDefinition: pFieldDefinition;
begin
   if UsePhysicalFields then
      TempFieldDefinition:=GetPhysicalFieldDefinition(FieldNum)
   else
      TempFieldDefinition:=GetFieldDefinition(FieldNum);
   Move(BlobSignature,(RecordBuffer+TempFieldDefinition^.Offset+FLDCHG_DATA+BLOBBLOCK_SIZE)^,
                       SIGNATURE_SIZE);
end;

function TDataCursor.GetNextFreeRecordNumber: Integer;
begin
   Result:=FDataTable.GetNextFreeRecordNumber;
end;

procedure TDataCursor.SetNextFreeRecordNumber(Value: Integer);
begin
   FDataTable.SetNextFreeRecordNumber(Value);
end;

procedure TDataCursor.GetNextFreeRecord(var NewRecord: TRecord);
var
   LastFreeRecordNumber: Integer;
begin
   LastFreeRecordNumber:=GetNextFreeRecordNumber;
   GetRecord(LastFreeRecordNumber,False,READ_CURRENT,NewRecord,False);
   SetNextFreeRecordNumber(NewRecord.NextFreeNumber);
   NewRecord.OriginalNumber:=LastFreeRecordNumber;
end;

procedure TDataCursor.SetNextFreeRecord(EmptyRecord: TRecord);
begin
   EmptyRecord.Status:=RECORD_DELETED;
   { Only recycle records if the cursor is not being used for
     cached updates }
   if (not FCachedUpdates) then
      begin
      if (GetNextFreeRecordNumber <> (PhysicalRecordsUsed+1)) then
         EmptyRecord.NextFreeNumber:=GetNextFreeRecordNumber
      else
         EmptyRecord.NextFreeNumber:=0;
      SetNextFreeRecordNumber(EmptyRecord.Number);
      end;
end;

function TDataCursor.GetRecord(RecordNum: Integer; ReadAhead: Boolean;
                               Direction: Byte; var RecordToGet: TRecord;
                               AssignNumber: Boolean=True): Boolean;
begin
   Result:=FDataTable.GetRecord(Self,RecordNum,ReadAhead,Direction,RecordToGet);
   if Result then
      begin
      { Version 5 }
      with RecordToGet do
         begin
         if AssignNumber and (not FCachedUpdates) and (Status <> RECORD_DELETED) then
            OriginalNumber:=RecordNum;
         Size:=FRecordSize;
         end;
      { Version 5 }
      end;
end;

procedure TDataCursor.PutRecord(RecordToRelease: TRecord);
begin
   FDataTable.PutRecord(RecordToRelease);
end;

procedure TDataCursor.CalculateExpressionFields(RecordBuffer: PChar);
var
   I: Word;
   TempResultToken: TExpToken;
begin
   if (not FHasExpressionFields) or FCalculatingFields then
      Exit;
   for I:=1 to FieldCount do
      begin
      with GetFieldDefinition(I)^ do
         begin
         if ExpressionField and (ExpressionTokens <> nil) then
            begin
            TempResultToken:=TExpToken(ExpressionTokens);
            EvaluateExpressionToken(TempResultToken,RecordBuffer,Integer(Self),
                                    @TDataCursor.EvaluateCalculatedFieldData,LocaleID);
            if (not TempResultToken.IsNull) then
               PutField(FieldNum,RecordBuffer,TempResultToken.Value,True,False)
            else
               PutField(FieldNum,RecordBuffer,nil,True,False);
            end;
         end;
      end;
end;

function TDataCursor.EvaluateCalculatedFieldData(RecordBuffer: PChar;
                                                 FieldToken: TExpToken): Boolean;
var
   IsBlank: Boolean;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSizeLoaded: Integer;
   { Version 5 }
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   { Version 5 }
begin
   Result:=True;
   if FCalculatingFields then
      Exit;
   FCalculatingFields:=True;
   try
      with FieldToken do
         begin
         IsBlank:=True;
         if (DataType=TYPE_BLOB) then
            begin
            BlobHandle:=0;
            GetPhysicalField(FieldNumber,RecordBuffer,@BlobHandle,IsBlank);
            if not IsBlank then
               begin
               OpenBlob(FieldNumber,RecordBuffer,BLOB_OPENREADONLY,True,True,
                                    BlobSizeToLoad,False);
               try
                  if (SubType=SUBTYPE_MEMO) then
                     DataSize:=(BlobSizeToLoad+1)
                  else
                     DataSize:=BlobSizeToLoad;
                  GetBlob(FieldNumber,RecordBuffer,0,Value,BlobSizeToLoad,
                          BlobSizeLoaded,True);
                  if (SubType=SUBTYPE_MEMO) then
                     (Value+BlobSizeToLoad)^:=#0;
               finally
                  FreeBlob(FieldNumber,RecordBuffer,True,True);
               end;
               end
            else
               begin
               if ((DataType=TYPE_BLOB) and (SubType=SUBTYPE_MEMO)) then
                  begin
                  DataSize:=1;
                  Value^:=#0;
                  end
               else
                  DataSize:=0;
               end;
            end
         else
            { Version 5 }
            begin
            if (DataType=TYPE_ZSTRING) then
               begin
               GetPhysicalField(FieldNumber,RecordBuffer,@TempFieldBuffer,IsBlank);
               DataSize:=StrLen(@TempFieldBuffer)+1;
               Move(TempFieldBuffer,Value^,DataSize);
               end
            else
               GetPhysicalField(FieldNumber,RecordBuffer,Value,IsBlank);
            end;
            { Version 5 }
         IsNull:=IsBlank;
         end;
   finally
      FCalculatingFields:=False;
   end;
end;

function TDataCursor.GetNextFreeBlockNumber: Integer;
begin
   Result:=FDataTable.GetNextFreeBlockNumber
end;

procedure TDataCursor.SetNextFreeBlockNumber(Value: Integer);
begin
   FDataTable.SetNextFreeBlockNumber(Value);
end;

procedure TDataCursor.GetNextFreeBlock(var NewBlock: TBlock);
begin
   GetBlock(GetNextFreeBlockNumber,False,1,NewBlock);
   SetNextFreeBlockNumber(NewBlock.NextNumber);
   NewBlock.Initialize;
end;

procedure TDataCursor.SetNextFreeBlock(EmptyBlock: TBlock);
begin
   if (GetNextFreeBlockNumber <> (PhysicalBlocksUsed+1)) then
      EmptyBlock.NextNumber:=GetNextFreeBlockNumber
   else
      EmptyBlock.NextNumber:=0;
   SetNextFreeBlockNumber(EmptyBlock.Number);
end;

function TDataCursor.GetBlock(BlockNum: Integer; ReadAhead: Boolean;
                              ReadAheadBlocks: Integer;
                              var BlockToGet: TBlock): Boolean;
begin
   FReadAheadBlocks:=ReadAheadBlocks;
   Result:=FDataTable.GetBlock(Self,BlockNum,ReadAhead,READ_FORWARD,
                               BlockToGet);
end;

procedure TDataCursor.PutBlock(BlockToRelease: TBlock);
begin
   FDataTable.PutBlock(BlockToRelease);
end;

function TDataCursor.GetBlobBlockSize: Integer;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.BlobBlockSize
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.BlobBlockSize;
      end;
end;

function TDataCursor.GetBlobBlockBufferSize: Integer;
begin
   Result:=(BlobBlockSize-SizeOf(TBlockHeader));
end;

function TDataCursor.GetIndexPageSize: Integer;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.IndexPageSize
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.IndexPageSize;
      end;
end;

function TDataCursor.GetIndexPageBufferSize: Integer;
begin
   Result:=(IndexPageSize-SizeOf(TPageHeader));
end;

function TDataCursor.GetLocaleID: Integer;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FLocaleID
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.LocaleID;
      end;
end;

function TDataCursor.GetUserMajorVersion: Word;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.UserMajorVersion
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.UserMajorVersion;
      end;
end;

function TDataCursor.GetUserMinorVersion: Word;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.UserMinorVersion
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.UserMinorVersion;
      end;
end;

function TDataCursor.GetVersionNum: string;
var
   TempHeader: TDataHeader;
   TempPassword: string;
   VersionByte: Byte;
begin
   if FIsOpen then
      VersionByte:=FDataTable.VersionNum
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      VersionByte:=TempHeader.VersionNum;
      end;
   Result:=DataEngine.VersionToStr(VersionByte);
end;

procedure TDataCursor.VerifyStructureInformation(NewLocaleID: Integer;
                                                 NewEncrypted: Boolean;
                                                 NewPassword: string;
                                                 NewIndexPageSize: Integer;
                                                 NewBlobBlockSize: Integer;
                                                 NewLastAutoIncID: Integer;
                                                 NumberOfFields: Word;
                                                 const FieldDefinitions: array of pFieldDefinition;
                                                 NumberOfIndexes: Byte;
                                                 const IndexDefinitions: array of pIndexDefinition;
                                                 AllowExpressionFields: Boolean);
begin
   if NewEncrypted and ((Trim(NewPassword)='') or (Length(Trim(NewPassword)) > MAX_PASSWORD_LENGTH)) then
      DataEngine.RaiseError(DBISAM_INVALIDPASSWORD,'','',ProperDataDirectoryName,ProperTableName);
   if (NewLocaleID <> LOCALE_ANSI_STD) then
      begin
      if (not OSValidLocale(NewLocaleID)) then
         DataEngine.RaiseError(DBISAM_CANNOTLOADLDDRV,'','',ProperDataDirectoryName,ProperTableName);
      end;
   if (NumberOfFields < 1) or (NumberOfFields > MAX_NUM_FIELDS) then
      DataEngine.RaiseError(DBISAM_FLDLIMIT,'','',ProperDataDirectoryName,ProperTableName);
   if (NewIndexPageSize < MIN_PAGE_SIZE) or (NewIndexPageSize > MAX_PAGE_SIZE) then
      DataEngine.RaiseError(DBISAM_INDEXLIMIT,'','',ProperDataDirectoryName,ProperTableName);
   if (NumberOfIndexes > MAX_USER_INDEXES) then
      DataEngine.RaiseError(DBISAM_INDEXLIMIT,'','',ProperDataDirectoryName,ProperTableName);
   if (NewBlobBlockSize < MIN_BLOCK_SIZE) or (NewBlobBlockSize > MAX_BLOCK_SIZE) then
      DataEngine.RaiseError(DBISAM_BLOBLIMIT,'','',ProperDataDirectoryName,ProperTableName);
   VerifyFieldInformation(True,NumberOfFields,FieldDefinitions,
                          AllowExpressionFields);
   VerifyIndexInformation(NewLocaleID,NewIndexPageSize,NumberOfFields,FieldDefinitions,
                          NumberOfIndexes,IndexDefinitions);
end;

procedure TDataCursor.VerifyFieldInformation(UpdateOffsets: Boolean;
                                             NumberOfFields: Word;
                                             const FieldDefinitions: array of pFieldDefinition;
                                             AllowExpressionFields: Boolean);
var
   I: Word;
   J: Word;
   TempRecordOffset: Word;
begin
   { Add offset for record data at beginning of record buffer }
   TempRecordOffset:=SizeOf(TRecordHeader);
   for I:=1 to NumberOfFields do
      begin
      with FieldDefinitions[I-1]^ do
         begin
         FieldName:=Trim(FieldName);
         if (FieldName='') or
            (AnsiCompareText(FieldName,RECORDID_FIELD_NAME)=0) or
            (AnsiCompareText(FieldName,RECORDHASH_FIELD_NAME)=0) then
            DataEngine.RaiseError(DBISAM_INVALIDFIELDNAME,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         if (not IsAlpha(FieldName[1])) then
            DataEngine.RaiseError(DBISAM_INVALIDFIELDNAME,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         if (System.Length(FieldName) > MAX_FIELDNAME_SIZE) then
            DataEngine.RaiseError(DBISAM_INVALIDFIELDNAME,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         for J:=1 to NumberOfFields do
            begin
            if (J <> I) and
               (AnsiCompareText(Trim(FieldDefinitions[J-1]^.FieldName),FieldName)=0) then
               DataEngine.RaiseError(DBISAM_INVALIDFIELDNAME,'','',ProperDataDirectoryName,ProperTableName,
                                       FieldName);
            end;
         for J:=1 to NumberOfFields do
            begin
            if (J <> I) and
               (FieldDefinitions[J-1]^.FieldNum=FieldNum) and
               ((FieldDefinitions[J-1]^.FieldNum <> RECORDID_FIELD_NUM) and
                (FieldDefinitions[J-1]^.FieldNum <> RECORDHASH_FIELD_NUM)) then
               DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                     FieldName);
            end;
         if (DataType=TYPE_UNKNOWN) then
            DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         if not (DataType in [TYPE_ZSTRING,TYPE_BYTES,TYPE_VARBYTES]) then
            Length:=0
         else
            begin
            if (SubType=SUBTYPE_UNICODE) then
               begin
               if (Length=0) or (Length > (MAX_FIELD_SIZE div 2)) then
                  DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                        FieldName);
               end
            else
               begin
               if (Length=0) or (Length > MAX_FIELD_SIZE) then
                  DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                        FieldName);
               end;
            end;
         if (not VerifyBasicExpression(Default,DataType)) or
            (not VerifyBasicExpression(Minimum,DataType)) or
            (not VerifyBasicExpression(Maximum,DataType)) then
            DataEngine.RaiseError(DBISAM_INVALIDVCHKSTRUCT,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         if (Compression > NO_COMPRESSION) then
            begin
            if (DataType <> TYPE_BLOB) or (Compression > BEST_COMPRESSION) then
               DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                       FieldName);
            end;
         if (ExpressionField and (not AllowExpressionFields)) then
            DataEngine.RaiseError(DBISAM_INVALIDFLDTYPE,'','',ProperDataDirectoryName,ProperTableName,
                                  FieldName);
         if (DataType <> TYPE_BCD) then
            Decimals:=0;
         UpdateFieldSize(FieldDefinitions[I-1]);
         UpdateFieldDecimals(FieldDefinitions[I-1]);
         if (not ExpressionField) then
            begin
            if UpdateOffsets then
               begin
               Offset:=TempRecordOffset;
               Inc(TempRecordOffset,FLDCHG_DATA+DataSize);
               end
            else
               Inc(TempRecordOffset,FLDCHG_DATA+DataSize);
            end;
         end;
      end;
end;

procedure TDataCursor.VerifyIndexInformation(NewLocaleID: Integer;
                                             NewIndexPageSize: Integer;
                                             NumberOfFields: Word;
                                             const FieldDefinitions: array of pFieldDefinition;
                                             NumberOfIndexes: Byte;
                                             const IndexDefinitions: array of pIndexDefinition);
var
   I: Word;
   J: Byte;
   H: Word;
   TempKeySize: Word;
   TempFieldPos: Word;
begin
   for I:=0 to NumberOfIndexes do
      begin
      with IndexDefinitions[I]^ do
         begin
         if (I > 0) then
            begin
            IndexName:=Trim(IndexName);
            if (not IsAlpha(IndexName[1])) then
               DataEngine.RaiseError(DBISAM_INVALIDINDEXNAME,'','',ProperDataDirectoryName,ProperTableName,'',
                                     IndexName);
            if (System.Length(IndexName) > MAX_INDEXNAME_SIZE) then
               DataEngine.RaiseError(DBISAM_INVALIDINDEXNAME,'','',ProperDataDirectoryName,ProperTableName,'',
                                     IndexName);
            for H:=1 to NumberOfIndexes do
               begin
               if (H <> I) and
                  (AnsiCompareText(Trim(IndexDefinitions[H]^.IndexName),IndexName)=0) then
                  DataEngine.RaiseError(DBISAM_INDEXEXISTS,'','',ProperDataDirectoryName,ProperTableName,'',
                                        IndexName);
               end;
            end
         else
            begin
            with IndexDefinitions[I]^ do
               begin
               IndexName:='';
               KeyUnique:=True;
               { If no fields are defined then there is no primary index,
                 so add an automatic primary index }
               if (KeyFields[1]=0) then
                  begin
                  KeyDescending:=False;
                  KeyCaseInsensitive:=False;
                  KeyFieldCount:=1;
                  FillChar(KeyFields,SizeOf(TKeyFields),#0);
                  KeyFields[1]:=RECORDID_FIELD_NUM;
                  KeySize:=AUTO_PRIMARYKEY_SIZE;
                  FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                  NoKeyStatistics:=False;
                  KeyCompressionType:=NO_COMPRESS;
                  end;
               end;
            end;
         J:=1;
         TempKeySize:=0;
         while True do
            begin
            if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
               begin
               if (KeyFields[J+1] <> 0) then
                  begin
                  if (I=0) then
                     DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                             FTableName,IntToStr(KeyFields[J]),'Primary')
                  else
                     DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                             FTableName,IntToStr(KeyFields[J]),IndexName);
                  end
               else
                  Break;
               end
            else if (KeyFields[J] <> 0) and
                    (KeyFields[J] <> RECORDID_FIELD_NUM) and
                    (KeyFields[J] <> RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               TempFieldPos:=0;
               for H:=1 to NumberOfFields do
                  begin
                  if (FieldDefinitions[H-1]^.FieldNum=KeyFields[J]) then
                     begin
                     TempFieldPos:=H;
                     Break;
                     end;
                  end;
               if (TempFieldPos <= 0) or (TempFieldPos > NumberOfFields) then
                  begin
                  if (I=0) then
                     DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                             FTableName,IntToStr(KeyFields[J]),'Primary')
                  else
                     DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                             FTableName,IntToStr(KeyFields[J]),IndexName);
                  end;
               if (FieldDefinitions[TempFieldPos-1]^.DataType=TYPE_BLOB) then
                  DataEngine.RaiseError(DBISAM_SEARCHCOLREQD,'','',ProperDataDirectoryName,
                                          FTableName,FieldDefinitions[TempFieldPos-1]^.FieldName,
                                          IndexName);
               Inc(TempKeySize,FLDCHG_DATA+GetIndexedSize(FieldDefinitions[TempFieldPos-1]));
               Inc(J);
               end
            else if (KeyFields[J]=RECORDID_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDID_SIZE);
               Inc(J);
               end
            else if (KeyFields[J]=RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDHASH_SIZE);
               Inc(J);
               end
            else
               Break;
            end;
         if (TempKeySize > MAX_KEYLEN) or (TempKeySize=0) or
            (TempKeySize > ((NewIndexPageSize-SizeOf(TPageHeader)) div 3)) then
            begin
            if (I=0) then
               DataEngine.RaiseError(DBISAM_INVALIDKEY,'','',ProperDataDirectoryName,
                                     FTableName,'','Primary')
            else
               DataEngine.RaiseError(DBISAM_INVALIDKEY,'','',ProperDataDirectoryName,
                                     FTableName,'',IndexName);
            end;
         { Add the automatic record ID size if the current index is not unique }
         if (not KeyUnique) then
            Inc(TempKeySize,RECORDID_SIZE);
         KeyFieldCount:=(J-1);
         KeySize:=TempKeySize;
         end;
      end;
   { Now check the text index information }
   with IndexDefinitions[TEXT_INDEX_POS]^ do
      begin
      IndexName:=TEXT_INDEX_NAME;
      KeySize:=TEXT_KEY_SIZE;
      KeyCompressionType:=BOTH_COMPRESS;
      NoKeyStatistics:=True;
      J:=1;
      while True do
         begin
         if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
            begin
            if (KeyFields[J+1] <> 0) then
               DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                       FTableName,IntToStr(KeyFields[J]),IndexName)
            else
               Break;
            end
         else if (KeyFields[J] <> 0) and (J <= MAX_NUM_FLDSINKEY) then
            begin
            TempFieldPos:=0;
            for H:=1 to NumberOfFields do
               begin
               if (FieldDefinitions[H-1]^.FieldNum=KeyFields[J]) then
                  begin
                  TempFieldPos:=H;
                  Break;
                  end;
               end;
            if (TempFieldPos <= 0) or (TempFieldPos > NumberOfFields) then
               DataEngine.RaiseError(DBISAM_INVALIDIDXDESC,'','',ProperDataDirectoryName,
                                       FTableName,IntToStr(KeyFields[J]),IndexName);
            if (not (((FieldDefinitions[TempFieldPos-1]^.DataType=TYPE_BLOB) and
                      (FieldDefinitions[TempFieldPos-1]^.SubType=SUBTYPE_MEMO)) or
                      (FieldDefinitions[TempFieldPos-1]^.DataType=TYPE_ZSTRING))) then
               DataEngine.RaiseError(DBISAM_SEARCHCOLREQD,'','',ProperDataDirectoryName,
                                       FTableName,FieldDefinitions[TempFieldPos-1]^.FieldName,IndexName);
            Inc(J);
            end
         else
            Break;
         end;
      end;
end;

function TDataCursor.GetMaxPageSize(NumberOfFields: Word;
                                    const FieldDefinitions: array of pFieldDefinition;
                                    NumberOfIndexes: Byte;
                                    const IndexDefinitions: array of pIndexDefinition): Integer;
var
   I: Word;
   J: Byte;
   H: Word;
   TempKeySize: Word;
   TempFieldPos: Word;
   MaxKeySize: Word;
begin
   MaxKeySize:=0;
   for I:=0 to NumberOfIndexes do
      begin
      with IndexDefinitions[I]^ do
         begin
         if (I=0) then
            begin
            with IndexDefinitions[I]^ do
               begin
               IndexName:='';
               KeyUnique:=True;
               { If no fields are defined then there is no primary index,
                 so add an automatic primary index }
               if (KeyFields[1]=0) then
                  begin
                  KeyDescending:=False;
                  KeyCaseInsensitive:=False;
                  KeyFieldCount:=1;
                  FillChar(KeyFields,SizeOf(TKeyFields),#0);
                  KeyFields[1]:=RECORDID_FIELD_NUM;
                  KeySize:=AUTO_PRIMARYKEY_SIZE;
                  FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                  NoKeyStatistics:=False;
                  KeyCompressionType:=NO_COMPRESS;
                  end;
               end;
            end;
         J:=1;
         TempKeySize:=0;
         while True do
            begin
            if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
               begin
               if (KeyFields[J+1]=0) then
                  Break;
               end
            else if (KeyFields[J] <> 0) and
                    (KeyFields[J] <> RECORDID_FIELD_NUM) and
                    (KeyFields[J] <> RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               TempFieldPos:=0;
               for H:=1 to NumberOfFields do
                  begin
                  if (FieldDefinitions[H-1]^.FieldNum=KeyFields[J]) then
                     begin
                     { Version 5 }
                     UpdateFieldSize(FieldDefinitions[H-1]);
                     { Version 5 }
                     TempFieldPos:=H;
                     Break;
                     end;
                  end;
               Inc(TempKeySize,FLDCHG_DATA+GetIndexedSize(FieldDefinitions[TempFieldPos-1]));
               Inc(J);
               end
            else if (KeyFields[J]=RECORDID_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDID_SIZE);
               Inc(J);
               end
            else if (KeyFields[J]=RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDHASH_SIZE);
               Inc(J);
               end
            else
               Break;
            end;
         { Add the automatic record ID size if the current index is not unique }
         if (not KeyUnique) then
            Inc(TempKeySize,RECORDID_SIZE);
         end;
      MaxKeySize:=MaximumWord(MaxKeySize,TempKeySize);
      end;
   if (MaxKeySize <= SMALL_KEY_SIZE) then
      Result:=SMALL_PAGE_SIZE
   else if (MaxKeySize <= MED_KEY_SIZE) then
      Result:=MED_PAGE_SIZE
   else
      Result:=LARGE_PAGE_SIZE
end;

function TDataCursor.FieldDefinitionHasChanged(OldFieldDefinition: pFieldDefinition;
                                               NewFieldDefinition: pFieldDefinition): Boolean;
begin
   Result:=False;
   if (NewFieldDefinition^.FieldNum <> OldFieldDefinition^.FieldNum) or
      ((NewFieldDefinition^.DataType <> OldFieldDefinition^.DataType) or
       ((NewFieldDefinition^.DataType=OldFieldDefinition^.DataType) and
        (NewFieldDefinition^.SubType=SUBTYPE_AUTOINC) and
        (OldFieldDefinition^.SubType=SUBTYPE_UNKNOWN))) or
      (NewFieldDefinition^.DataSize <> OldFieldDefinition^.DataSize) or
      (NewFieldDefinition^.DataDecimals <> OldFieldDefinition^.DataDecimals) or
      (NewFieldDefinition^.Required <> OldFieldDefinition^.Required) or
      (NewFieldDefinition^.CharCase <> OldFieldDefinition^.CharCase) or
      (NewFieldDefinition^.Compression <> OldFieldDefinition^.Compression) or
      (AnsiCompareText(NewFieldDefinition^.Default,OldFieldDefinition^.Default) <> 0) or
      (AnsiCompareText(NewFieldDefinition^.Minimum,OldFieldDefinition^.Minimum) <> 0) or
      (AnsiCompareText(NewFieldDefinition^.Maximum,OldFieldDefinition^.Maximum) <> 0) then
      Result:=True;
end;

function TDataCursor.IndexDefinitionHasChanged(OldIndexDefinition: pIndexDefinition;
                                               NewIndexDefinition: pIndexDefinition;
                                               NewNumberOfFields: Word;
                                               const NewFieldDefinitions: array of pFieldDefinition): Boolean;
var
   I: Byte;
   J: Word;
   OldFieldDefinition: pFieldDefinition;
   NewFieldDefinition: pFieldDefinition;
   FieldFound: Boolean;
begin
   Result:=False;
   { Check key information first }
   if (NewIndexDefinition^.KeySize <> OldIndexDefinition^.KeySize) or
      (NewIndexDefinition^.KeyFieldCount <> OldIndexDefinition^.KeyFieldCount) or
      (NewIndexDefinition^.KeyCaseInsensitive <> OldIndexDefinition^.KeyCaseInsensitive) or
      (NewIndexDefinition^.KeyUnique <> OldIndexDefinition^.KeyUnique) or
      (NewIndexDefinition^.KeyCompressionType <> OldIndexDefinition^.KeyCompressionType) then
      begin
      Result:=True;
      Exit;
      end;
   { Now check key fields information }
   I:=1;
   while (NewIndexDefinition^.KeyFields[I] <> 0) and
         (I <= MAX_NUM_FLDSINKEY) do
      begin
      OldFieldDefinition:=GetPhysicalFieldDefinitionByPos(OldIndexDefinition^.KeyFields[I]);
      if (NewIndexDefinition^.KeyFields[I] <> RECORDID_FIELD_NUM) and
         (NewIndexDefinition^.KeyFields[I] <> RECORDHASH_FIELD_NUM) then
         begin
         NewFieldDefinition:=nil;
         FieldFound:=False;
         for J:=1 to NewNumberOfFields do
            begin
            if (NewFieldDefinitions[J-1]^.FieldNum=NewIndexDefinition^.KeyFields[I]) then
               begin
               NewFieldDefinition:=NewFieldDefinitions[J-1];
               FieldFound:=True;
               Break;
               end;
            end;
         end
      else
         begin
         NewFieldDefinition:=OldFieldDefinition;
         FieldFound:=True;
         end;
      if (not FieldFound) then
         DataEngine.RaiseError(DBISAM_OUTOFRANGE,'','',ProperDataDirectoryName,ProperTableName,
                                 IntToStr(NewIndexDefinition^.KeyFields[I]));
      if (NewIndexDefinition^.KeyFields[I] <> OldIndexDefinition^.KeyFields[I]) or
         (NewIndexDefinition^.KeyDescendingFields[I] <> OldIndexDefinition^.KeyDescendingFields[I]) or
         FieldDefinitionHasChanged(OldFieldDefinition,NewFieldDefinition) then
         begin
         Result:=True;
         Exit;
         end;
      Inc(I);
      end;
end;

procedure TDataCursor.ResetFieldNumbers;
var
   I: Byte;
   H: Word;
   TempIndexDefinition: TIndexDefinition;
   TempFieldDefinition: TFieldDefinition;
begin
   for I:=0 to IndexCount do
      begin
      TempIndexDefinition:=GetIndexDefinition(I)^;
      ResetIndexFieldNumbers(@TempIndexDefinition);
      UpdateIndexDefinition(I,@TempIndexDefinition);
      end;
   TempIndexDefinition:=GetIndexDefinition(TEXT_INDEX_POS)^;
   ResetIndexFieldNumbers(@TempIndexDefinition);
   UpdateIndexDefinition(TEXT_INDEX_POS,@TempIndexDefinition);
   for H:=1 to PhysicalFieldCount do
      begin
      TempFieldDefinition:=GetPhysicalFieldDefinitionByPos(H)^;
      TempFieldDefinition.FieldNum:=H;
      UpdatePhysicalFieldDefinitionByPos(H,@TempFieldDefinition);
      end;
end;

procedure TDataCursor.ResetIndexFieldNumbers(IndexDefinition: pIndexDefinition);
var
   I: Byte;
   H: Word;
begin
   I:=1;
   while (IndexDefinition^.KeyFields[I] <> 0) and
         (I <= MAX_NUM_FLDSINKEY) do
      begin
      for H:=1 to PhysicalFieldCount do
         begin
         if (IndexDefinition^.KeyFields[I]=
             GetPhysicalFieldDefinitionByPos(H)^.FieldNum) then
            begin
            IndexDefinition^.KeyFields[I]:=H;
            Break;
            end;
         end;
      Inc(I);
      end;
end;

procedure TDataCursor.SetFieldMapping(NewNumberOfFields: Word;
                                      const NewFieldDefinitions: array of pFieldDefinition);
var
   I: Word;
begin
   { Verify the new field mapping }
    VerifyFieldInformation(False,NewNumberOfFields,NewFieldDefinitions,True);
   { Free the old field definitions }
   for I:=1 to FFieldCount do
      DeAllocMem(FFieldDefinitions[I]);
   { Now install the new field definitions }
   FFieldCount:=NewNumberOfFields;
   FHasExpressionFields:=False;
   for I:=1 to NewNumberOfFields do
      begin
      FFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
      FFieldDefinitions[I]^:=NewFieldDefinitions[I-1]^;
      with FFieldDefinitions[I]^ do
         begin
         if ExpressionField then
            begin
            FHasExpressionFields:=True;
            Offset:=FRecordSize;
            Inc(FRecordSize,(FLDCHG_DATA+DataSize));
            end;
         end;
      end;
end;

procedure TDataCursor.SetDefaultFieldMapping;
var
   I: Word;
begin
   FHasExpressionFields:=False;
   for I:=1 to FFieldCount do
      begin
      with FFieldDefinitions[I]^ do
         begin
         if ExpressionField then
            begin
            FHasExpressionFields:=True;
            Offset:=FRecordSize;
            Inc(FRecordSize,(FLDCHG_DATA+DataSize));
            end;
         FieldOrigin:=FTableName+PARSE_ALIAS_QUALIFIER+FieldName;
         OriginFieldNum:=FieldNum;
         if DataSession.IsServer then
            FieldDatabaseOrigin:=FDataDirectory.Name
         else
            FieldDatabaseOrigin:=FDataDirectory.Directory;
         end;
      end;
end;

procedure TDataCursor.CheckExclusive;
begin
   if not FExclusive then
      DataEngine.RaiseError(DBISAM_NEEDEXCLACCESS,'','',ProperDataDirectoryName,ProperTableName);
end;

procedure TDataCursor.CheckNotReadOnly;
begin
   if FReadOnly then
      DataEngine.RaiseError(DBISAM_OSEACCES,'','',ProperDataDirectoryName,ProperTableName);
end;

procedure TDataCursor.CheckNotOpen;
begin
   if FIsOpen then
      DataEngine.RaiseError(DBISAM_TABLEOPEN,'','',ProperDataDirectoryName,ProperTableName);
end;

procedure TDataCursor.CheckTransaction;
begin
   if (not FResultSet) or (FResultSet and FSourceTable) then
      FDataDirectory.CheckTransaction;
end;

procedure TDataCursor.CreateTable(NewLocaleID: Integer;
                                  NewUserMajorVersion: Word;
                                  NewUserMinorVersion: Word;
                                  NewEncrypted: Boolean;
                                  NewPassword: string;
                                  NewDescription: string;
                                  NewIndexPageSize: Integer;
                                  NewBlobBlockSize: Integer;
                                  NewLastAutoIncID: Integer;
                                  NewTextIndexStopWords: TStrings;
                                  const NewTextIndexSpaceChars: TCharSet;
                                  const NewTextIndexIncludeChars: TCharSet;
                                  OverwriteExisting: Boolean;
                                  NumberOfFields: Word;
                                  const FieldDefinitions: array of pFieldDefinition;
                                  NumberOfIndexes: Byte;
                                  const IndexDefinitions: array of pIndexDefinition);
var
   I: Integer;
   TempStopWords: TLocaleStringList;
   TempSpaceChars: TCharSet;
   TempIncludeChars: TCharSet;
begin
   CheckTransaction;
   CheckExclusive;
   CheckNotReadOnly;

   NewIndexPageSize:=BlockOffset(NewIndexPageSize,CRYPTO_BLOCK_SIZE);
   NewBlobBlockSize:=BlockOffset(NewBlobBlockSize,CRYPTO_BLOCK_SIZE);

   VerifyStructureInformation(NewLocaleID,
                              NewEncrypted,NewPassword,
                              NewIndexPageSize,NewBlobBlockSize,
                              NewLastAutoIncID,
                              NumberOfFields,FieldDefinitions,
                              NumberOfIndexes,IndexDefinitions,False);

   if FDataDirectory.DataTableExists(FTableName,False,False) and (not OverwriteExisting) then
      DataEngine.RaiseError(DBISAM_TABLEEXISTS,'','',ProperDataDirectoryName,ProperTableName);

   FDataTable:=FDataDirectory.CreateDataTable(FTableName,NewLocaleID,
                                              NewUserMajorVersion,NewUserMinorVersion,
                                              NewEncrypted,NewPassword,
                                              NewDescription,
                                              NewIndexPageSize,NewBlobBlockSize,
                                              NewLastAutoIncID,
                                              NumberOfFields,FieldDefinitions,
                                              NumberOfIndexes,IndexDefinitions,
                                              FTemporary);

   FIsOpen:=True;

   try

      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_CREATETABLE);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FTableName[1],Length(FTableName));
            Pack(FTemporary,SizeOf(Boolean));
            Pack(NewLocaleID,SizeOf(Integer));
            Pack(NewUserMajorVersion,SizeOf(Word));
            Pack(NewUserMinorVersion,SizeOf(Word));
            Pack(NewEncrypted,SizeOf(Boolean));
            Pack(NewPassword[1],Length(NewPassword));
            Pack(NewDescription[1],Length(NewDescription));
            Pack(NewIndexPageSize,SizeOf(Integer));
            Pack(NewBlobBlockSize,SizeOf(Integer));
            Pack(NewLastAutoIncID,SizeOf(Integer));
            PackTextIndexParams(NewTextIndexStopWords,NewTextIndexSpaceChars,
                                NewTextIndexIncludeChars);
            Pack(OverwriteExisting,SizeOf(Boolean));
            Pack(NumberOfFields,SizeOf(Word));
            for I:=0 to NumberOfFields-1 do
               Pack(FieldDefinitions[I]^,SizeOf(TFieldDefinition));
            Pack(NumberOfIndexes,SizeOf(Byte));
            for I:=0 to NumberOfIndexes do
               Pack(IndexDefinitions[I]^,SizeOf(TIndexDefinition));
            Pack(IndexDefinitions[TEXT_INDEX_POS]^,SizeOf(TIndexDefinition));
            EndPack;
            SendReceive;
            CheckForException;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         TempStopWords:=TLocaleStringList.Create;
         try
            with TempStopWords do
               begin
               SetLocaleID(NewLocaleID);
               Duplicates:=dupIgnore;
               Sorted:=True;
               end;
            DataEngine.GetDefaultTextIndexParams(TempStopWords,TempSpaceChars,
                                                 TempIncludeChars);
            if (NewTextIndexStopWords <> nil) then
               TempStopWords.Assign(NewTextIndexStopWords);
            if (NewTextIndexSpaceChars <> []) then
               TempSpaceChars:=NewTextIndexSpaceChars;
            if (NewTextIndexIncludeChars <> []) then
               TempIncludeChars:=NewTextIndexIncludeChars;
            SetTextIndexParams(TempStopWords,TempSpaceChars,TempIncludeChars);
         finally
            TempStopWords.Free;
         end;
         end;

      CloseCursor(False);

   except
      CloseCursor(False);
      raise;
   end;

end;

procedure TDataCursor.DeleteTable;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   CheckTransaction;
   CheckNotOpen;
   GetDataHeader(TempHeader,TempPassword);
   FDataDirectory.DeleteDataTable(FTableName);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETETABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataCursor.RenameTable(const NewTableName: string);
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   CheckTransaction;
   CheckNotOpen;
   GetDataHeader(TempHeader,TempPassword);
   FDataDirectory.RenameDataTable(FTableName,FDataDirectory,NewTableName,False);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_RENAMETABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         Pack(NewTableName[1],Length(NewTableName));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataCursor.InternalBackupTable;
begin
   FDataDirectory.RenameDataTable(FTableName,FDataDirectory,FTableName,True);
end;

procedure TDataCursor.InternalRestoreTable(ActualDataDirectory: TDataDirectory;
                                           const ActualTableName: string);
begin
   FDataDirectory.RenameDataTable(FTableName,ActualDataDirectory,ActualTableName,False);
end;

procedure TDataCursor.InternalBackupIndex(TempDataDirectory: TDataDirectory);
begin
   FDataTable.InternalBackupIndex(TempDataDirectory);
end;

procedure TDataCursor.InternalRestoreIndex(TempDataDirectory: TDataDirectory;
                                           RemoveOnly: Boolean; RemoveBackup: Boolean);
begin
   FDataTable.InternalRestoreIndex(TempDataDirectory,RemoveOnly,RemoveBackup);
end;

function TDataCursor.OptimizeTable(const OptimizeIndexName: string;
                                   SuppressBackups: Boolean;
                                   SendProgress: Boolean): Integer;
var
   NewDataDirectory: TDataDirectory;
   NewDataCursor: TDataCursor;
   I: Word;
   TempFieldCount: Word;
   TempFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   TempIndexCount: Byte;
   TempIndexDefinitions: array [0..MAX_NUM_INDEXES] of pIndexDefinition;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempRecordBuffer: PChar;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   OldFieldDefinition: pFieldDefinition;
   NewFieldDefinition: pFieldDefinition;
   IsBlank: Boolean;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSize: Integer;
begin
   CheckTransaction;
   CheckNotOpen;
   CheckExclusive;
   CheckNotReadOnly;
   Result:=0;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_OPTIMIZETABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         Pack(OptimizeIndexName[1],Length(OptimizeIndexName));
         Pack(SuppressBackups,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      OpenCursor(False);
      try
         IndexName:=OptimizeIndexName;
         if FDataDirectory.InMemory then
            NewDataDirectory:=DataSession.OpenDataDirectory(INMEMORY_DATABASE_NAME,
                              INMEMORY_TEMP_NAME,False,False)
         else
            NewDataDirectory:=DataSession.OpenDataDirectory('',
                              FDataDirectory.Directory,False,False);
         try
            NewDataCursor:=TDataCursor.Create(NewDataDirectory,False);
            try
               TempFieldCount:=0;
               FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
               for I:=1 to FieldCount do
                  begin
                  TempFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
                  TempFieldDefinitions[I]^:=FFieldDefinitions[I]^;
                  Inc(TempFieldCount);
                  end;
               TempIndexCount:=0;
               FillChar(TempIndexDefinitions,SizeOf(TempIndexDefinitions),#0);
               for I:=0 to IndexCount do
                  begin
                  TempIndexDefinitions[I]:=AllocMem(SizeOf(TIndexDefinition));
                  TempIndexDefinitions[I]^:=GetIndexDefinition(I)^;
                  Inc(TempIndexCount);
                  end;
               Dec(TempIndexCount);
               TempIndexDefinitions[TEXT_INDEX_POS]:=AllocMem(SizeOf(TIndexDefinition));
               TempIndexDefinitions[TEXT_INDEX_POS]^:=GetIndexDefinition(TEXT_INDEX_POS)^;
               try
                  with NewDataCursor do
                     begin
                     TableName:=NewDataDirectory.GetTempDataTableName;
                     ErrorTableName:=Self.TableName;
                     Temporary:=False;
                     Exclusive:=True;
                     CreateTable(Self.LocaleID,
                                 Self.UserMajorVersion,Self.UserMinorVersion,
                                 Self.Encrypted,Self.Password,
                                 Self.Description,
                                 Self.IndexPageSize,Self.BlobBlockSize,
                                 Self.LastAutoIncID,
                                 Self.TextStopWords,Self.TextSpaceChars,
                                 Self.TextIncludeChars,True,
                                 TempFieldCount,TempFieldDefinitions,
                                 TempIndexCount,TempIndexDefinitions);
                     OpenCursor(False);
                     SuppressRecordIDs:=True;
                     SuppressTriggers:=True;
                     InternalSetIndexPos(PHYSICAL_INDEX_POS);
                     TempRecordBuffer:=AllocMem(RecordSize);
                     try
                        TempRecordNumber:=1;
                        TempLastPercentDone:=0;
                        Self.GotoFirstIndexPosition;
                        while (not Self.FEOF) do
                           begin
                           Self.GetRecord(Self.PhysicalRecordNumber,True,READ_FORWARD,TempRecord);
                           try
                              InitRecord(TempRecordBuffer);
                              for I:=1 to Self.FieldCount do
                                 begin
                                 OldFieldDefinition:=Self.FFieldDefinitions[I];
                                 NewFieldDefinition:=FFieldDefinitions[I];
                                 Self.GetField(OldFieldDefinition^.FieldNum,
                                               TempRecord.Buffer,
                                               @TempFieldBuffer,IsBlank);
                                 if not IsBlank then
                                    begin
                                    if (OldFieldDefinition^.DataType=TYPE_BLOB) then
                                       begin
                                       Self.OpenBlob(OldFieldDefinition^.FieldNum,
                                                     TempRecord.Buffer,
                                                     BLOB_OPENREADONLY,False,True,BlobSizeToLoad,False);
                                       Self.GetField(OldFieldDefinition^.FieldNum,
                                                     TempRecord.Buffer,
                                                     @BlobHandle,IsBlank);
                                       OpenBlob(NewFieldDefinition^.FieldNum,
                                                TempRecordBuffer,BLOB_OPENREADWRITE,False,True,
                                                BlobSize,False);
                                       BlobHandle:=FlipIntegerSign(BlobHandle);
                                       PutBlob(NewFieldDefinition^.FieldNum,
                                               TempRecordBuffer,
                                               0,TBlobBuffer(BlobHandle).Buffer,
                                               BlobSizeToLoad,False);
                                       end
                                    else
                                       PutField(NewFieldDefinition^.FieldNum,
                                                TempRecordBuffer,@TempFieldBuffer,
                                                False,False);
                                    end
                                 else
                                    PutField(NewFieldDefinition^.FieldNum,
                                             TempRecordBuffer,nil,False,False);
                                 end;
                              try
                                 PutRecordID(TempRecord.ID,TempRecordBuffer);
                                 PutRecordHash(TempRecord.Hash,TempRecordBuffer);
                                 AppendRecord(TempRecordBuffer,False,False,True,True);
                              finally
                                 Self.FreeAllBlobs(False,False);
                              end;
                              TempPercentDone:=Trunc(((TempRecordNumber/Self.RecordCount)*100));
                              if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                 begin
                                 Self.DoProgress(TempPercentDone);
                                 TempLastPercentDone:=TempPercentDone;
                                 end;
                              Inc(TempRecordNumber);
                              Self.SkipIndexKeys(1);
                           finally
                              PutRecord(TempRecord);
                           end;
                           end;
                        LastAutoIncID:=Self.LastAutoIncID;
                        LastRecordID:=Self.LastRecordID;
                        CloseCursor(True);
                        Self.CloseCursor(True);
                        if SuppressBackups then
                           Self.DeleteTable
                        else
                           Self.InternalBackupTable;
                        InternalRestoreTable(Self.DataDirectory,Self.TableName);
                        if (TempLastPercentDone <> 100) then
                           Self.DoProgress(100);
                        Result:=TempRecordNumber;
                     finally
                        DeAllocMem(TempRecordBuffer);
                     end;
                     end;
               finally
                  for I:=1 to TempFieldCount do
                     DeAllocMem(TempFieldDefinitions[I]);
                  for I:=0 to TempIndexCount do
                     DeAllocMem(TempIndexDefinitions[I]);
                  DeAllocMem(TempIndexDefinitions[TEXT_INDEX_POS]);
               end;
            finally
               NewDataCursor.Free;
            end;
         finally
            DataSession.CloseDataDirectory(NewDataDirectory,False);
         end;
      finally
         CloseCursor(True);
      end;
      end;
end;

procedure TDataCursor.CopyTable(const NewDataDirectoryName: string;
                                const NewTableName: string; CopyIndexes: Boolean;
                                SendProgress: Boolean);
var
   NewDataDirectory: TDataDirectory;
   NewDataCursor: TDataCursor;
   I: Word;
   J: Byte;
   TempFieldCount: Word;
   TempFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   TempIndexCount: Byte;
   TempIndexDefinitions: array [0..MAX_NUM_INDEXES] of pIndexDefinition;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempRecordBuffer: PChar;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   OldFieldDefinition: pFieldDefinition;
   NewFieldDefinition: pFieldDefinition;
   IsBlank: Boolean;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSize: Integer;
   TempDirectory: string;
   TempRights: Integer;
   TempDataDirectoryName: string;
   IndexValid: Boolean;
begin
   CheckTransaction;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_COPYTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NewDataDirectoryName[1],Length(NewDataDirectoryName));
         Pack(NewTableName[1],Length(NewTableName));
         Pack(CopyIndexes,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      NewDataDirectory:=nil;
      ReadLockTable;
      try
         TempDataDirectoryName:=RemoveAllTrailingBS(NewDataDirectoryName);
         TempDirectory:='';
         if DataSession.IsServer then
            begin
            TempRights:=0;
            if (TempDataDirectoryName='') then
               TempDataDirectoryName:=FDataDirectory.Name
            else
               TempDataDirectoryName:=RemoveAllBS(TempDataDirectoryName);
            DataSession.DoGetPath(TempDataDirectoryName,TempDirectory);
            NewDataDirectory:=DataSession.OpenDataDirectory(TempDataDirectoryName,
                                                            TempDirectory,False,False);
            DataSession.DoGetRights(TempDataDirectoryName,TempRights);
            NewDataDirectory.ServerRights:=TempRights;
            DataSession.DoCheckRights(NewDataDirectory,CREATE_RIGHT);
            end
         else
            begin
            if (TempDataDirectoryName='') then
               begin
               if FDataDirectory.InMemory then
                  TempDataDirectoryName:=FDataDirectory.Name
               else
                  TempDataDirectoryName:=FDataDirectory.Directory;
               end;
            if MemoryDirectory(TempDataDirectoryName) then
               begin
               TempDataDirectoryName:=RemoveAllBS(TempDataDirectoryName);
               DataSession.DoGetPath(TempDataDirectoryName,TempDirectory);
               NewDataDirectory:=DataSession.OpenDataDirectory(TempDataDirectoryName,
                                                               TempDirectory,False,False);
               end
            else
               NewDataDirectory:=DataSession.OpenDataDirectory('',TempDataDirectoryName,
                                                               False,False);
            end;
         NewDataCursor:=TDataCursor.Create(NewDataDirectory,False);
         try
            TempFieldCount:=0;
            FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
            for I:=1 to FieldCount do
               begin
               TempFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
               if (not FFieldDefinitions[I]^.Hidden) then
                  begin
                  TempFieldDefinitions[I]^:=FFieldDefinitions[I]^;
                  with TempFieldDefinitions[I]^ do
                     begin
                     ExpressionField:=False;
                     ExpressionTokens:=nil;
                     end;
                  Inc(TempFieldCount);
                  end;
               end;
            TempIndexCount:=0;
            FillChar(TempIndexDefinitions,SizeOf(TempIndexDefinitions),#0);
            if CopyIndexes then
               begin
               for I:=0 to IndexCount do
                  begin
                  { Check to make sure that a given index is still
                    valid, which is sometimes not the case with live
                    queries that have field mappings installed }
                  IndexValid:=True;
                  with GetIndexDefinition(I)^ do
                     begin
                     for J:=1 to KeyFieldCount do
                        begin
                        if (KeyFields[J] > FieldCount) and
                           (KeyFields[J] <> RECORDID_FIELD_NUM) and
                           (KeyFields[J] <> RECORDHASH_FIELD_NUM) then
                           begin
                           IndexValid:=False;
                           Break;
                           end;
                        end;
                     end;
                  if IndexValid then
                     begin
                     TempIndexDefinitions[TempIndexCount]:=AllocMem(SizeOf(TIndexDefinition));
                     TempIndexDefinitions[TempIndexCount]^:=GetIndexDefinition(I)^;
                     Inc(TempIndexCount)
                     end;
                  end;
               if (TempIndexCount > 0) then
                  Dec(TempIndexCount);
               TempIndexDefinitions[TEXT_INDEX_POS]:=AllocMem(SizeOf(TIndexDefinition));
               TempIndexDefinitions[TEXT_INDEX_POS]^:=GetIndexDefinition(TEXT_INDEX_POS)^;
               end
            else
               begin
               TempIndexDefinitions[0]:=AllocMem(SizeOf(TIndexDefinition));
               TempIndexDefinitions[TEXT_INDEX_POS]:=AllocMem(SizeOf(TIndexDefinition));
               end;
            try
               with NewDataCursor do
                  begin
                  TableName:=NewTableName;
                  ErrorTableName:=Self.TableName;
                  Exclusive:=True;
                  CreateTable(Self.LocaleID,
                              Self.UserMajorVersion,Self.UserMinorVersion,
                              Self.Encrypted,Self.Password,
                              Self.Description,
                              Self.IndexPageSize,Self.BlobBlockSize,
                              Self.LastAutoIncID,
                              Self.TextStopWords,Self.TextSpaceChars,
                              Self.TextIncludeChars,True,
                              TempFieldCount,TempFieldDefinitions,
                              TempIndexCount,TempIndexDefinitions);
                  try
                     OpenCursor(False);
                     SuppressRecordIDs:=True;
                     SuppressTriggers:=True;
                     InternalSetIndexPos(PHYSICAL_INDEX_POS);
                     TempRecordBuffer:=AllocMem(RecordSize);
                     try
                        TempRecordNumber:=1;
                        TempLastPercentDone:=0;
                        Self.GotoFirstIndexPosition;
                        while (not Self.FEOF) do
                           begin
                           Self.GetRecord(Self.PhysicalRecordNumber,True,READ_FORWARD,
                                          TempRecord);
                           try
                              if (TempRecord.Status <> RECORD_DELETED) then
                                 begin
                                 with Self.CurrentRecord do
                                    begin
                                    Size:=Self.RecordSize;
                                    Copy(TempRecord);
                                    end;
                                 Self.CalculateExpressionFields(Self.CurrentRecord.Buffer);
                                 InitRecord(TempRecordBuffer);
                                 for I:=1 to TempFieldCount do
                                    begin
                                    OldFieldDefinition:=Self.FFieldDefinitions[I];
                                    NewFieldDefinition:=FFieldDefinitions[I];
                                    Self.GetField(OldFieldDefinition^.FieldNum,
                                                  Self.CurrentRecord.Buffer,
                                                  @TempFieldBuffer,IsBlank);
                                    if not IsBlank then
                                       begin
                                       if (OldFieldDefinition^.DataType=TYPE_BLOB) then
                                          begin
                                          Self.OpenBlob(OldFieldDefinition^.FieldNum,
                                                        Self.CurrentRecord.Buffer,
                                                        BLOB_OPENREADONLY,False,True,BlobSizeToLoad,False);
                                          Self.GetField(OldFieldDefinition^.FieldNum,
                                                        Self.CurrentRecord.Buffer,
                                                        @BlobHandle,IsBlank);
                                          OpenBlob(NewFieldDefinition^.FieldNum,
                                                   TempRecordBuffer,BLOB_OPENREADWRITE,False,True,
                                                   BlobSize,False);
                                          BlobHandle:=FlipIntegerSign(BlobHandle);
                                          PutBlob(NewFieldDefinition^.FieldNum,
                                                  TempRecordBuffer,
                                                  0,TBlobBuffer(BlobHandle).Buffer,
                                                  BlobSizeToLoad,False);
                                          end
                                       else
                                          PutField(NewFieldDefinition^.FieldNum,
                                                   TempRecordBuffer,@TempFieldBuffer,
                                                   False,False);
                                       end
                                    else
                                       PutField(NewFieldDefinition^.FieldNum,
                                                TempRecordBuffer,nil,False,False);
                                    end;
                                 try
                                    PutRecordID(Self.CurrentRecord.ID,TempRecordBuffer);
                                    PutRecordHash(Self.CurrentRecord.Hash,TempRecordBuffer);
                                    AppendRecord(TempRecordBuffer,False,False,True,True);
                                 finally
                                    Self.FreeAllBlobs(False,False);
                                 end;
                                 end;
                              TempPercentDone:=Trunc(((TempRecordNumber/Self.RecordCount)*100));
                              if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                 begin
                                 Self.DoProgress(TempPercentDone);
                                 TempLastPercentDone:=TempPercentDone;
                                 end;
                              Inc(TempRecordNumber);
                              Self.SkipIndexKeys(1);
                           finally
                              PutRecord(TempRecord);
                           end;
                           end;
                        if (TempLastPercentDone <> 100) then
                           Self.DoProgress(100);
                        LastAutoIncID:=Self.LastAutoIncID;
                        LastRecordID:=Self.LastRecordID;
                     finally
                        DeAllocMem(TempRecordBuffer);
                     end;
                  finally
                     CloseCursor(True);
                  end;
                  end;
            finally
               for I:=1 to TempFieldCount do
                  DeAllocMem(TempFieldDefinitions[I]);
               for I:=0 to TempIndexCount do
                  DeAllocMem(TempIndexDefinitions[I]);
               DeAllocMem(TempIndexDefinitions[TEXT_INDEX_POS]);
            end;
         finally
            NewDataCursor.Free;
         end;
      finally
         DataSession.CloseDataDirectory(NewDataDirectory,False);
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.EmptyTable;
begin
   CheckTransaction;
   CheckExclusive;
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_EMPTYTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      { Be sure to get the text indexing params so that they are
        written back out to the index file after emptying the table }
      GetTextIndexParams;
      FDataTable.EmptyTable;
      FTextParamsDirty:=True;
      RefreshRangeAndFilters;
      SetToBegin;
      end;
end;

procedure TDataCursor.EmptyIndex;
begin
   FDataTable.EmptyIndex;
end;

function TDataCursor.RepairTable(VerifyOnly: Boolean; FixBlobSignatures: Boolean;
                                 SendProgress: Boolean; SendLog: Boolean;
                                 ForceIndexRebuild: Boolean): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempRecordCount: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempLastRecordID: Integer;
   TempHighRecordID: Integer;
   TempHighAutoIncID: Integer;
   TempAutoIncID: Integer;
   TempBlobBlock: Integer;
   TempBlobSignature: Integer;
   IsBlank: Boolean;
   I: Word;
   DataValid: Boolean;
   IndexValid: Boolean;
   BlobValid: Boolean;
   TempStopWords: TLocaleStringList;
   TempSpaceChars: TCharSet;
   TempIncludeChars: TCharSet;
   TempRecordIDIndex: Integer;
   TempHash: TMD5Digest;
begin
   CheckTransaction;
   CheckNotOpen;
   CheckExclusive;
   if (not VerifyOnly) then
      CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_REPAIRTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         Pack(VerifyOnly,SizeOf(Boolean));
         Pack(FixBlobSignatures,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         Pack(SendLog,SizeOf(Boolean));
         Pack(ForceIndexRebuild,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      Result:=True;
      DataValid:=True;
      IndexValid:=True;
      BlobValid:=True;
      FRepairing:=True;
      try
         OpenCursor(False);
         try
            if VerifyOnly then
               DoLog('Verification of table '+FTableName+' '+
                     'started at '+DateTimeToStr(Now))
            else
               DoLog('Repair of table '+FTableName+' '+
                     'started at '+DateTimeToStr(Now));

            if VerifyOnly then
               DoSteppedProgress('Verifying headers',0)
            else
               DoSteppedProgress('Repairing headers',0);
            RepairHeaders(VerifyOnly,DataValid,IndexValid,BlobValid);
            Result:=(DataValid and IndexValid and BlobValid);
            try
               ReadTextIndexParams;
               { Version 5 }
               FTextParamsRead:=True;
               { Version 5 }
            except
               if VerifyOnly then
                  DoLog('Invalid or corrupt text indexing parameters in '+
                        'index')
               else
                  begin
                  DoLog('Invalid or corrupt text indexing parameters in '+
                        'index, error fixed');
                  TempStopWords:=TLocaleStringList.Create;
                  try
                     with TempStopWords do
                        begin
                        SetLocaleID(FLocaleID);
                        Duplicates:=dupIgnore;
                        Sorted:=True;
                        end;
                     DataEngine.GetDefaultTextIndexParams(TempStopWords,TempSpaceChars,
                                                          TempIncludeChars);
                     SetTextIndexParams(TempStopWords,TempSpaceChars,TempIncludeChars);
                     IndexValid:=False;
                  finally
                     TempStopWords.Free;
                  end;
                  end;
            end;
            if VerifyOnly then
               DoSteppedProgress('Verifying headers',100)
            else
               DoSteppedProgress('Repairing headers',100);
            InternalSetIndexPos(PHYSICAL_INDEX_POS);
            TempRecordNumber:=1;
            TempLastRecordID:=LastRecordID;
            TempHighRecordID:=0;
            TempHighAutoIncID:=0;
            TempRecordCount:=0;
            TempLastPercentDone:=0;
            FRecordIDList.Capacity:=PhysicalRecordsUsed;
            while (TempRecordNumber <= PhysicalRecordsUsed) do
               begin
               GetRecord(TempRecordNumber,True,READ_FORWARD,
                         TempRecord);
               try
                  try
                     TempRecordIDIndex:=0;
                     if (TempRecord.ID=0) or
                        FindRecordID(TempRecord.ID,TempRecordIDIndex) then
                        begin
                        if VerifyOnly then
                           begin
                           DoLog('Record ID '+IntToStr(TempRecord.ID)+' for physical record # '+
                                 IntToStr(TempRecord.Number)+' is invalid');
                           TempLastRecordID:=WrapIncInteger(TempLastRecordID);
                           TempRecord.ID:=TempLastRecordID;
                           TempRecord.IsDirty:=False;
                           end
                        else
                           begin
                           DoLog('Record ID '+IntToStr(TempRecord.ID)+' for physical record # '+
                                 IntToStr(TempRecord.Number)+' is invalid, error fixed');
                           TempRecord.ID:=GetNextRecordID;
                           end;
                        FindRecordID(TempRecord.ID,TempRecordIDIndex);
                        Result:=False;
                        end;
                     FRecordIDList.Insert(TempRecordIDIndex,Pointer(TempRecord.ID));
                     TempHighRecordID:=MaximumInteger(TempRecord.ID,TempHighRecordID);
                     if (TempRecord.Status <> RECORD_DELETED) then
                        begin
                        { Check the record checksum (hash) }
                        TempHash:=CalcRecordHash(TempRecord.Buffer);
                        if (not MD5DigestCompare(TempRecord.Hash,TempHash)) then
                           begin
                           if VerifyOnly then
                              DoLog('Checksum for physical record # '+IntToStr(TempRecord.Number)+
                                    ' (logical record ID of '+IntToStr(TempRecord.ID)+') is invalid and '+
                                    'the data is most likely corrupted')
                           else
                              begin
                              DoLog('Checksum for physical record # '+IntToStr(TempRecord.Number)+
                                    ' (logical record ID of '+IntToStr(TempRecord.ID)+') is invalid and '+
                                    'the data is most likely corrupted, error fixed');
                              TempRecord.Hash:=TempHash;
                              end;
                           Result:=False;
                           end;
                        Inc(TempRecordCount);
                        if (not ForceIndexRebuild) and IndexValid then
                           begin
                           try
                              for I:=0 to IndexCount do
                                 begin
                                 InternalSetIndexPos(I);
                                 GetKeyValues(TempRecord.Buffer,
                                              @TempKeyBuffer);
                                 if (not VerifyIndexKey(@TempKeyBuffer,
                                                        TempRecordNumber)) then
                                    begin
                                    IndexValid:=False;
                                    Break;
                                    end;
                                 end;
                           except
                              IndexValid:=False;
                           end;
                           end;
                        { Check the autoinc fields for the highest number }
                        if FHasAutoIncFields then
                           begin
                           for I:=1 to FieldCount do
                              begin
                              with GetFieldDefinition(I)^ do
                                 begin
                                 if (DataType=TYPE_INT32) and
                                    (SubType=SUBTYPE_AUTOINC) then
                                    begin
                                    GetField(FieldNum,TempRecord.Buffer,
                                             @TempAutoIncID,IsBlank);
                                    if (not IsBlank) and (TempAutoIncID <> 0) then
                                       TempHighAutoIncID:=MaximumInteger(TempAutoIncID,TempHighAutoIncID);
                                    end;
                                 end;
                              end;
                           end;
                        if (BlobFieldCount > 0) then
                           begin
                           for I:=1 to FieldCount do
                              begin
                              with GetFieldDefinition(I)^ do
                                 begin
                                 if (DataType=TYPE_BLOB) then
                                    begin
                                    GetField(FieldNum,TempRecord.Buffer,
                                             @TempBlobBlock,IsBlank);
                                    if (not IsBlank) and (TempBlobBlock <> 0) then
                                       begin
                                       if (TempBlobBlock > PhysicalBlocksUsed) or
                                          (TempBlobBlock < 0) then
                                          begin
                                          if VerifyOnly then
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   ' (logical record ID of '+IntToStr(TempRecord.ID)+')')
                                          else
                                             begin
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   '(logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                                   'error fixed');
                                             TempBlobBlock:=0;
                                             end;
                                          Result:=False;
                                          end
                                       else
                                          begin
                                          TempBlobSignature:=GetBlobSignature(FieldNum,
                                                            TempRecord.Buffer,False);
                                          if (not RepairBlob(VerifyOnly,TempBlobBlock,
                                                             TempBlobSignature,
                                                             TempRecord.Number,
                                                             TempRecord.ID,
                                                             FixBlobSignatures)) and Result then
                                             Result:=False;
                                          end;
                                       if (not VerifyOnly) then
                                          begin
                                          PutField(FieldNum,TempRecord.Buffer,
                                                   @TempBlobBlock,False,False);
                                          TempRecord.IsDirty:=True;
                                          end;
                                       end
                                    else
                                       begin
                                       if (TempBlobBlock <> 0) then
                                          begin
                                          if VerifyOnly then
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   ' (logical record ID of '+IntToStr(TempRecord.ID)+')')
                                          else
                                             begin
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                                   'error fixed');
                                             PutField(FieldNum,TempRecord.Buffer,
                                                      nil,False,False);
                                             TempRecord.IsDirty:=True;
                                             end;
                                          Result:=False;
                                          end;
                                       end;
                                    end;
                                 end;
                              end;
                           end;
                        { Now check text indexes }
                        if (not ForceIndexRebuild) and IndexValid then
                           begin
                           try
                              if (not VerifyTextIndexes(TempRecord)) then
                                 IndexValid:=False;
                           except
                              IndexValid:=False;
                           end;
                           end;
                        end
                     else
                        begin
                        { If record is deleted, add it to the free records
                          linked-list }
                        if (not VerifyOnly) then
                           SetNextFreeRecord(TempRecord);
                        if (BlobFieldCount > 0) then
                           begin
                           for I:=1 to FieldCount do
                              begin
                              with GetFieldDefinition(I)^ do
                                 begin
                                 if (DataType=TYPE_BLOB) then
                                    begin
                                    GetField(FieldNum,TempRecord.Buffer,
                                             @TempBlobBlock,IsBlank);
                                    if (not IsBlank) and (TempBlobBlock <> 0) then
                                       begin
                                       if VerifyOnly then
                                          DoLog('Invalid BLOB offset into '+
                                                'BLOB file for physical record # '+
                                                IntToStr(TempRecord.Number)+
                                                ' (logical record ID of '+IntToStr(TempRecord.ID)+')')
                                       else
                                          begin
                                          DoLog('Invalid BLOB offset into '+
                                                'BLOB file for physical record # '+
                                                IntToStr(TempRecord.Number)+
                                                ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                                'error fixed');
                                          PutField(FieldNum,TempRecord.Buffer,
                                                   nil,False,False);
                                          TempRecord.IsDirty:=True;
                                          end;
                                       Result:=False;
                                       end
                                    else
                                       begin
                                       if (TempBlobBlock <> 0) then
                                          begin
                                          if VerifyOnly then
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   ' (logical record ID of '+IntToStr(TempRecord.ID)+')')
                                          else
                                             begin
                                             DoLog('Invalid BLOB offset into '+
                                                   'BLOB file for physical record # '+
                                                   IntToStr(TempRecord.Number)+
                                                   ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                                   'error fixed');
                                             PutField(FieldNum,TempRecord.Buffer,
                                                      nil,False,False);
                                             TempRecord.IsDirty:=True;
                                             end;
                                          Result:=False;
                                          end;
                                       end;
                                    end;
                                 end;
                              end;
                           end;
                        end;
                  except
                     on E: Exception do
                        begin
                        if VerifyOnly then
                           DoLog('Unexpected error '+PARSE_SINGLEQUOTE+E.Message+
                                  PARSE_SINGLEQUOTE+' during verification for physical record # '+
                                  IntToStr(TempRecord.Number)+
                                  ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                  'continuing with verification')
                        else
                           DoLog('Unexpected error '+PARSE_SINGLEQUOTE+E.Message+
                                  PARSE_SINGLEQUOTE+' during repair for physical record # '+
                                  IntToStr(TempRecord.Number)+
                                  ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                  'continuing with repair');
                        Result:=False;
                        end;
                  end;
                  TempPercentDone:=Trunc(((TempRecordNumber/PhysicalRecordsUsed)*100));
                  if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                     begin
                     if VerifyOnly then
                        DoSteppedProgress('Verifying record, index, and BLOB data',TempPercentDone)
                     else
                        DoSteppedProgress('Repairing record, index, and BLOB data',TempPercentDone);
                     TempLastPercentDone:=TempPercentDone;
                     end;
                  Inc(TempRecordNumber);
               finally
                  PutRecord(TempRecord);
                  InternalSetIndexPos(PHYSICAL_INDEX_POS);
               end;
               end;
            if (TempLastPercentDone <> 100) then
               begin
               if VerifyOnly then
                  DoSteppedProgress('Verifying record, index, and BLOB data',100)
               else
                  DoSteppedProgress('Repairing record, index, and BLOB data',100);
               end;
            if IndexValid then
               begin
               { Now check each index to make sure that the actual pages and keys
                 are valid (backwards scan) }
               TempLastPercentDone:=0;
               for I:=0 to IndexCount do
                  begin
                  if IndexValid then
                     begin
                     try
                        if (TempRecordCount > 0) then
                           begin
                           InternalSetIndexPos(I);
                           if (not VerifyNextIndexPage(GetRootPageNumber,nil,TempRecordCount)) then
                              IndexValid:=False;
                           end;
                     except
                        IndexValid:=False;
                     end;
                     end;
                  if (IndexCount > 0) then
                     begin
                     TempPercentDone:=Trunc(((I/IndexCount)*100));
                     if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                        begin
                        if VerifyOnly then
                           DoSteppedProgress('Verifying index data',TempPercentDone)
                        else
                           DoSteppedProgress('Repairing index data',TempPercentDone);
                        TempLastPercentDone:=TempPercentDone;
                        end;
                     end;
                  end;
               if (TempLastPercentDone <> 100) then
                  begin
                  if VerifyOnly then
                     DoSteppedProgress('Verifying index data',100)
                  else
                     DoSteppedProgress('Repairing index data',100);
                  end;
               end;
            if ForceIndexRebuild or (not IndexValid) then
               begin
               if VerifyOnly then
                  DoLog('Indexes do not match record data and are invalid')
               else
                  begin
                  if (not ForceIndexRebuild) then
                     DoLog('Indexes do not match record data and are invalid, starting to fix indexes');
                  { Make sure to flag the text params as dirty so they
                    are written back out to disk after the index rebuild }
                  FTextParamsDirty:=True;
                  EmptyIndex;
                  InternalSetIndexPos(PHYSICAL_INDEX_POS);
                  TempRecordNumber:=1;
                  TempLastPercentDone:=0;
                  while (TempRecordNumber <= PhysicalRecordsUsed) do
                     begin
                     GetRecord(TempRecordNumber,True,READ_FORWARD,
                               TempRecord);
                     try
                        try
                           if (TempRecord.Status <> RECORD_DELETED) then
                              begin
                              try
                                 for I:=0 to IndexCount do
                                    begin
                                    if IsUniqueIndex(I) then
                                       begin
                                       InternalSetIndexPos(I);
                                       GetKeyValues(TempRecord.Buffer,
                                                    @TempKeyBuffer);
                                       if CheckForKeyViolation(@TempKeyBuffer) then
                                          RaiseKeyViolationError;
                                       end;
                                    end;
                                 for I:=0 to IndexCount do
                                    begin
                                    InternalSetIndexPos(I);
                                    GetKeyValues(TempRecord.Buffer,
                                                 @TempKeyBuffer);
                                    AddIndexKey(@TempKeyBuffer,TempRecordNumber);
                                    end;
                                 CreateTextIndexes(TempRecord);
                              except
                                 on E: Exception do
                                    begin
                                    if (DataEngine.ConvertExceptionToCode(E)=DBISAM_KEYVIOL) then
                                       begin
                                       DoLog('Error rebuilding index keys for physical record '+
                                             '# '+IntToStr(TempRecord.Number)+
                                             ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                             'error fixed but physical record deleted');
                                       if (BlobFieldCount > 0) then
                                          begin
                                          DeleteAllBlobs(TempRecord.Buffer);
                                          RemoveTextIndexes(TempRecord);
                                          UpdateBlobSignatures(TempRecord.Buffer,False);
                                          FlushBlobBuffers;
                                          UpdateBlobBlocks(TempRecord.Buffer,False);
                                          FreeAllBlobs(False,False);
                                          end
                                       else
                                          RemoveTextIndexes(TempRecord);
                                       SetNextFreeRecord(TempRecord);
                                       Dec(TempRecordCount);
                                       Result:=False;
                                       end
                                    else
                                       raise;
                                    end;
                              end;
                              end;
                        except
                           on E: Exception do
                              begin
                              DoLog('Unexpected error '+PARSE_SINGLEQUOTE+E.Message+
                                    PARSE_SINGLEQUOTE+' during rebuild of index keys for physical record # '+
                                    IntToStr(TempRecord.Number)+
                                    ' (logical record ID of '+IntToStr(TempRecord.ID)+'), '+
                                    'continuing with repair');
                              Result:=False;
                              end;
                        end;
                        TempPercentDone:=Trunc(((TempRecordNumber/PhysicalRecordsUsed)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           if (not ForceIndexRebuild) then
                              DoSteppedProgress('Repairing indexes',TempPercentDone)
                           else
                              DoSteppedProgress('Rebuilding indexes',TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        Inc(TempRecordNumber);
                     finally
                        PutRecord(TempRecord);
                        InternalSetIndexPos(PHYSICAL_INDEX_POS);
                     end;
                     end;
                  if (TempLastPercentDone <> 100) then
                     begin
                     if (not ForceIndexRebuild) then
                        DoSteppedProgress('Repairing indexes',100)
                     else
                        DoSteppedProgress('Rebuilding indexes',100);
                     end;
                  end;
               if (not ForceIndexRebuild) then
                  begin
                  if (not VerifyOnly) then
                     DoLog('Invalid indexes fixed');
                  Result:=False;
                  end;
               end;
            { Update next record ID with highest record ID found
              if the highest record ID is higher than what the header
              actually contains }
            if VerifyOnly then
               begin
               if (TempLastRecordID < TempHighRecordID) or
                  (TempLastRecordID=High(Integer)) then
                  begin
                  DoLog('Invalid next available record ID of '+IntToStr(TempLastRecordID));
                  Result:=False;
                  end;
               end
            else
               begin
               if (LastRecordID < TempHighRecordID) or
                  (TempLastRecordID=High(Integer)) then
                  begin
                  DoLog('Invalid next available record ID of '+IntToStr(LastRecordID)+', error fixed');
                  LastRecordID:=TempHighRecordID;
                  Result:=False;
                  end;
               end;
            { Update next autoinc ID with highest autoinc ID found
              if the highest autoinc ID is higher than what the header
              actually contains }
            if (LastAutoIncID < TempHighAutoIncID) or
               (LastAutoIncID=High(Integer)) then
               begin
               if VerifyOnly then
                  DoLog('Invalid next available auto-increment value of '+IntToStr(LastAutoIncID))
               else
                  begin
                  DoLog('Invalid next available auto-increment value of '+IntToStr(LastAutoIncID)+', error fixed');
                  LastAutoIncID:=TempHighAutoIncID;
                  end;
               Result:=False;
               end;
            if (TempRecordCount <> TotalRecordCount) then
               begin
               if VerifyOnly then
                  DoLog('Invalid total record count of '+IntToStr(TotalRecordCount))
               else
                  begin
                  DoLog('Invalid total record count of '+IntToStr(TotalRecordCount)+', error fixed');
                  TotalRecordCount:=TempRecordCount;
                  end;
               Result:=False;
               end;
            if VerifyOnly then
               DoLog('Verification of table '+FTableName+' '+
                     'completed at '+DateTimeToStr(Now))
            else
               DoLog('Repair of table '+FTableName+' '+
                     'completed at '+DateTimeToStr(Now));
         finally
            CloseCursor(True);
         end;
      finally
         FRepairing:=False;
      end;
      end;
end;

function TDataCursor.FindRecordID(RecordID: Integer; var RecordIDIndex: Integer): Boolean;
var
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   RecordIDIndex:=0;
   if (FRecordIDList.Count=0) then
      Exit;
   CompareResult:=CMP_EQUAL;
   Low:=0;
   High:=(FRecordIDList.Count-1);
   while (Low <= High) do
      begin
      RecordIDIndex:=((Low+High) div 2);
      CompareResult:=CompareRecordIDs(Integer(FRecordIDList[RecordIDIndex]),RecordID);
      case CompareResult of
         CMP_GREATER: High:=(RecordIDIndex-1);
         CMP_LESS: Low:=(RecordIDIndex+1);
         CMP_EQUAL:
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
   { Adjust the record index for proper insertion }
   if (CompareResult=CMP_LESS) then
      begin
      if (RecordIDIndex < FRecordIDList.Count) then
         Inc(RecordIDIndex);
      end;
end;

procedure TDataCursor.RepairHeaders(VerifyOnly: Boolean; var DataValid: Boolean;
                                    var IndexValid: Boolean; var BlobValid: Boolean);
begin
   FDataTable.RepairHeaders(Self,VerifyOnly,DataValid,IndexValid,BlobValid);
end;

procedure TDataCursor.UpgradeTable(SendProgress: Boolean; SendLog: Boolean);
var
   V1FieldDefinitions: array [1..MAX_NUM_FIELDS] of pV1FieldDefinition;
   V123FieldDefinitions: array [1..MAX_NUM_FIELDS] of pV123FieldDefinition;
   NewFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   NewIndexDefinitions: array [0..MAX_NUM_INDEXES] of TIndexDefinition;
   InputFile: TEngineFile;
   OutputFile: TEngineFile;
   V123DataHeader: TV123DataHeader;
   NewDataHeader: TDataHeader;
   V1IndexHeader: TV1IndexHeader;
   V23IndexHeader: TV23IndexHeader;
   NewIndexHeader: TIndexHeader;
   V123BlobHeader: TV123BlobHeader;
   NewBlobHeader: TBlobHeader;
   WasEncrypted: Boolean;
   AreBlobsPresent: Boolean;
   OldBlobBlockSize: Integer;
   NewBlobBlockSize: Integer;
   NumBlocks: Integer;
   NewBlockNumber: Integer;
   NewBlockBuffer: PChar;
   NumFields: Word;
   NumIndexes: Byte;
   NumRecords: Integer;
   OldVersionNum: Byte;
   OldRecordLen: Word;
   NewRecordBuffer: PChar;
   TempRecordBuffer: PChar;
   OldRecordBuffer: PChar;
   I: Integer;
   J: Integer;
   TempOffset: Integer;
   TempBlobSignature: Integer;
   BlobFieldNum: Integer;
   TempBCD: TBCD;
   TempPassword: string;
   TempBuffer: PChar;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   CurLocaleSettings: TLocaleSettings;
   NewLocaleSettings: TLocaleSettings;
   TempDataPassword: TDataPassword;
   TempDataRootPage: Integer;
   NewDataRootPage: Integer;
   NewPageBuffer: PChar;
begin
   CheckTransaction;
   CheckNotOpen;
   CheckExclusive;
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_UPGRADETABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         Pack(SendProgress,SizeOf(Boolean));
         Pack(SendLog,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      InputFile:=TEngineFile.Create(Self);
      try
         OutputFile:=TEngineFile.Create(Self);
         try
            InputFile.FileName:=EnsureFileExt(FDataDirectory.Directory+FTableName,
                                              DataEngine.DataExtension,
                                              DataEngine.DataExtension);
            InputFile.InMemory:=FDataDirectory.InMemory;
            InputFile.Exclusive:=True;
            InputFile.OpenFile;
            try
               InputFile.Read(V123DataHeader,SizeOf(TV123DataHeader),False);
               if (V123DataHeader.VersionNum=VERSION_NUMBER) then
                  begin
                  DoLog(FTableName+' is already at the highest '+
                        'table version of '+DataEngine.VersionToStr(VERSION_NUMBER)+
                        ', upgrade aborted');
                  Exit;
                  end
               else if (V123DataHeader.VersionNum > VERSION_NUMBER) then
                  begin
                  DoLog(FTableName+' is already at a higher '+
                        'table version then the current engine version'+
                        ', upgrade aborted');
                  Exit;
                  end
               else
                  DoLog('Upgrade of table '+FTableName+' to version '+
                        DataEngine.VersionToStr(VERSION_NUMBER)+' started at '+
                        DateTimeToStr(Now));
               TempDataPassword:=nil;
               if V123DataHeader.Encrypted then
                  begin
                  TempPassword:=V123DataHeader.Password;
                  V123DecryptBuffer(TempPassword[1],Length(TempPassword),
                                PASSWORD_LOCK1,PASSWORD_LOCK2);
                  while True do
                     begin
                     if (not DataSession.CheckForPassword(TempPassword)) then
                        begin
                        if (not DataSession.AskForPassword) then
                           DataEngine.RaiseError(DBISAM_NOTSUFFTABLERIGHTS,'','',ProperDataDirectoryName,
                                                   FTableName);
                        end
                     else
                        begin
                        TempDataPassword:=DataSession.GetDataPassword(TempPassword);
                        Break;
                        end;
                     end;
                  end
               else
                  TempPassword:='';
               OldVersionNum:=V123DataHeader.VersionNum;
               if V123DataHeader.Encrypted then
                  V123DecryptBuffer(V123DataHeader.Description[1],Length(V123DataHeader.Description),
                                   PASSWORD_LOCK1,PASSWORD_LOCK2);
               { Update the header since the fields have moved around a bit }
               with NewDataHeader do
                  begin
                  UpdateStamp:=V123DataHeader.UpdateStamp;
                  VersionNum:=VERSION_NUMBER;
                  FileSignature:=DataEngine.SignatureDigest;
                  NextFreeRecord:=V123DataHeader.NextFreeRecord;
                  NextEndingRecord:=V123DataHeader.NextEndingRecord;
                  LastRecordID:=V123DataHeader.LastRecordID;
                  LastAutoIncID:=V123DataHeader.LastRecordID;
                  RecordCount:=0; { Fixed in subsequent repair table }
                  RecordLength:=(V123DataHeader.RecordLength+RECORDHASH_SIZE);
                  FieldCount:=V123DataHeader.FieldCount;
                  BlobFieldCount:=V123DataHeader.BlobFieldCount;
                  BlobBlockSize:=BlockOffset(V123DataHeader.BlobBlockSize,CRYPTO_BLOCK_SIZE);
                  LastBlobSignature:=V123DataHeader.LastBlobSignature;
                  IndexPageSize:=DEFAULT_PAGE_SIZE;
                  LastUpdated:=V123DataHeader.LastUpdated;
                  Description:=V123DataHeader.Description;
                  Encrypted:=V123DataHeader.Encrypted;
                  if Encrypted then
                     begin
                     Digest:=TempDataPassword.Digest;
                     DataEngine.Encrypt(TempDataPassword.Data,PChar(@Digest),SizeOf(TMD5Digest));
                     end
                  else
                     FillChar(Digest,SizeOf(TMD5Digest),#0);
                  LocaleID:=OSLocaleID(V123DataHeader.LanguageID,V123DataHeader.SortID);
                  UserMajorVersion:=V123DataHeader.UserMajorVersion;
                  UserMinorVersion:=V123DataHeader.UserMinorVersion;
                  end;
               WasEncrypted:=V123DataHeader.Encrypted;
               AreBlobsPresent:=(V123DataHeader.BlobFieldCount > 0);
               OldBlobBlockSize:=V123DataHeader.BlobBlockSize;
               NewBlobBlockSize:=NewDataHeader.BlobBlockSize;
               NumFields:=V123DataHeader.FieldCount;
               NumRecords:=(V123DataHeader.NextEndingRecord-1);
               OldRecordLen:=V123DataHeader.RecordLength;
               if (OldVersionNum < 4) then
                  NewDataHeader.LastBlobSignature:=(V123DataHeader.BlobFieldCount*NumRecords);
               if FDataDirectory.InMemory then
                  OutputFile.FileName:=DataEngine.GetTempFileName(INMEMORY_TEMP_NAME,
                                                       DataEngine.DataTempExtension,FDataDirectory.InMemory,False)
               else
                  begin
                  if DataEngine.TempTablesInDataDirectory then
                     OutputFile.FileName:=DataEngine.GetTempFileName(FDataDirectory.Directory,
                                                          DataEngine.DataTempExtension,FDataDirectory.InMemory,False)
                  else
                     OutputFile.FileName:=DataEngine.GetTempFileName(DataSession.PrivateDirectory,
                                                          DataEngine.DataTempExtension,FDataDirectory.InMemory,False);
                  end;
               OutputFile.InMemory:=FDataDirectory.InMemory;
               OutputFile.Exclusive:=True;
               OutputFile.CreateFile;
               try
                  TempOffset:=SizeOf(TRecordHeader);
                  TempBuffer:=nil;
                  FillChar(V1FieldDefinitions,SizeOf(V1FieldDefinitions),#0);
                  FillChar(V123FieldDefinitions,SizeOf(V123FieldDefinitions),#0);
                  FillChar(NewFieldDefinitions,SizeOf(NewFieldDefinitions),#0);
                  if (OldVersionNum < 3) then
                     begin
                     for I:=1 to NumFields do
                        begin
                        V1FieldDefinitions[I]:=AllocMem(SizeOf(TV1FieldDefinition));
                        NewFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
                        end;
                     end
                  else
                     begin
                     for I:=1 to NumFields do
                        begin
                        V123FieldDefinitions[I]:=AllocMem(SizeOf(TV123FieldDefinition));
                        NewFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
                        end;
                     end;
                  if (OldVersionNum < 3) then
                     begin
                     TempBuffer:=AllocMem(NumFields*SizeOf(TV1FieldDefinition));
                     InputFile.Read(TempBuffer^,(NumFields*SizeOf(TV1FieldDefinition)),False);
                     if WasEncrypted then
                        V123DecryptBuffer(TempBuffer^,Word(NumFields*SizeOf(TV1FieldDefinition)),
                                      FIRST_LOCK,SECOND_LOCK);
                     for I:=1 to NumFields do
                        Move((TempBuffer+((I-1)*SizeOf(TV1FieldDefinition)))^,
                             V1FieldDefinitions[I]^,SizeOf(TV1FieldDefinition));
                     end
                  else
                     begin
                     TempBuffer:=AllocMem(NumFields*SizeOf(TV123FieldDefinition));
                     InputFile.Read(TempBuffer^,(NumFields*SizeOf(TV123FieldDefinition)),False);
                     if WasEncrypted then
                        begin
                        if (OldVersionNum < 4) then
                           V123DecryptBuffer(TempBuffer^,Word(NumFields*SizeOf(TV123FieldDefinition)),
                                         FIRST_LOCK,SECOND_LOCK)
                        else
                           V123DecryptBuffer(TempBuffer^,(NumFields*SizeOf(TV123FieldDefinition)),
                                         FIRST_LOCK,SECOND_LOCK)
                        end;
                     for I:=1 to NumFields do
                        Move((TempBuffer+((I-1)*SizeOf(TV123FieldDefinition)))^,
                             V123FieldDefinitions[I]^,SizeOf(TV123FieldDefinition));
                     end;
                  try
                     TempLastPercentDone:=0;
                     DataEngine.LockLocaleSettings;
                     try
                        DataEngine.GetLocaleSettings(CurLocaleSettings);
                        try
                           DataEngine.GetDefaultLocaleSettings(NewDataHeader.LocaleID,
                                                               NewLocaleSettings);
                           DataEngine.SetLocaleSettings(NewLocaleSettings);
                           for I:=1 to NumFields do
                              begin
                              if (OldVersionNum < 3) then
                                 begin
                                 with NewFieldDefinitions[I]^ do
                                    begin
                                    FieldNum:=pV1FieldDefinition(V1FieldDefinitions[I])^.FieldNum;
                                    FieldName:=pV1FieldDefinition(V1FieldDefinitions[I])^.FieldName;
                                    Description:=pV1FieldDefinition(V1FieldDefinitions[I])^.Description;
                                    DataType:=pV1FieldDefinition(V1FieldDefinitions[I])^.DataType;
                                    SubType:=pV1FieldDefinition(V1FieldDefinitions[I])^.SubType;
                                    Length:=pV1FieldDefinition(V1FieldDefinitions[I])^.Length;
                                    Decimals:=pV1FieldDefinition(V1FieldDefinitions[I])^.Decimals;
                                    Offset:=TempOffset;
                                    Required:=pV1FieldDefinition(V1FieldDefinitions[I])^.Required;
                                    Minimum:=pV1FieldDefinition(V1FieldDefinitions[I])^.Minimum;
                                    Maximum:=pV1FieldDefinition(V1FieldDefinitions[I])^.Maximum;
                                    Default:=pV1FieldDefinition(V1FieldDefinitions[I])^.Default;
                                    CharCase:=NO_CHANGE;
                                    Compression:=NO_COMPRESSION;
                                    end;
                                 end
                              else
                                 begin
                                 with NewFieldDefinitions[I]^ do
                                    begin
                                    FieldNum:=V123FieldDefinitions[I]^.FieldNum;
                                    FieldName:=V123FieldDefinitions[I]^.FieldName;
                                    Description:=V123FieldDefinitions[I]^.Description;
                                    DataType:=V123FieldDefinitions[I]^.DataType;
                                    SubType:=V123FieldDefinitions[I]^.SubType;
                                    Length:=V123FieldDefinitions[I]^.Length;
                                    Decimals:=V123FieldDefinitions[I]^.Decimals;
                                    Offset:=TempOffset;
                                    Required:=V123FieldDefinitions[I]^.Required;
                                    Minimum:=V123FieldDefinitions[I]^.Minimum;
                                    Maximum:=V123FieldDefinitions[I]^.Maximum;
                                    Default:=V123FieldDefinitions[I]^.Default;
                                    if (OldVersionNum < 4) then
                                       CharCase:=NO_CHANGE
                                    else
                                       CharCase:=V123FieldDefinitions[I]^.CharCase;
                                    Compression:=NO_COMPRESSION;
                                    end;
                                 end;
                              { Convert BLOB sub-types to new, restricted types }
                              if (NewFieldDefinitions[I]^.DataType=TYPE_BLOB) and
                                 (not (NewFieldDefinitions[I]^.SubType in [SUBTYPE_UNKNOWN,SUBTYPE_MEMO,SUBTYPE_GRAPHIC])) then
                                 NewFieldDefinitions[I]^.SubType:=SUBTYPE_UNKNOWN;
                              if (OldVersionNum < 5) then
                                 begin
                                 NewFieldDefinitions[I]^.Minimum:=ConvertExpressionToAnsi(
                                                          NewFieldDefinitions[I]^.Minimum,
                                                          NewFieldDefinitions[I]^.DataType);
                                 NewFieldDefinitions[I]^.Maximum:=ConvertExpressionToAnsi(
                                                          NewFieldDefinitions[I]^.Maximum,
                                                          NewFieldDefinitions[I]^.DataType);
                                 NewFieldDefinitions[I]^.Default:=ConvertExpressionToAnsi(
                                                          NewFieldDefinitions[I]^.Default,
                                                          NewFieldDefinitions[I]^.DataType);
                                 end;
                              if (AnsiCompareText(NewFieldDefinitions[I].FieldName,RECORDID_FIELD_NAME)=0) or
                                 (AnsiCompareText(NewFieldDefinitions[I].FieldName,RECORDHASH_FIELD_NAME)=0) then
                                 begin
                                 DoLog('Field name '+PARSE_SINGLEQUOTE+NewFieldDefinitions[I].FieldName+PARSE_SINGLEQUOTE+
                                       ' is a reserved field name and has been changed to '+PARSE_SINGLEQUOTE+'_'+
                                       NewFieldDefinitions[I].FieldName+PARSE_SINGLEQUOTE);
                                 NewFieldDefinitions[I].FieldName:='_'+NewFieldDefinitions[I].FieldName;
                                 end;
                              UpdateFieldSize(NewFieldDefinitions[I]);
                              UpdateFieldDecimals(NewFieldDefinitions[I]);
                              Inc(TempOffset,(FLDCHG_DATA+NewFieldDefinitions[I]^.DataSize));
                              TempPercentDone:=Trunc(((I/NumFields)*100));
                              if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                 begin
                                 DoSteppedProgress('Upgrading field definitions for '+FTableName,
                                                   TempPercentDone);
                                 TempLastPercentDone:=TempPercentDone;
                                 end;
                              end;
                        finally
                           DataEngine.SetLocaleSettings(CurLocaleSettings);
                        end;
                     finally
                        DataEngine.UnlockLocaleSettings;
                     end;
                     NewDataHeader.RecordLength:=BlockOffset(TempOffset,CRYPTO_BLOCK_SIZE);
                     OutputFile.Seek(0,FROM_BOF);
                     OutputFile.Write(NewDataHeader,SizeOf(TDataHeader));
                     if (OldVersionNum <= 5) then
                        ReAllocMem(TempBuffer,(NumFields*SizeOf(TFieldDefinition)));
                     for I:=1 to NumFields do
                        Move(NewFieldDefinitions[I]^,
                             (TempBuffer+((I-1)*SizeOf(TFieldDefinition)))^,SizeOf(TFieldDefinition));
                     if WasEncrypted then
                        DataEngine.Encrypt(TempDataPassword.Data,TempBuffer,

                                          (NumFields*SizeOf(TFieldDefinition)));
                     OutputFile.Write(TempBuffer^,(NumFields*SizeOf(TFieldDefinition)));
                     if (TempLastPercentDone <> 100) then
                        DoSteppedProgress('Upgrading field definitions for '+FTableName,100);
                     DoLog('Field definitions of '+FTableName+' upgraded to '+
                           'latest table version '+DataEngine.VersionToStr(VERSION_NUMBER));
                     NewRecordBuffer:=AllocMem(NewDataHeader.RecordLength);
                     TempRecordBuffer:=AllocMem(NewDataHeader.RecordLength);
                     OldRecordBuffer:=AllocMem(OldRecordLen);
                     try
                        TempLastPercentDone:=0;
                        for I:=1 to NumRecords do
                           begin
                           InputFile.Read(OldRecordBuffer^,OldRecordLen,False);
                           if WasEncrypted then
                              V123DecryptBuffer(OldRecordBuffer^,OldRecordLen,
                                                 FIRST_LOCK,SECOND_LOCK);
                           Move(OldRecordBuffer^,NewRecordBuffer^,SizeOf(TV123RecordHeader));
                           Move(OldRecordBuffer^,TempRecordBuffer^,SizeOf(TV123RecordHeader));
                           BlobFieldNum:=1;
                           for J:=1 to NumFields do
                              begin
                              if (OldVersionNum < 3) then
                                 begin
                                 if (V1FieldDefinitions[J]^.DataType=TYPE_BLOB) then
                                    begin
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         FLDCHG_DATA+BLOBBLOCK_SIZE);
                                    NewBlockNumber:=pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^;
                                    if (NewBlockNumber > 0) then
                                       begin
                                       Dec(NewBlockNumber,SizeOf(TBlobHeader));
                                       NewBlockNumber:=((NewBlockNumber div OldBlobBlockSize)+1);
                                       pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^:=NewBlockNumber;
                                       end;
                                    TempBlobSignature:=(((I-1)*NewDataHeader.BlobFieldCount)+BlobFieldNum);
                                    Move(TempBlobSignature,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA+BLOBBLOCK_SIZE)^,
                                          SIGNATURE_SIZE);
                                    Inc(BlobFieldNum);
                                    FillChar((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                             (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize),#0);
                                    end
                                 else if (V1FieldDefinitions[J]^.DataType=TYPE_BCD) then
                                    begin
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    TempBCD:=CurrToTBCD(CompToCurr(pComp(OldRecordBuffer+
                                             V1FieldDefinitions[J]^.Offset+FLDCHG_DATA)^),
                                             V1FieldDefinitions[J]^.Decimals);
                                    Move(TempBCD,(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move(TempBCD,(TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else if (V1FieldDefinitions[J]^.DataType=TYPE_INT32) and
                                         (V1FieldDefinitions[J]^.SubType=SUBTYPE_AUTOINC) then
                                    begin
                                    Boolean((NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Boolean((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else
                                    begin
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    Move((OldRecordBuffer+V1FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    end;
                                 end
                              else if (OldVersionNum < 4) then
                                 begin
                                 if (V123FieldDefinitions[J]^.DataType=TYPE_BLOB) then
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         FLDCHG_DATA+BLOBBLOCK_SIZE);
                                    NewBlockNumber:=pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^;
                                    if (NewBlockNumber > 0) then
                                       begin
                                       Dec(NewBlockNumber,SizeOf(TBlobHeader));
                                       NewBlockNumber:=((NewBlockNumber div OldBlobBlockSize)+1);
                                       pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^:=NewBlockNumber;
                                       end;
                                    TempBlobSignature:=(((I-1)*NewDataHeader.BlobFieldCount)+BlobFieldNum);
                                    Move(TempBlobSignature,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA+BLOBBLOCK_SIZE)^,
                                          SIGNATURE_SIZE);
                                    Inc(BlobFieldNum);
                                    FillChar((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                             (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize),#0);
                                    end
                                 else if (V123FieldDefinitions[J]^.DataType=TYPE_BCD) then
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    TempBCD:=CurrToTBCD(CompToCurr(pComp(OldRecordBuffer+
                                             V123FieldDefinitions[J]^.Offset+FLDCHG_DATA)^),
                                             V123FieldDefinitions[J]^.DataDecimals);
                                    Move(TempBCD,(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move(TempBCD,(TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else if (V123FieldDefinitions[J]^.DataType=TYPE_INT32) and
                                         (V123FieldDefinitions[J]^.SubType=SUBTYPE_AUTOINC) then
                                    begin
                                    Boolean((NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Boolean((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    end;
                                 end
                              else if (OldVersionNum < 5) then
                                 begin
                                 if (V123FieldDefinitions[J]^.DataType=TYPE_BLOB) then
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         FLDCHG_DATA+BLOBBLOCK_SIZE+SIGNATURE_SIZE);
                                    NewBlockNumber:=pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^;
                                    if (NewBlockNumber > 0) then
                                       begin
                                       Dec(NewBlockNumber,SizeOf(TBlobHeader));
                                       NewBlockNumber:=((NewBlockNumber div OldBlobBlockSize)+1);
                                       pInteger(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^:=NewBlockNumber;
                                       end;
                                    FillChar((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                             (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize),#0);
                                    end
                                 else if (V123FieldDefinitions[J]^.DataType=TYPE_BCD) then
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,FLDCHG_DATA);
                                    TempBCD:=CurrToTBCD(CompToCurr(pComp(OldRecordBuffer+
                                             V123FieldDefinitions[J]^.Offset+FLDCHG_DATA)^),
                                             V123FieldDefinitions[J]^.DataDecimals);
                                    Move(TempBCD,(NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move(TempBCD,(TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else if (V123FieldDefinitions[J]^.DataType=TYPE_INT32) and
                                         (V123FieldDefinitions[J]^.SubType=SUBTYPE_AUTOINC) then
                                    begin
                                    Boolean((NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Boolean((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    end;
                                 end
                              else
                                 begin
                                 if (V123FieldDefinitions[J]^.DataType=TYPE_INT32) and
                                    (V123FieldDefinitions[J]^.SubType=SUBTYPE_AUTOINC) then
                                    begin
                                    Boolean((NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Boolean((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^):=True;
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (TempRecordBuffer+NewFieldDefinitions[J]^.Offset+FLDCHG_DATA)^,
                                         NewFieldDefinitions[J]^.DataSize);
                                    end
                                 else
                                    begin
                                    Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                         (NewRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                         (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize));
                                    if (V123FieldDefinitions[J]^.DataType <> TYPE_BLOB) then
                                       Move((OldRecordBuffer+V123FieldDefinitions[J]^.Offset)^,
                                            (TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                            (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize))
                                    else
                                       FillChar((TempRecordBuffer+NewFieldDefinitions[J]^.Offset)^,
                                                (FLDCHG_DATA+NewFieldDefinitions[J]^.DataSize),#0);
                                    end;
                                 end;
                              end;
                           PutRecordHash(MD5Buffer((TempRecordBuffer+SizeOf(TRecordHeader))^,
                                                   (NewDataHeader.RecordLength-SizeOf(TRecordHeader))),NewRecordBuffer);
                           if WasEncrypted then
                              DataEngine.Encrypt(TempDataPassword.Data,NewRecordBuffer,
                                                 NewDataHeader.RecordLength);
                           OutputFile.Write(NewRecordBuffer^,NewDataHeader.RecordLength);
                           TempPercentDone:=Trunc(((I/NumRecords)*100));
                           if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                              begin
                              DoSteppedProgress('Upgrading records for '+FTableName,
                                                TempPercentDone);
                              TempLastPercentDone:=TempPercentDone;
                              end;
                           end;
                        if (TempLastPercentDone <> 100) then
                           DoSteppedProgress('Upgrading records for '+FTableName,100);
                        DoLog(IntToStr(NumRecords)+' records of '+FTableName+' upgraded to '+
                              'latest table version '+DataEngine.VersionToStr(VERSION_NUMBER));
                     finally
                        DeAllocMem(OldRecordBuffer);
                        DeAllocMem(TempRecordBuffer);
                        DeAllocMem(NewRecordBuffer);
                     end;
                  finally
                     DeAllocMem(TempBuffer);
                     for I:=1 to NumFields do
                        begin
                        DeAllocMem(V1FieldDefinitions[I]);
                        DeAllocMem(V123FieldDefinitions[I]);
                        DeAllocMem(NewFieldDefinitions[I]);
                        end;
                  end;
               finally
                  OutputFile.CloseFile;
               end;
            finally
               InputFile.CloseFile;
            end;

            { Rename the current file to the backup extension and then
              rename the new file to the current file name }
            if (not FDataDirectory.InMemory) then
               begin
               if OSFileExists(EnsureFileExt(InputFile.FileName,DataEngine.DataExtension,
                                             DataEngine.DataUpgradeExtension),False) then
                  OSFileDelete(EnsureFileExt(InputFile.FileName,DataEngine.DataExtension,
                                             DataEngine.DataUpgradeExtension));
               end;

            InputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.DataExtension,
                                               DataEngine.DataUpgradeExtension));
            OutputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.DataUpgradeExtension,
                                                DataEngine.DataExtension));

            { Now convert the index file, if one is present }

            InputFile.FileName:=EnsureFileExt(FDataDirectory.Directory+FTableName,
                                              DataEngine.DataExtension,DataEngine.IndexExtension);
            InputFile.Exclusive:=True;
            if InputFile.Exists then
               begin
               InputFile.OpenFile;
               try
                  TempDataRootPage:=0;
                  if FDataDirectory.InMemory then
                     OutputFile.FileName:=DataEngine.GetTempFileName(INMEMORY_TEMP_NAME,
                                                          DataEngine.IndexTempExtension,FDataDirectory.InMemory,False)
                  else
                     begin
                     if DataEngine.TempTablesInDataDirectory then
                        OutputFile.FileName:=DataEngine.GetTempFileName(FDataDirectory.Directory,
                                                             DataEngine.IndexTempExtension,FDataDirectory.InMemory,False)
                     else
                        OutputFile.FileName:=DataEngine.GetTempFileName(DataSession.PrivateDirectory,
                                                             DataEngine.IndexTempExtension,FDataDirectory.InMemory,False);
                     end;
                  OutputFile.Exclusive:=True;
                  OutputFile.CreateFile;
                  try
                     TempBuffer:=nil;
                     FillChar(NewIndexHeader,SizeOf(TIndexHeader),#0);
                     FillChar(NewIndexDefinitions,SizeOf(NewIndexDefinitions),#0);
                     if (OldVersionNum < 3) then
                        begin
                        InputFile.Read(V1IndexHeader,SizeOf(TV1IndexHeader),False);
                        if WasEncrypted then
                           V123DecryptBuffer(V1IndexHeader,SizeOf(TV1IndexHeader),
                                             FIRST_LOCK,SECOND_LOCK);
                        NumIndexes:=V1IndexHeader.IndexCount;
                        end
                     else
                        begin
                        InputFile.Read(V23IndexHeader,SizeOf(TV23IndexHeader),False);
                        if WasEncrypted then
                           V123DecryptBuffer(V23IndexHeader,SizeOf(TV23IndexHeader),
                                             FIRST_LOCK,SECOND_LOCK);
                        NumIndexes:=V23IndexHeader.IndexCount;
                        end;
                     if (OldVersionNum < 3) then
                        begin
                        with NewIndexHeader do
                           begin
                           UpdateStamp:=V1IndexHeader.UpdateStamp;
                           VersionNum:=VERSION_NUMBER;
                           FileSignature:=DataEngine.SignatureDigest;
                           NextEndingPage:=1;
                           NextFreePage:=0;
                           IndexCount:=NumIndexes;
                           TempLastPercentDone:=0;
                           for I:=0 to NumIndexes do
                              begin
                              with NewIndexDefinitions[I] do
                                 begin
                                 IndexName:=V1IndexHeader.IndexesList[I].IndexName;
                                 KeySize:=V1IndexHeader.IndexesList[I].KeySize;
                                 KeyDescending:=V1IndexHeader.IndexesList[I].KeyDescending;
                                 KeyCaseInsensitive:=V1IndexHeader.IndexesList[I].KeyCaseInsensitive;
                                 KeyUnique:=V1IndexHeader.IndexesList[I].KeyUnique;
                                 KeyCompressionType:=NO_COMPRESS;
                                 KeyFieldCount:=V1IndexHeader.IndexesList[I].KeyFieldCount;
                                 if KeyDescending then
                                    FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#1)
                                 else
                                    FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                                 for J:=1 to OLD_MAX_NUM_FLDSINKEY do
                                    KeyFields[J]:=V1IndexHeader.IndexesList[I].KeyFields[J];
                                 NoKeyStatistics:=False;
                                 IndexChanged:=False;
                                 RemoveIndex:=False;
                                 end;
                              if (I <> 0) then
                                 begin
                                 TempPercentDone:=Trunc(((I/IndexCount)*100));
                                 if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                    begin
                                    DoSteppedProgress('Upgrading index definitions for '+FTableName,
                                                      TempPercentDone);
                                    TempLastPercentDone:=TempPercentDone;
                                    end;
                                 end;
                              end;
                           end;
                        end
                     else
                        begin
                        with NewIndexHeader do
                           begin
                           UpdateStamp:=V23IndexHeader.UpdateStamp;
                           VersionNum:=VERSION_NUMBER;
                           FileSignature:=DataEngine.SignatureDigest;
                           NextEndingPage:=1;
                           NextFreePage:=0;
                           IndexCount:=NumIndexes;
                           TempLastPercentDone:=0;
                           for I:=0 to NumIndexes do
                              begin
                              with NewIndexDefinitions[I] do
                                 begin
                                 IndexName:=V23IndexHeader.IndexesList[I].IndexName;
                                 KeySize:=V23IndexHeader.IndexesList[I].KeySize;
                                 KeyDescending:=V23IndexHeader.IndexesList[I].KeyDescending;
                                 KeyCaseInsensitive:=V23IndexHeader.IndexesList[I].KeyCaseInsensitive;
                                 KeyUnique:=V23IndexHeader.IndexesList[I].KeyUnique;
                                 KeyCompressionType:=V23IndexHeader.IndexesList[I].KeyCompressionType;
                                 KeyFieldCount:=V23IndexHeader.IndexesList[I].KeyFieldCount;
                                 if KeyDescending then
                                    FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#1)
                                 else
                                    FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                                 for J:=1 to OLD_MAX_NUM_FLDSINKEY do
                                    KeyFields[J]:=V23IndexHeader.IndexesList[I].KeyFields[J];
                                 NoKeyStatistics:=False;
                                 IndexChanged:=False;
                                 RemoveIndex:=False;
                                 end;
                              if (I <> 0) then
                                 begin
                                 TempPercentDone:=Trunc(((I/IndexCount)*100));
                                 if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                    begin
                                    DoSteppedProgress('Upgrading index definitions for '+FTableName,
                                                      TempPercentDone);
                                    TempLastPercentDone:=TempPercentDone;
                                    end;
                                 end;
                              end;
                           { Be sure to add the primary index if one doesn't exist }
                           if V23IndexHeader.NoPrimaryIndex then
                              begin
                              with NewIndexDefinitions[0] do
                                 begin
                                 IndexName:='';
                                 KeyUnique:=True;
                                 KeyDescending:=False;
                                 KeyCaseInsensitive:=False;
                                 KeyFieldCount:=1;
                                 FillChar(KeyFields,SizeOf(TKeyFields),#0);
                                 KeyFields[1]:=RECORDID_FIELD_NUM;
                                 KeySize:=AUTO_PRIMARYKEY_SIZE;
                                 FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                                 NoKeyStatistics:=False;
                                 KeyCompressionType:=NO_COMPRESS;
                                 end;
                              end;
                           { Move over the text index if it exists }
                           if (OldVersionNum < 5) then
                              begin
                              with NewIndexDefinitions[TEXT_INDEX_POS] do
                                 begin
                                 IndexName:=TEXT_INDEX_NAME;
                                 KeySize:=TEXT_KEY_SIZE;
                                 KeyDescending:=False;
                                 KeyCaseInsensitive:=False;
                                 KeyUnique:=False;
                                 KeyCompressionType:=BOTH_COMPRESS;
                                 KeyFieldCount:=0;
                                 FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                                 FillChar(KeyFields,SizeOf(TKeyFields),#0);
                                 NoKeyStatistics:=True;
                                 IndexChanged:=False;
                                 RemoveIndex:=False;
                                 end;
                              end
                           else
                              begin
                              TempDataRootPage:=V23IndexHeader.IndexesList[OLD_TEXT_INDEX_POS].DataRootPage;
                              with NewIndexDefinitions[TEXT_INDEX_POS] do
                                 begin
                                 IndexName:=TEXT_INDEX_NAME;
                                 KeySize:=TEXT_KEY_SIZE;
                                 KeyDescending:=False;
                                 KeyCaseInsensitive:=False;
                                 KeyUnique:=False;
                                 KeyCompressionType:=BOTH_COMPRESS;
                                 KeyFieldCount:=V23IndexHeader.IndexesList[OLD_TEXT_INDEX_POS].KeyFieldCount;
                                 FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                                 for J:=1 to OLD_MAX_NUM_FLDSINKEY do
                                    KeyFields[J]:=V23IndexHeader.IndexesList[OLD_TEXT_INDEX_POS].KeyFields[J];
                                 NoKeyStatistics:=True;
                                 IndexChanged:=False;
                                 RemoveIndex:=False;
                                 end;
                              if (TempDataRootPage <> 0) then
                                 NewIndexHeader.DataRootPages[TEXT_INDEX_POS]:=1
                              else
                                 NewIndexHeader.DataRootPages[TEXT_INDEX_POS]:=0;
                              end;
                           end;
                        end;
                     if WasEncrypted then
                        DataEngine.Encrypt(TempDataPassword.Data,PChar(@NewIndexHeader),
                                           SizeOf(TIndexHeader));
                     OutputFile.Seek(0,FROM_BOF);
                     OutputFile.Write(NewIndexHeader,SizeOf(TIndexHeader));
                     if WasEncrypted then
                        DataEngine.Encrypt(TempDataPassword.Data,@NewIndexDefinitions,
                                           SizeOf(NewIndexDefinitions));
                     OutputFile.Write(NewIndexDefinitions,SizeOf(NewIndexDefinitions));
                     if (TempLastPercentDone <> 100) then
                        DoSteppedProgress('Upgrading index definitions for '+FTableName,100);
                     DoLog('Index definitions of '+FTableName+' upgraded to '+
                           'latest table version '+DataEngine.VersionToStr(VERSION_NUMBER));
                     if WasEncrypted then
                        DataEngine.Decrypt(TempDataPassword.Data,PChar(@NewIndexHeader),
                                           SizeOf(TIndexHeader));
                     { Be sure to bring over the text index data pages, if the exist }
                     if (TempDataRootPage <> 0) then
                        begin
                        NewPageBuffer:=AllocMem(DEFAULT_PAGE_SIZE);
                        try
                           NewDataRootPage:=1;
                           while (TempDataRootPage <> 0) do
                              begin
                              InputFile.Seek(Int64(SizeOf(TV23IndexHeader))+
                                             Int64(((TempDataRootPage*DEFAULT_PAGE_SIZE)-DEFAULT_PAGE_SIZE)),FROM_BOF);
                              InputFile.Read(NewPageBuffer^,DEFAULT_PAGE_SIZE,False);
                              if WasEncrypted then
                                 begin
                                 V123DecryptBuffer(NewPageBuffer^,DEFAULT_PAGE_SIZE,
                                                   FIRST_LOCK,SECOND_LOCK);
                                 TempDataRootPage:=pPageHeader(NewPageBuffer)^.RightNumber;
                                 DataEngine.Encrypt(TempDataPassword.Data,NewPageBuffer,DEFAULT_PAGE_SIZE);
                                 end
                              else
                                 TempDataRootPage:=pPageHeader(NewPageBuffer)^.RightNumber;
                              OutputFile.Seek(Int64(SizeOf(TIndexHeader))+
                                             Int64(SizeOf(TIndexDefinition)*(MAX_NUM_INDEXES+1))+
                                             Int64(((NewDataRootPage*DEFAULT_PAGE_SIZE)-DEFAULT_PAGE_SIZE)),FROM_BOF);
                              OutputFile.Write(NewPageBuffer^,DEFAULT_PAGE_SIZE);
                              Inc(NewDataRootPage);
                              end;
                           { Reset the next ending page number }
                           NewIndexHeader.NextEndingPage:=NewDataRootPage;
                           if WasEncrypted then
                              DataEngine.Encrypt(TempDataPassword.Data,PChar(@NewIndexHeader),SizeOf(TIndexHeader));
                           OutputFile.Seek(0,FROM_BOF);
                           OutputFile.Write(NewIndexHeader,SizeOf(TIndexHeader));
                        finally
                           DeAllocMem(NewPageBuffer);
                        end;
                        end;
                  finally
                     OutputFile.CloseFile;
                  end;
               finally
                  InputFile.CloseFile;
               end;

               { Rename the current file to the backup extension and then
                 rename the new file to the current file name }
               if (not FDataDirectory.InMemory) then
                  begin
                  if OSFileExists(EnsureFileExt(InputFile.FileName,DataEngine.IndexExtension,
                                                DataEngine.IndexUpgradeExtension),False) then
                     OSFileDelete(EnsureFileExt(InputFile.FileName,DataEngine.IndexExtension,
                                                DataEngine.IndexUpgradeExtension));
                  end;
               InputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.IndexExtension,
                                                  DataEngine.IndexUpgradeExtension));
               OutputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.IndexUpgradeExtension,
                                                   DataEngine.IndexExtension));
               end;

            { Now convert the BLOB file, if one is present }

            if AreBlobsPresent then
               begin
               InputFile.FileName:=EnsureFileExt(FDataDirectory.Directory+FTableName,
                                                 DataEngine.DataExtension,DataEngine.BlobExtension);
               InputFile.Exclusive:=True;
               InputFile.OpenFile;
               try
                  InputFile.Read(V123BlobHeader,SizeOf(TV123BlobHeader),False);
                  if WasEncrypted then
                     V123DecryptBuffer(V123BlobHeader,SizeOf(TV123BlobHeader),
                                        FIRST_LOCK,SECOND_LOCK);
                  with NewBlobHeader do
                     begin
                     UpdateStamp:=V123BlobHeader.UpdateStamp;
                     VersionNum:=VERSION_NUMBER;
                     FileSignature:=DataEngine.SignatureDigest;
                     NextFreeBlock:=V123BlobHeader.NextFreeBlock;
                     NextEndingBlock:=V123BlobHeader.NextEndingBlock;
                     if (OldVersionNum < 5) then
                        begin
                        NewBlockNumber:=NextEndingBlock;
                        if (NewBlockNumber <> 0) then
                           begin
                           Dec(NewBlockNumber,SizeOf(TBlobHeader));
                           NextEndingBlock:=((NewBlockNumber div OldBlobBlockSize)+1);
                           end;
                        NewBlockNumber:=NextFreeBlock;
                        if (NewBlockNumber <> 0) then
                           begin
                           Dec(NewBlockNumber,SizeOf(TBlobHeader));
                           NextFreeBlock:=((NewBlockNumber div OldBlobBlockSize)+1);
                           end;
                        end;
                     NumBlocks:=(NextEndingBlock-1);
                     end;
                  DoLog('BLOB header of '+FTableName+' upgraded to '+
                        'latest table version '+DataEngine.VersionToStr(VERSION_NUMBER));
                  if FDataDirectory.InMemory then
                     OutputFile.FileName:=DataEngine.GetTempFileName(INMEMORY_TEMP_NAME,
                                                          DataEngine.BlobTempExtension,FDataDirectory.InMemory,False)
                  else
                     begin
                     if DataEngine.TempTablesInDataDirectory then
                        OutputFile.FileName:=DataEngine.GetTempFileName(FDataDirectory.Directory,
                                                             DataEngine.BlobTempExtension,FDataDirectory.InMemory,False)
                     else
                        OutputFile.FileName:=DataEngine.GetTempFileName(DataSession.PrivateDirectory,
                                                             DataEngine.BlobTempExtension,FDataDirectory.InMemory,False);
                     end;
                  OutputFile.Exclusive:=True;
                  OutputFile.CreateFile;
                  try
                     if WasEncrypted then
                        DataEngine.Encrypt(TempDataPassword.Data,PChar(@NewBlobHeader),
                                           SizeOf(TBlobHeader));
                     OutputFile.Seek(0,FROM_BOF);
                     OutputFile.Write(NewBlobHeader,SizeOf(TBlobHeader));
                     NewBlockBuffer:=AllocMem(NewBlobBlockSize);
                     try
                        TempLastPercentDone:=0;
                        for I:=1 to NumBlocks do
                           begin
                           InputFile.Read(NewBlockBuffer^,OldBlobBlockSize,False);
                           if WasEncrypted then
                              begin
                              V123DecryptBuffer(NewBlockBuffer^,SizeOf(TBlockHeader),
                                                 FIRST_LOCK,SECOND_LOCK);
                              V123DecryptBuffer((NewBlockBuffer+SizeOf(TBlockHeader))^,
                                                (OldBlobBlockSize-SizeOf(TBlockHeader)),
                                                 FIRST_LOCK,SECOND_LOCK);
                              end;
                           if (OldVersionNum < 5) then
                              begin
                              with pBlockHeader(NewBlockBuffer)^ do
                                 begin
                                 NewBlockNumber:=PrevNumber;
                                 if (NewBlockNumber > 0) then
                                    begin
                                    Dec(NewBlockNumber,SizeOf(TBlobHeader));
                                    NewBlockNumber:=((NewBlockNumber div OldBlobBlockSize)+1);
                                    PrevNumber:=NewBlockNumber;
                                    end;
                                 NewBlockNumber:=NextNumber;
                                 if (NewBlockNumber > 0) then
                                    begin
                                    Dec(NewBlockNumber,SizeOf(TBlobHeader));
                                    NewBlockNumber:=((NewBlockNumber div OldBlobBlockSize)+1);
                                    NextNumber:=NewBlockNumber;
                                    end;
                                 end;
                              end;
                           if WasEncrypted then
                              DataEngine.Encrypt(TempDataPassword.Data,NewBlockBuffer,
                                                 NewBlobBlockSize);
                           OutputFile.Write(NewBlockBuffer^,NewBlobBlockSize);
                           TempPercentDone:=Trunc(((I/NumBlocks)*100));
                           if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                              begin
                              DoSteppedProgress('Upgrading BLOB blocks for '+FTableName,
                                                TempPercentDone);
                              TempLastPercentDone:=TempPercentDone;
                              end;
                           end;
                        if (TempLastPercentDone <> 100) then
                           DoSteppedProgress('Upgrading BLOB blocks for '+FTableName,100);
                        DoLog(IntToStr(NumBlocks)+' BLOB blocks of '+FTableName+' upgraded to '+
                              'latest table version '+DataEngine.VersionToStr(VERSION_NUMBER));
                     finally
                        DeAllocMem(NewBlockBuffer);
                     end;
                  finally
                     OutputFile.CloseFile;
                  end;
               finally
                  InputFile.CloseFile;
               end;

               { Rename the current file to the backup extension and then
                 rename the new file to the current file name }
               if (not FDataDirectory.InMemory) then
                  begin
                  if OSFileExists(EnsureFileExt(InputFile.FileName,DataEngine.BlobExtension,
                                                DataEngine.BlobUpgradeExtension),False) then
                     OSFileDelete(EnsureFileExt(InputFile.FileName,DataEngine.BlobExtension,
                                                DataEngine.BlobUpgradeExtension));
                  end;
               InputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.BlobExtension,
                                                  DataEngine.BlobUpgradeExtension));
               OutputFile.RenameFile(EnsureFileExt(InputFile.FileName,DataEngine.BlobUpgradeExtension,
                                                   DataEngine.BlobExtension));
               end;

            RepairTable(False,True,SendProgress,SendLog,True);

            DoLog('Upgrade of table '+FTableName+' to version '+
                  DataEngine.VersionToStr(VERSION_NUMBER)+' completed at '+
                  DateTimeToStr(Now));

            FSteppedProgressCallback:=nil;
            FSteppedProgressClientData:=0;
            FLogCallback:=nil;
            FLogClientData:=0;

         finally
            OutputFile.Free;
         end;
      finally
         InputFile.Free;
      end;
      end;
end;

function TDataCursor.ConvertExpressionToAnsi(const ExprStr: string;
                                             FieldType: Word): string;
begin
   Result:=ExprStr;
   if (not (FieldType in [TYPE_ZSTRING,TYPE_BYTES,TYPE_VARBYTES,
                          TYPE_BOOL,TYPE_UINT16,TYPE_INT16,
                          TYPE_INT32,TYPE_INT64])) and (ExprStr <> '') then
      begin
      case FieldType of
         TYPE_FLOAT:
            Result:=AnsiFloatToStr(StrToFloat(ExprStr));
         TYPE_BCD:
            Result:=AnsiCurrToStr(StrToCurr(ExprStr));
         TYPE_TIMESTAMP:
            begin
            if (AnsiCompareText(ExprStr,PARSE_NOW)=0) then
               Result:=PARSE_CURDATETIME
            else if (AnsiCompareText(ExprStr,PARSE_DATE)=0) then
               Result:=PARSE_CURDATE
            else if (AnsiCompareText(ExprStr,PARSE_TIME)=0) then
               Result:=PARSE_CURTIME
            else
               begin
               if IsADateTimeNonAnsi(ExprStr) then
                  Result:=AnsiDateTimeToStr(StrToDate(ExprStr),True)
               else if IsADateNonAnsi(ExprStr) then
                  Result:=AnsiDateToStr(StrToDate(ExprStr))
               else if IsATimeNonAnsi(ExprStr) then
                  Result:=AnsiTimeToStr(StrToTime(ExprStr),True);
               end;
            end;
         TYPE_TIME:
            begin
            if (AnsiCompareText(ExprStr,PARSE_TIME)=0) then
               Result:=PARSE_CURTIME
            else
               begin
               if IsATimeNonAnsi(ExprStr) then
                  Result:=AnsiTimeToStr(StrToTime(ExprStr),True);
               end;
            end;
         TYPE_DATE:
            begin
            if (AnsiCompareText(ExprStr,PARSE_DATE)=0) then
               Result:='CURRENT_DATE'
               { Had to use literal because Kylix 2 won't
                 compile the following line without an
                 internal compiler error                
               Result:=PARSE_CURDATE}
            else
               begin
               if IsADateNonAnsi(ExprStr) then
                  Result:=AnsiDateToStr(StrToDate(ExprStr));
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.UpdateDataHeader(NewLocaleID: Integer;
                                       NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                       NewEncrypted: Boolean; const NewPassword: string;
                                       const NewDescription: string;
                                       NewIndexPageSize: Integer;
                                       NewBlobBlockSize: Integer;
                                       NewLastAutoIncID: Integer);
begin
   FDataTable.UpdateDataHeader(NewLocaleID,
                               NewUserMajorVersion,NewUserMinorVersion,
                               NewEncrypted,NewPassword,
                               NewDescription,
                               NewIndexPageSize,NewBlobBlockSize,
                               NewLastAutoIncID);
end;

procedure TDataCursor.GetDataHeader(var Header: TDataHeader;
                                    var Password: string);
var
   TempFile: TEngineFile;
   TempPassword: string;
   TempDescription: string;
   TempDataPassword: TDataPassword;
   V123DataHeader: TV123DataHeader;
begin
   Password:='';
   if FIsOpen then
      begin
      FDataTable.GetDataHeader(Header);
      TempDataPassword:=DataSession.CheckForDigest(Header.Digest);
      if (TempDataPassword <> nil) then
         Password:=TempDataPassword.Password;
      end
   else
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_GETDATAHEADER);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FTableName[1],Length(FTableName));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(Header);
            Password[0]:=Char(Byte(Unpack(Password[1])));
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         TempFile:=TEngineFile.Create(Self);
         try
            with TempFile do
               begin
               FileName:=EnsureFileExt(FDataDirectory.Directory+FTableName,
                                       DataEngine.DataExtension,DataEngine.DataExtension);
               Exclusive:=False;
               ReadOnly:=False;
               InMemory:=FDataDirectory.InMemory;
               OpenFile;
               try
                  LockFile;
                  try
                     TempPassword:='';
                     Seek(0,FROM_BOF);
                     Read(Header,SizeOf(TDataHeader),False);
                     { Check the version information }
                     if DataEngine.ValidVersion(Header.VersionNum) then
                        begin
                        if (Header.VersionNum <> VERSION_NUMBER) then
                           begin
                           Seek(0,FROM_BOF);
                           Read(V123DataHeader,SizeOf(TV123DataHeader),False);
                           FillChar(Header,SizeOf(TDataHeader),#0);
                           with Header do
                              begin
                              UpdateStamp:=V123DataHeader.UpdateStamp;
                              VersionNum:=V123DataHeader.VersionNum;
                              FileSignature:=DataEngine.SignatureDigest;
                              NextFreeRecord:=V123DataHeader.NextFreeRecord;
                              NextEndingRecord:=V123DataHeader.NextEndingRecord;
                              LastRecordID:=V123DataHeader.LastRecordID;
                              LastAutoIncID:=V123DataHeader.LastRecordID;
                              RecordCount:=0; { ignore, not used }
                              RecordLength:=V123DataHeader.RecordLength;
                              FieldCount:=V123DataHeader.FieldCount;
                              BlobFieldCount:=V123DataHeader.BlobFieldCount;
                              BlobBlockSize:=V123DataHeader.BlobBlockSize;
                              LastBlobSignature:=V123DataHeader.LastBlobSignature;
                              IndexPageSize:=DEFAULT_PAGE_SIZE;
                              LastUpdated:=V123DataHeader.LastUpdated;
                              Description:=V123DataHeader.Description;
                              Encrypted:=V123DataHeader.Encrypted;
                              if Encrypted then
                                 begin
                                 TempPassword:=V123DataHeader.Password;
                                 V123DecryptBuffer(TempPassword[1],Length(TempPassword),
                                                   PASSWORD_LOCK1,PASSWORD_LOCK2);
                                 TempDescription:=V123DataHeader.Description;
                                 V123DecryptBuffer(TempDescription[1],Length(TempDescription),
                                                   PASSWORD_LOCK1,PASSWORD_LOCK2);
                                 Description:=TempDescription;
                                 end;
                              FillChar(Digest,SizeOf(TMD5Digest),#0);
                              LocaleID:=OSLocaleID(V123DataHeader.LanguageID,V123DataHeader.SortID);
                              UserMajorVersion:=V123DataHeader.UserMajorVersion;
                              UserMinorVersion:=V123DataHeader.UserMinorVersion;
                              end;
                           end
                        else if (not MD5DigestCompare(Header.FileSignature,DataEngine.SignatureDigest)) and
                                (not MD5DigestCompare(Header.FileSignature,MD5String(DBISAM_SIGNATURE))) then
                           DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                                                 TableName);
                        end
                     else
                        DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                                              TableName);
                  finally
                     UnlockFile;
                  end;
                  if Header.Encrypted then
                     begin
                     if (TempPassword <> '') then
                        begin
                        while True do
                           begin
                           if (not DataSession.CheckForPassword(TempPassword)) then
                              begin
                              if (not DataSession.AskForPassword) then
                                 DataEngine.RaiseError(DBISAM_NOTSUFFTABLERIGHTS,'','',ProperDataDirectoryName,
                                                       FTableName);
                              end
                           else
                              begin
                              Password:=TempPassword;
                              Break;
                              end;
                           end;
                        end
                     else
                        begin
                        while True do
                           begin
                           TempDataPassword:=DataSession.CheckForDigest(Header.Digest);
                           if (TempDataPassword=nil) then
                              begin
                              if (not DataSession.AskForPassword) then
                                 DataEngine.RaiseError(DBISAM_NOTSUFFTABLERIGHTS,'','',ProperDataDirectoryName,
                                                       FTableName);
                              end
                           else
                              begin
                              Password:=TempDataPassword.Password;
                              Break;
                              end;
                           end;
                        end;
                     end;
               finally
                  CloseFile;
               end;
               end;
         finally
            TempFile.Free;
         end;
         end;
      end;
end;

procedure TDataCursor.GetIndexHeader(var Header: TIndexHeader);
begin
   if FIsOpen then
      FDataTable.GetIndexHeader(Header)
end;

procedure TDataCursor.GetBlobHeader(var Header: TBlobHeader);
begin
   if FIsOpen then
      FDataTable.GetBlobHeader(Header)
end;

function TDataCursor.RepairBlob(VerifyOnly: Boolean;
                                var BlobBlock: Integer;
                                BlobSignature: Integer;
                                RecordNum: Integer;
                                RecordID: Integer;
                                FixBlobSignatures: Boolean): Boolean;
var
   ProposedBlobSize: Integer;
   ActualBlobSize: Integer;
   CurrentBlock: TBlock;
   NextBlock: TBlock;
   DesiredBytes: Word;
begin
   Result:=True;
   if (BlobBlock=0) then
      Exit;
   GetBlock(BlobBlock,False,1,CurrentBlock);
   try
      { First check to see if we have a mismatch BLOB signature
        on the first block }
      if (CurrentBlock.Signature <> BlobSignature) then
         begin
         if FixBlobSignatures then
            CurrentBlock.Signature:=BlobSignature
         else
            begin
            if VerifyOnly then
               DoLog('Invalid BLOB offset '+
                     'in BLOB file for physical record # '+
                     IntToStr(RecordNum)+
                     ' (logical record ID of '+IntToStr(RecordID)+')')
            else
               begin
               DoLog('Invalid BLOB offset '+
                     'in BLOB file for physical record # '+
                     IntToStr(RecordNum)+
                     ' (logical record ID of '+IntToStr(RecordID)+'), '+
                     'error fixed');
               BlobBlock:=0;
               end;
            Result:=False;
            Exit;
            end;
         end;
      ProposedBlobSize:=CurrentBlock.TotalLength;
      ActualBlobSize:=0;
      { Zero out the previous block offset }
      if (not VerifyOnly) then
         CurrentBlock.PrevNumber:=0;
      if (ProposedBlobSize > 0) then
         begin
         while (CurrentBlock.NextNumber <> 0) do
            begin
            DesiredBytes:=MinimumInteger(BlobBlockBufferSize,
                                           (ProposedBlobSize-ActualBlobSize));
            { If the current block length is too small, then
              zero it out }
            if (CurrentBlock.Length <> DesiredBytes) then
               begin
               if VerifyOnly then
                  DoLog('Invalid block size '+
                        'in BLOB file for physical record # '+
                        IntToStr(RecordNum)+
                        ' (logical record ID of '+IntToStr(RecordID)+')')
               else
                  begin
                  DoLog('Invalid block size '+
                        'in BLOB file for physical record # '+
                        IntToStr(RecordNum)+
                        ' (logical record ID of '+IntToStr(RecordID)+'), '+
                        'error fixed');
                  CurrentBlock.NextNumber:=0;
                  end;
               Result:=False;
               Break;
               end
            { If the next block offset is out of bounds then zero it out }
            else if (CurrentBlock.NextNumber > PhysicalBlocksUsed) or
                    (CurrentBlock.NextNumber < 1) then
               begin
               if VerifyOnly then
                  DoLog('Invalid intra-block pointer '+
                        'in BLOB file for physical record # '+
                        IntToStr(RecordNum)+
                        ' (logical record ID of '+IntToStr(RecordID)+')')
               else
                  begin
                  DoLog('Invalid intra-block pointer '+
                        'in BLOB file for physical record # '+
                        IntToStr(RecordNum)+
                        ' (logical record ID of '+IntToStr(RecordID)+'), '+
                        'error fixed');
                  CurrentBlock.NextNumber:=0;
                  end;
               Result:=False;
               Break;
               end
            else
               begin
               { Now proceed to go to the next block and
                 verify it's information }
               GetBlock(CurrentBlock.NextNumber,True,
                        GetBlockCount(ProposedBlobSize-ActualBlobSize),
                        NextBlock);
               try
                  { Check for accidental recursion or a mismatched
                    record number }
                  if (NextBlock.UseCount > 1) then
                     begin
                     PutBlock(NextBlock);
                     if VerifyOnly then
                        DoLog('Recursive intra-block pointer '+
                              'in BLOB file for physical record # '+
                              IntToStr(RecordNum)+
                              ' (logical record ID of '+IntToStr(RecordID)+')')
                     else
                        begin
                        DoLog('Recursive intra-block pointer '+
                              'in BLOB file for physical record # '+
                              IntToStr(RecordNum)+
                              ' (logical record ID of '+IntToStr(RecordID)+'), '+
                              'error fixed');
                        CurrentBlock.NextNumber:=0;
                        end;
                     Result:=False;
                     Break;
                     end
                  else if (NextBlock.Signature <> BlobSignature) then
                     begin
                     if FixBlobSignatures then
                        NextBlock.Signature:=BlobSignature
                     else
                        begin
                        if VerifyOnly then
                           DoLog('Invalid intra-block pointer '+
                                 'in BLOB file for physical record # '+
                                 IntToStr(RecordNum)+
                                 ' (logical record ID of '+IntToStr(RecordID)+')')
                        else
                           begin
                           DoLog('Invalid intra-block pointer '+
                                 'in BLOB file for physical record # '+
                                 IntToStr(RecordNum)+
                                 ' (logical record ID of '+IntToStr(RecordID)+'), '+
                                 'error fixed');
                           CurrentBlock.NextNumber:=0;
                           end;
                        Result:=False;
                        Break;
                        end;
                     end;
                  { Increment the total size }
                  Inc(ActualBlobSize,CurrentBlock.Length);
                  { And also update the previous block offset }
                  if (not VerifyOnly) then
                     NextBlock.PrevNumber:=CurrentBlock.Number;
               finally
                  PutBlock(CurrentBlock);
                  CurrentBlock:=NextBlock;
               end;
               end;
            end;
         { Increment the total size }
         Inc(ActualBlobSize,CurrentBlock.Length);
         if (ActualBlobSize <> ProposedBlobSize) then
            begin
            PutBlock(CurrentBlock);
            if VerifyOnly then
               DoLog('BLOB size mismatch '+
                     'in BLOB file for physical record # '+
                     IntToStr(RecordNum)+
                     ' (logical record ID of '+IntToStr(RecordID)+')')
            else
               begin
               GetBlock(BlobBlock,False,1,CurrentBlock);
               CurrentBlock.TotalLength:=ActualBlobSize;
               DoLog('BLOB size mismatch '+
                     'in BLOB file for physical record # '+
                     IntToStr(RecordNum)+
                     ' (logical record ID of '+IntToStr(RecordID)+'), '+
                     'error fixed');
               end;
            Result:=False;
            end;
         end
      else
         begin
         if VerifyOnly then
            DoLog('BLOB size mismatch '+
                  'in BLOB file for physical record # '+
                  IntToStr(RecordNum)+
                  ' (logical record ID of '+IntToStr(RecordID)+')')
         else
            begin
            DoLog('BLOB size mismatch '+
                  'in BLOB file for physical record # '+
                  IntToStr(RecordNum)+
                  ' (logical record ID of '+IntToStr(RecordID)+'), '+
                  'error fixed');
            BlobBlock:=0;
            end;
         Result:=False;
         end;
   finally
      PutBlock(CurrentBlock);
   end;
end;

function TDataCursor.GetCachedUpdatesCursor: TDataCursor;
var
   I: Word;
   J: Word;
   TempFieldCount: Word;
   TempFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   TempIndexCount: Byte;
   TempIndexDefinitions: array [0..MAX_NUM_INDEXES] of pIndexDefinition;
   IndexValid: Boolean;
   RemovePassword: Boolean;
begin
   if (FCacheDataCursor <> nil) then
      Result:=FCacheDataCursor
   else
      begin
      try
         if (FCacheDataSession=nil) then
            DataEngine.StartDataSession(FCacheDataSession);
         if (FCacheDataDirectory=nil) then
            FCacheDataDirectory:=FCacheDataSession.OpenDataDirectory('',
                                 FCacheDataSession.PrivateDirectory,False,False);
         FCacheDataCursor:=TDataCursor.Create(FCacheDataDirectory,False);
         TempFieldCount:=0;
         FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
         for I:=1 to PhysicalFieldCount do
            begin
            TempFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
            if (not GetPhysicalFieldDefinition(I)^.Hidden) then
               begin
               TempFieldDefinitions[I]^:=GetPhysicalFieldDefinition(I)^;
               Inc(TempFieldCount);
               end;
            end;
         TempIndexCount:=0;
         FillChar(TempIndexDefinitions,SizeOf(TempIndexDefinitions),#0);
         for I:=0 to IndexCount do
            begin
            { Check to make sure that a given index is still
              valid, which is sometimes not the case with live
              queries that have field mappings installed }
            IndexValid:=True;
            with GetIndexDefinition(I)^ do
               begin
               for J:=1 to KeyFieldCount do
                  begin
                  if (KeyFields[J] > FieldCount) and
                     (KeyFields[J] <> RECORDID_FIELD_NUM) and
                     (KeyFields[J] <> RECORDHASH_FIELD_NUM) then
                     begin
                     IndexValid:=False;
                     Break;
                     end;
                  end;
               end;
            if IndexValid then
               begin
               TempIndexDefinitions[TempIndexCount]:=AllocMem(SizeOf(TIndexDefinition));
               TempIndexDefinitions[TempIndexCount]^:=GetIndexDefinition(I)^;
               Inc(TempIndexCount)
               end;
            end;
         if (TempIndexCount > 0) then
            Dec(TempIndexCount);
         TempIndexDefinitions[TEXT_INDEX_POS]:=AllocMem(SizeOf(TIndexDefinition));
         TempIndexDefinitions[TEXT_INDEX_POS]^:=GetIndexDefinition(TEXT_INDEX_POS)^;
         try
            with FCacheDataCursor do
               begin
               TableName:=ExtractFileRoot(DataDirectory.GetTempDataTableName,DataEngine.DataExtension);
               ErrorTableName:=Self.TableName;
               CachedUpdates:=True;
               Temporary:=True;
               Exclusive:=True;
               SuppressTriggers:=True;
               RemovePassword:=False;
               if Self.Encrypted then
                  begin
                  if not DataSession.CheckForPassword(Self.Password) then
                     begin
                     DataSession.AddPassword(Self.Password);
                     RemovePassword:=True;
                     end;
                  end;
               try
                  CreateTable(Self.LocaleID,Self.UserMajorVersion,Self.UserMinorVersion,
                              Self.Encrypted,Self.Password,
                              Self.Description,
                              Self.IndexPageSize,Self.BlobBlockSize,
                              Self.LastAutoIncID,
                              Self.TextStopWords,Self.TextSpaceChars,
                              Self.TextIncludeChars,True,
                              TempFieldCount,TempFieldDefinitions,
                              TempIndexCount,TempIndexDefinitions);
                  OpenCursor(False);
                  IndexName:=Self.IndexName;
               finally
                  if Self.Encrypted and RemovePassword then
                     DataSession.DeletePassword(Self.Password);
               end;
               end;
            { Now install any field mappings, if necessary }
            if (FResultSet and FSourceTable) then
               begin
               for I:=1 to TempFieldCount do
                  DeAllocMem(TempFieldDefinitions[I]);
               TempFieldCount:=0;
               FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
               for I:=1 to FFieldCount do
                  begin
                  TempFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
                  if (not FFieldDefinitions[I]^.Hidden) then
                     begin
                     TempFieldDefinitions[I]^:=FFieldDefinitions[I]^;
                     Inc(TempFieldCount);
                     end;
                  end;
               FCacheDataCursor.SetFieldMapping(TempFieldCount,TempFieldDefinitions);
               end;
            Result:=FCacheDataCursor;
         finally
            for I:=1 to TempFieldCount do
               DeAllocMem(TempFieldDefinitions[I]);
            for I:=0 to TempIndexCount do
               DeAllocMem(TempIndexDefinitions[I]);
            DeAllocMem(TempIndexDefinitions[TEXT_INDEX_POS]);
         end;
      except
         FreeCachedUpdates;
         raise;
      end;
      end;
   PopulateCachedUpdates;
end;

procedure TDataCursor.PopulateCachedUpdates;
var
   CacheDataBuffer: PChar;
   CacheDataBufferSize: Integer;
begin
   FCacheDataCursor.CachedUpdates:=False;
   try
      CacheDataBuffer:=nil;
      CacheDataBufferSize:=0;
      SaveToStream(CacheDataBuffer,CacheDataBufferSize,STREAM_TO_CACHE,False);
      try
         with FCacheDataCursor do
            begin
            EmptyTable;
            LoadFromStream(CacheDataBuffer,CacheDataBufferSize,STREAM_TO_CACHE,False,False);
            end;
      finally
         DeAllocMem(CacheDataBuffer);
      end;
   finally
      with FCacheDataCursor do
         begin
         CachedUpdates:=True;
         { Version 5 }
         ForceRefresh;
         { Version 5 }
         end;
   end;
end;

procedure TDataCursor.ApplyCachedUpdatesToCursor(DestCursor: TDataCursor;
                                                 SendErrors: Boolean);
var
   CacheDataBuffer: PChar;
   CacheDataBufferSize: Integer;
begin
   if (not FCachedUpdates) then
      Exit;
   CacheDataBuffer:=nil;
   CacheDataBufferSize:=0;
   SaveToStream(CacheDataBuffer,CacheDataBufferSize,STREAM_FROM_CACHE,False);
   try
      with DestCursor do
         LoadFromStream(CacheDataBuffer,CacheDataBufferSize,STREAM_FROM_CACHE,False,False);
   finally
      DeAllocMem(CacheDataBuffer);
   end;
end;

procedure TDataCursor.SetCacheErrorCallback(ClientData: Integer;
                                            CacheErrorCallback: pCacheErrorCallback);
begin
   FCacheErrorClientData:=ClientData;
   FCacheErrorCallback:=pCacheErrorCallback(@CacheErrorCallback);
end;

procedure TDataCursor.CacheError(RecordNumber: Integer;
                                 RecordBuffer: PChar;
                                 OldRecordBuffer: PChar;
                                 E: Exception;
                                 OperationType: Byte;
                                 Retrying: Boolean;
                                 var Response: Byte);
begin
   Response:=ERROR_RESPONSE_FAIL;
   if Assigned(FCacheErrorCallback) then
      begin
      try
         FCacheErrorCallback(FCacheErrorClientData,RecordNumber,FRecordSize,
                             RecordBuffer,OldRecordBuffer,E,OperationType,
                             Retrying,Response);
      finally
         if (BlobFieldCount > 0) then
            FreeBlobCopies(OldRecordBuffer,False);
      end;
      end;
end;

procedure TDataCursor.FreeCachedUpdates;
begin
   if (FCacheDataCursor <> nil) then
      begin
      with FCacheDataCursor do
         begin
         CloseCursor(True);
         Free;
         end;
      FCacheDataCursor:=nil;
      end;
   if (FCacheDataDirectory <> nil) then
      begin
      FCacheDataSession.CloseDataDirectory(FCacheDataDirectory,False);
      FCacheDataDirectory:=nil;
      end;
   if (FCacheDataSession <> nil) then
      begin
      DataEngine.CloseDataSession(FCacheDataSession);
      FCacheDataSession:=nil;
      end;
end;

procedure TDataCursor.SetIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
begin
   FDataTable.SetIndexDefinition(CurIndexPos,Buffer);
   if (CurIndexPos=FIndexPos) then
      InternalUpdateKeyInformation;
end;

procedure TDataCursor.UpdateIndexDefinition(CurIndexPos: Byte; Buffer: pIndexDefinition);
begin
   FDataTable.UpdateIndexDefinition(CurIndexPos,Buffer);
   if (CurIndexPos=FIndexPos) then
      InternalUpdateKeyInformation;
end;

function TDataCursor.IndexExists(const NewName: string): Boolean;
begin
   Result:=FDataTable.IndexExists(NewName);
end;

function TDataCursor.CompareKeys(FirstKeyBuffer: PChar;
                                 SecondKeyBuffer: PChar;
                                 CompareLength: Word): Integer;
var
   I: Byte;
   BufferOffset: Word;
   TempCompareLength: Word;
begin
   Result:=CMP_EQUAL;
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      if (FLocaleID <> LOCALE_ANSI_STD) then
         begin
         BufferOffset:=0;
         I:=1;
         while (I <= FKeyFieldCount) and
               (BufferOffset < CompareLength) do
            begin
            if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
               begin
               { Now compare the existing buffers first including the
                 NULL flag for the string field, CompareString will
                 not handle a 0 for the NULL flag properly }
               TempCompareLength:=FLDCHG_DATA;
               Result:=CompareBytes((FirstKeyBuffer+BufferOffset),
                                    (SecondKeyBuffer+BufferOffset),
                                     TempCompareLength,FKeyDescendingFields[I]);
               if (Result <> CMP_EQUAL) then
                  Exit;
               TempCompareLength:=MinimumWord(GetIndexedSize(FKeyFieldDefinitions[I]),
                                             (CompareLength-(BufferOffset+FLDCHG_DATA)));
               { Now do the actual CompareString call }
               Result:=OSCompareStrings(FLocaleID,
                                       (FirstKeyBuffer+(BufferOffset+FLDCHG_DATA)),
                                       (SecondKeyBuffer+(BufferOffset+FLDCHG_DATA)),
                                        TempCompareLength,False);
               if FKeyDescendingFields[I] then
                  Result:=-Result;
               Inc(TempCompareLength,FLDCHG_DATA);
               end
            else
               begin
               TempCompareLength:=MinimumWord((FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])),
                                                (CompareLength-BufferOffset));
               Result:=CompareBytes((FirstKeyBuffer+BufferOffset),
                                    (SecondKeyBuffer+BufferOffset),
                                    TempCompareLength,FKeyDescendingFields[I]);
               end;
            if (Result <> CMP_EQUAL) then
               Exit;
            Inc(BufferOffset,TempCompareLength);
            Inc(I);
            end;
         if (BufferOffset < CompareLength) then
            begin
            TempCompareLength:=(CompareLength-BufferOffset);
            Result:=CompareBytes((FirstKeyBuffer+BufferOffset),
                                 (SecondKeyBuffer+BufferOffset),
                                 TempCompareLength,False);
            end;
         end
      else
         begin
         BufferOffset:=0;
         I:=1;
         while (I <= FKeyFieldCount) and
               (BufferOffset < CompareLength) do
            begin
            TempCompareLength:=MinimumWord((FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])),
                                             (CompareLength-BufferOffset));
            Result:=CompareBytes((FirstKeyBuffer+BufferOffset),
                                 (SecondKeyBuffer+BufferOffset),
                                 TempCompareLength,FKeyDescendingFields[I]);
            if (Result <> CMP_EQUAL) then
               Exit;
            Inc(BufferOffset,TempCompareLength);
            Inc(I);
            end;
         if (BufferOffset < CompareLength) then
            begin
            TempCompareLength:=(CompareLength-BufferOffset);
            Result:=CompareBytes((FirstKeyBuffer+BufferOffset),
                                 (SecondKeyBuffer+BufferOffset),
                                 TempCompareLength,False);
            end;
         end;
      end
   else
      begin
      Result:=CompareBytes(FirstKeyBuffer,SecondKeyBuffer,
                           (FLDCHG_DATA+TEXT_FLDNUM_SIZE),False);
      if (Result <> CMP_EQUAL) then
         Exit;
      Result:=OSCompareStrings(FLocaleID,
                              (FirstKeyBuffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE)),
                              (SecondKeyBuffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE)),
                               TEXT_WORD_SIZE,False);
      if (Result <> CMP_EQUAL) then
         Exit;
      Result:=CompareBytes((FirstKeyBuffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE)),
                           (SecondKeyBuffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE)),
                            RECORDID_SIZE,False);
      end;
end;

function TDataCursor.CompareNumbers(FirstNumber: Integer;
                                    SecondNumber: Integer): Integer;
begin
   Result:=CMP_EQUAL;
   if (FirstNumber < SecondNumber) then
      Result:=CMP_LESS
   else if (FirstNumber > SecondNumber) then
      Result:=CMP_GREATER;
end;

procedure TDataCursor.CheckCallbacks(NewClientData: Integer);
var
   I: Integer;
begin
   if Assigned(FSteppedProgressCallback) then
      FSteppedProgressClientData:=NewClientData;
   if Assigned(FLogCallback) then
      FLogClientData:=NewClientData;
   if Assigned(FProgressCallback) then
      FProgressClientData:=NewClientData;
   if Assigned(FDataLostCallback) then
      FDataLostClientData:=NewClientData;
   for I:=0 to FFilters.Count-1 do
      begin
      with TFilter(FFilters[I]) do
         begin
         if IsCallbackFilter then
            ClientData:=NewClientData;
         end;
      end;
end;

procedure TDataCursor.DoSteppedProgress(const Step: string;
                                        PercentDone: Word);
begin
   if Assigned(FSteppedProgressCallback) then
      FSteppedProgressCallback(FSteppedProgressClientData,
                               Step,PercentDone);
end;

procedure TDataCursor.DoLog(const LogMessage: string);
begin
   if Assigned(FLogCallback) then
      FLogCallback(FLogClientData,LogMessage);
end;

procedure TDataCursor.DoProgress(PercentDone: Word);
begin
   if Assigned(FProgressCallback) then
      FProgressCallback(FProgressClientData,PercentDone);
end;

procedure TDataCursor.DoDataLost(Cause: Byte; const ContextInfo: string;
                                 var Continue: Boolean;
                                 var StopAsking: Boolean);
begin
   if Assigned(FDataLostCallback) then
      FDataLostCallback(FDataLostClientData,
                        Cause,ContextInfo,Continue,StopAsking);
end;

procedure TDataCursor.RefreshCurrentRecord(Direction: Byte);
var
   TempRecord: TRecord;
begin
   if (PhysicalRecordNumber <> 0) then
      begin
      { If the record is not retrieved the first time it's because of
        the change detection causing the record to not be retrieved, so
        we must retrieve it again after the table is read-locked }
      if (not GetRecord(PhysicalRecordNumber,True,Direction,
                        TempRecord)) then
         GetRecord(PhysicalRecordNumber,True,Direction,TempRecord);
      try
         with FCurrentRecord do
            begin
            Size:=FRecordSize;
            Copy(TempRecord);
            end;
      finally
         PutRecord(TempRecord);
      end;
      end
   else
      begin
      with FCurrentRecord do
         begin
         Size:=FRecordSize;
         Initialize;
         end;
      end;
   CalculateExpressionFields(FCurrentRecord.Buffer);
end;

procedure TDataCursor.SetCurrentRecord(RecNumber: Integer);
var
   TempRecord: TRecord;
begin
   if (RecNumber > 0) and (RecNumber <= PhysicalRecordsUsed) then
      begin
      try
         FCurRecordNumber:=RecNumber;
         { If the record is not retrieved the first time it's because of
           the change detection causing the record to not be retrieved, so
           we must retrieve it again after the table is read-locked }
         if (not GetRecord(FCurRecordNumber,True,READ_FORWARD,
                           TempRecord)) then
            GetRecord(FCurRecordNumber,True,READ_FORWARD,TempRecord);
         try
            with FCurrentRecord do
               begin
               Size:=FRecordSize;
               Copy(TempRecord);
               end;
            FBOF:=False;
            FEOF:=False;
         finally
            PutRecord(TempRecord);
         end;
      finally
         ReadUnlockTable;
      end;
      end
   else
      begin
      with FCurrentRecord do
         begin
         Size:=FRecordSize;
         Initialize;
         end;
      end;
   CalculateExpressionFields(FCurrentRecord.Buffer);
end;

{ Version 5 }
function TDataCursor.CompareCurrentRecordToKey(KeyBuffer: PChar;
                                               CompareLength: Word): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   GetKeyValues(FCurrentRecord.Buffer,@TempKeyBuffer);
   Result:=(CompareKeys(KeyBuffer,@TempKeyBuffer,CompareLength)=CMP_EQUAL);
end;
{ Version 5 }

function TDataCursor.Find(KeyProvided: Boolean; Buffer: PChar;
                          SearchFieldCount: Integer;
                          IsSoftSeek: Boolean; PartialLength: Word;
                          NewRecordBuffer: PChar): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   LastByte: Word;
   I: Word;
   TempSendBuffer: Boolean;
begin
   Result:=False;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         if (Buffer <> nil) then
            begin
            if KeyProvided then
               Move(Buffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(Buffer,@TempKeyBuffer);
            SetRequestCode(REQUEST_FIND);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(TempKeyBuffer,FKeySize);
            Pack(SearchFieldCount,SizeOf(Integer));
            Pack(IsSoftSeek,SizeOf(Boolean));
            Pack(PartialLength,SizeOf(Word));
            TempSendBuffer:=(NewRecordBuffer <> nil);
            Pack(TempSendBuffer,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(Result);
            UnpackCursorInfo;
            if TempSendBuffer then
               Unpack(NewRecordBuffer^);
            end
         else
            Result:=False;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if (Buffer <> nil) then
            begin
            if KeyProvided then
               Move(Buffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(Buffer,@TempKeyBuffer);
            LastByte:=0;
            if ((SearchFieldCount > 0) and
               (SearchFieldCount < FKeyFieldCount)) or
               (not FKeyUnique) or ((SearchFieldCount=0) and (PartialLength > 0)) then
               begin
               if (not FKeyUnique) and (SearchFieldCount=0) and (PartialLength=0) then
                  SearchFieldCount:=FKeyFieldCount;
               if (PartialLength=0) then
                  LastByte:=PartialLength
               else
                  LastByte:=PartialLength+1;
               for I:=1 to SearchFieldCount do
                  Inc(LastByte,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
               SetLowBytes(@TempKeyBuffer,LastByte);
               FindIndexKey(@TempKeyBuffer,True,False);
               Result:=(RecordCount <> 0) and
                       (CompareKeys(GetKey,@TempKeyBuffer,
                                    LastByte)=CMP_EQUAL);
               end
            else
               Result:=FindIndexKey(@TempKeyBuffer,IsSoftSeek,False);
            { Version 5 }
            RefreshCurrentRecord(READ_FORWARD);
            VerifyCurrentRecord(READ_FORWARD);
            if FEOF then
               begin
               GotoLastIndexPosition;
               RefreshCurrentRecord(READ_BACKWARD);
               VerifyCurrentRecord(READ_BACKWARD);
               end;
            if Result and (not IsSoftSeek) then
               begin
               if (LastByte <> 0) then
                  Result:=CompareCurrentRecordToKey(@TempKeyBuffer,LastByte)
               else
                  Result:=CompareCurrentRecordToKey(@TempKeyBuffer,FKeySize);
               end;
            { Version 5 }
            if (NewRecordBuffer <> nil) then
               FCurrentRecord.CopyToBuffer(NewRecordBuffer);
            end
         else
            Result:=False;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ExactFind(Buffer: PChar; NewRecordBuffer: PChar): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   GetKeyValues(Buffer,@TempKeyBuffer);
   Result:=FindExactIndexKey(@TempKeyBuffer);
   if Result then
      begin
      RefreshCurrentRecord(READ_CURRENT);
      FCurrentRecord.CopyToBuffer(NewRecordBuffer);
      end;
end;

function TDataCursor.CompareFind(Buffer: PChar; SearchFieldCount: Integer): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   LastByte: Word;
   I: Word;
   CompareResult: Integer;
begin
   Result:=False;
   if (Buffer <> nil) then
      begin
      GetKeyValues(Buffer,@TempKeyBuffer);
      if ((SearchFieldCount > 0) and
         (SearchFieldCount < FKeyFieldCount)) then
         begin
         if (not FKeyUnique) and (SearchFieldCount=0) then
            SearchFieldCount:=FKeyFieldCount;
         LastByte:=0;
         for I:=1 to SearchFieldCount do
            Inc(LastByte,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
         SetLowBytes(@TempKeyBuffer,LastByte);
         FindIndexKey(@TempKeyBuffer,True,False);
         if (RecordCount <> 0) then
            begin
            CompareResult:=CompareKeys(GetKey,@TempKeyBuffer,LastByte);
            if (CompareResult=CMP_LESS) or (CompareResult=CMP_EQUAL) then
               Result:=True;
            end;
         end
      else
         Result:=FindIndexKey(@TempKeyBuffer,True,False);
      if FEOF then
         GotoLastIndexPosition;
      RefreshCurrentRecord(READ_CURRENT);
      end
   else
      Result:=False;
end;

function TDataCursor.Locate(NumberOfFields: Word; Fields: TKeyFields;
                            RecordBuffer: PChar; IsCaseInsensitive: Boolean;
                            LastPartialLength: Word; NewRecordBuffer: PChar): Boolean;
var
   TempSendBuffer: Boolean;
   TempIndexPos: Byte;
begin
   Result:=False;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         if (RecordBuffer <> nil) then
            begin
            SetRequestCode(REQUEST_LOCATE);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(NumberOfFields,SizeOf(Word));
            Pack(Fields,SizeOf(TKeyFields));
            Pack(RecordBuffer^,FRecordSize);
            Pack(IsCaseInsensitive,SizeOf(Boolean));
            Pack(LastPartialLength,SizeOf(Word));
            TempSendBuffer:=(NewRecordBuffer <> nil);
            Pack(TempSendBuffer,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(Result);
            UnpackCursorInfo;
            if TempSendBuffer then
               Unpack(NewRecordBuffer^);
            end
         else
            Result:=False;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if (RecordBuffer <> nil) then
            begin
            if IndexAvailableForFields(NumberOfFields,Fields,IsCaseInsensitive,False,
                                       TempIndexPos) and
               ((not FRangeInEffect) or (FRangeInEffect and (TempIndexPos=FIndexPos))) then
               begin
               if (LastPartialLength > 0) then
                  Result:=IndexLocate(TempIndexPos,RecordBuffer,
                                      (NumberOfFields-1),True,
                                      LastPartialLength,NewRecordBuffer)
               else
                  Result:=IndexLocate(TempIndexPos,RecordBuffer,
                                      NumberOfFields,False,
                                      0,NewRecordBuffer);
               end
            else
               Result:=FilterLocate(NumberOfFields,Fields,
                                    RecordBuffer,IsCaseInsensitive,
                                    LastPartialLength,NewRecordBuffer);
            end
         else
            Result:=False;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.IndexLocate(NewIndexPos: Byte; Buffer: PChar;
                                 SearchFieldCount: Integer;
                                 IsSoftSeek: Boolean; PartialLength: Word;
                                 NewRecordBuffer: PChar): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   LastByte: Word;
   I: Word;
   SaveIndexPos: Byte;
begin
   Result:=False;
   if (Buffer <> nil) then
      begin
      LastByte:=0;
      SaveIndexPos:=FIndexPos;
      InternalSetIndexPos(NewIndexPos);
      try
         GetKeyValues(Buffer,@TempKeyBuffer);
         if ((SearchFieldCount > 0) and
            (SearchFieldCount < FKeyFieldCount)) or
            (not FKeyUnique) or ((SearchFieldCount=0) and (PartialLength > 0)) then
            begin
            if (not FKeyUnique) and (SearchFieldCount=0) and (PartialLength=0) then
               SearchFieldCount:=FKeyFieldCount;
            if (PartialLength=0) then
               LastByte:=PartialLength
            else
               LastByte:=PartialLength+1;
            for I:=1 to SearchFieldCount do
               Inc(LastByte,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
            SetLowBytes(@TempKeyBuffer,LastByte);
            FindIndexKey(@TempKeyBuffer,True,False);
            Result:=(RecordCount <> 0) and
                    (CompareKeys(GetKey,@TempKeyBuffer,
                                 LastByte)=CMP_EQUAL);
            end
         else
            Result:=FindIndexKey(@TempKeyBuffer,IsSoftSeek,False);
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
         if FEOF then
            begin
            GotoLastIndexPosition;
            RefreshCurrentRecord(READ_BACKWARD);
            VerifyCurrentRecord(READ_BACKWARD);
            end;
      finally
         InternalSetIndexPos(SaveIndexPos);
         { Version 5 }
         if Result then
            begin
            if (NewIndexPos <> SaveIndexPos) then
               begin
               GetKeyValues(FCurrentRecord.Buffer,@TempKeyBuffer);
               FindIndexKey(@TempKeyBuffer,True,False);
               Result:=CompareCurrentRecordToKey(@TempKeyBuffer,FKeySize);
               if Result then
                  FCurrentRecord.CopyToBuffer(NewRecordBuffer);
               end
            else
               begin
               if (LastByte <> 0) then
                  Result:=CompareCurrentRecordToKey(@TempKeyBuffer,LastByte)
               else
                  Result:=CompareCurrentRecordToKey(@TempKeyBuffer,FKeySize);
               if Result then
                  FCurrentRecord.CopyToBuffer(NewRecordBuffer)
               end;
            end;
         { Version 5 }
      end;
      end;
end;

function TDataCursor.FilterLocate(NumberOfFields: Word; Fields: TKeyFields;
                                  RecordBuffer: PChar; IsCaseInsensitive: Boolean;
                                  LastPartialLength: Word; NewRecordBuffer: PChar): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   I: Integer;
   NewToken: TExpToken;
   TempToken: TExpToken;
   TempFilterHandle: Pointer;
   TempFieldDefinition: pFieldDefinition;
begin
   Result:=False;
   GetBookmark(@TempKeyBuffer);
   try
      TempToken:=nil;
      NewToken:=nil;
      for I:=0 to NumberOfFields-1 do
         begin
         if (I=0) then
            NewToken:=TExpToken.Create
         else
            begin
            TempToken:=TExpToken.Create;
            with TempToken do
               begin
               TokenLiteral:=PARSE_AND;
               TokenType:=etBINARY;
               TokenOperator:=eoAND;
               DataType:=TYPE_BOOL;
               DataSize:=SizeOf(WordBool);
               LeftExpToken:=NewToken;
               NewToken:=TExpToken.Create;
               RightExpToken:=NewToken;
               end;
            end;
         TempFieldDefinition:=GetPhysicalFieldDefinition(Fields[I+1]);
         with NewToken do
            begin
            TokenType:=etCOMPARE;
            TokenOperator:=eoEQ;
            DataType:=TYPE_BOOL;
            DataSize:=SizeOf(WordBool);
            CaseInsensitive:=IsCaseInsensitive;
            LeftExpToken:=TExpToken.Create;
            with LeftExpToken do
               begin
               TokenType:=etFIELD;
               FieldName:=TempFieldDefinition^.FieldName;
               FieldNumber:=TempFieldDefinition^.FieldNum;
               DataType:=TempFieldDefinition^.DataType;
               SubType:=TempFieldDefinition^.SubType;
               DataSize:=TempFieldDefinition^.DataSize;
               DataDecimals:=TempFieldDefinition^.DataDecimals;
               end;
            RightExpToken:=TExpToken.Create;
            with RightExpToken do
               begin
               if (not Boolean((RecordBuffer+TempFieldDefinition^.Offset)^)) then
                  begin
                  TokenType:=etCONST;
                  DataType:=TempFieldDefinition^.DataType;
                  SubType:=TempFieldDefinition^.SubType;
                  IsNull:=True;
                  end
               else
                  begin
                  TokenType:=etCONST;
                  DataType:=TempFieldDefinition^.DataType;
                  SubType:=TempFieldDefinition^.SubType;
                  case DataType of
                     TYPE_ZSTRING:
                        begin
                        DataSize:=TempFieldDefinition^.DataSize;
                        DataDecimals:=TempFieldDefinition^.DataDecimals;
                        if (I=(NumberOfFields-1)) then
                           NewToken.PartialLength:=LastPartialLength;
                        Move((RecordBuffer+FLDCHG_DATA+TempFieldDefinition^.Offset)^,
                             Value^,DataSize);
                        end;
                     else
                        begin
                        DataSize:=TempFieldDefinition^.DataSize;
                        DataDecimals:=TempFieldDefinition^.DataDecimals;
                        Move((RecordBuffer+FLDCHG_DATA+TempFieldDefinition^.Offset)^,
                             Value^,DataSize);
                        end;
                     end;
                  end;
               end;
            end;
         if (I > 0) then
            NewToken:=TempToken;
         end;
      AddFilter(0,nil,NewToken,True,nil,True,True,IsCaseInsensitive,False,TempFilterHandle);
      try
         ActivateFilter(TempFilterHandle);
         if (RecordCount <> 0) then
            begin
            GotoFirstIndexPosition;
            FBOF:=False;
            FEOF:=False;
            RefreshCurrentRecord(READ_FORWARD);
            VerifyCurrentRecord(READ_FORWARD);
            if (RecordCount <> 0) then
               begin
               Result:=True;
               FCurrentRecord.CopyToBuffer(NewRecordBuffer)
               end;
            end
         else
            Result:=False;
      finally
         DropFilter(TempFilterHandle,False);
      end;
   finally
      if (not Result) then
         SetToBookmark(@TempKeyBuffer,True,True);
   end;
end;

function TDataCursor.IndexAvailableForFields(NumberOfFields: Word;
                                             Fields: TKeyFields;
                                             IsCaseInsensitive: Boolean;
                                             MatchDescending: Boolean;
                                             var AvailableIndexPos: Byte): Boolean;
var
   I: Integer;
   TempIndexDefinition: TIndexDefinition;
begin
   Result:=False;
   FillChar(TempIndexDefinition,SizeOf(TIndexDefinition),#0);
   with TempIndexDefinition do
      begin
      KeyUnique:=False;
      KeyDescending:=False;
      FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
      KeyCaseInsensitive:=IsCaseInsensitive;
      KeyFieldCount:=NumberOfFields;
      KeyFields:=Fields;
      end;
   for I:=0 to IndexCount do
      begin
      if CompareIndexDefinitions(@TempIndexDefinition,GetIndexDefinition(I),True,MatchDescending) then
         begin
         Result:=True;
         AvailableIndexPos:=I;
         Break;
         end;
      end;
end;

function TDataCursor.CompareIndexDefinitions(FirstIndexDefinition: pIndexDefinition;
                                             SecondIndexDefinition: pIndexDefinition;
                                             PartialFieldsMatch: Boolean;
                                             DescendingFieldsMatch: Boolean): Boolean;
var
   I: Byte;
   CheckCaseInsensitive: Boolean;
begin
   Result:=True;
   CheckCaseInsensitive:=False;
   I:=1;
   while (FirstIndexDefinition^.KeyFields[I] <> 0) and
         (I <= MAX_NUM_FLDSINKEY) do
      begin
      if (GetPhysicalFieldDefinition(FirstIndexDefinition^.KeyFields[I]) <> nil) and
         (GetPhysicalFieldDefinition(FirstIndexDefinition^.KeyFields[I])^.DataType=TYPE_ZSTRING) then
         begin
         CheckCaseInsensitive:=True;
         Break;
         end;
      Inc(I);
      end;
   if ((not PartialFieldsMatch) and
       (FirstIndexDefinition^.KeyFieldCount <> SecondIndexDefinition^.KeyFieldCount)) or
      (DescendingFieldsMatch and
       (FirstIndexDefinition^.KeyDescending <> SecondIndexDefinition^.KeyDescending)) or
      (CheckCaseInsensitive and
       (FirstIndexDefinition^.KeyCaseInsensitive <> SecondIndexDefinition^.KeyCaseInsensitive)) then
      Result:=False
   else
      begin
      I:=1;
      while (FirstIndexDefinition^.KeyFields[I] <> 0) and
            (I <= MAX_NUM_FLDSINKEY) do
         begin
         if (SecondIndexDefinition^.KeyFields[I] <> FirstIndexDefinition^.KeyFields[I]) or
            (DescendingFieldsMatch and
             (SecondIndexDefinition^.KeyDescendingFields[I] <> FirstIndexDefinition^.KeyDescendingFields[I])) then
            begin
            Result:=False;
            Exit;
            end;
         Inc(I);
         end;
      end;
end;

procedure TDataCursor.SetRange(KeysProvided: Boolean;
                               BeginBuffer: PChar; BeginFieldCount: Integer;
                               EndBuffer: PChar; EndFieldCount: Integer);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   LastByte: Word;
   I: Word;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         if (BeginBuffer <> nil) then
            begin
            if KeysProvided then
               Move(BeginBuffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(BeginBuffer,@TempKeyBuffer);
            end
         else
            FillChar(TempKeyBuffer,MAX_KEYLEN,#0);
         SetRequestCode(REQUEST_SETRANGE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(TempKeyBuffer,FKeySize);
         Pack(BeginFieldCount,SizeOf(Integer));
         if (EndBuffer <> nil) then
            begin
            if KeysProvided then
               Move(EndBuffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(EndBuffer,@TempKeyBuffer);
            end
         else
            FillChar(TempKeyBuffer,MAX_KEYLEN,#0);
         Pack(TempKeyBuffer,FKeySize);
         Pack(EndFieldCount,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
         FRangeInEffect:=True;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if (BeginBuffer <> nil) then
            begin
            if KeysProvided then
               Move(BeginBuffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(BeginBuffer,@TempKeyBuffer);
            if ((BeginFieldCount > 0) and
               (BeginFieldCount < FKeyFieldCount)) or (not FKeyUnique) then
               begin
               if (not FKeyUnique) and (BeginFieldCount=0) then
                  BeginFieldCount:=FKeyFieldCount;
               LastByte:=0;
               for I:=1 to BeginFieldCount do
                  Inc(LastByte,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
               SetLowBytes(@TempKeyBuffer,LastByte);
               end;
            end
         else
            FillChar(TempKeyBuffer,MAX_KEYLEN,#0);
         SetBeginIndexRange(@TempKeyBuffer);
         if (EndBuffer <> nil) then
            begin
            if KeysProvided then
               Move(EndBuffer^,TempKeyBuffer,FKeySize)
            else
               GetKeyValues(EndBuffer,@TempKeyBuffer);
            if ((EndFieldCount > 0) and
               (EndFieldCount < FKeyFieldCount)) or (not FKeyUnique) then
               begin
               if (not FKeyUnique) and (EndFieldCount=0) then
                  EndFieldCount:=FKeyFieldCount;
               LastByte:=0;
               for I:=1 to EndFieldCount do
                  Inc(LastByte,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
               SetHighBytes(@TempKeyBuffer,LastByte);
               end;
            end
         else
            FillChar(TempKeyBuffer,MAX_KEYLEN,#0);
         SetEndIndexRange(@TempKeyBuffer);
         ActivateRange;
         RefreshRangeAndFilters;
         RepositionCurrentRecord;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.ResetRange;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_RESETRANGE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         CancelRange;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         CancelRange;
         RefreshRangeAndFilters;
         RepositionCurrentRecord;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.FindIndexKey(Buffer: PChar; IsSoftSeek: Boolean;
                                  RestoreFlags: Boolean): Boolean;
var
   ParentPage: TPage;
   ChildPage: TPage;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
   WasBOF: Boolean;
   WasEOF: Boolean;
   RetryPages: Boolean;
   PageFound: Boolean;
   TempFilterKeyPos: Integer;
begin
   Result:=False;
   RetryPages:=True;
   while RetryPages do
      begin
      RetryPages:=False;
      if (RecordCount <> 0) then
         begin
         WasBOF:=FBOF;
         WasEOF:=FEOF;
         TempSequenceNumber:=FSequenceNumber;
         if FFiltersInEffect and (FFilterKeys.Count > 0) and
            (FFilterKeyIndexPos=FIndexPos) then
            begin
            TempFilterKeyPos:=FFilterKeyPos;
            Result:=SearchFilterKeys(Buffer,TempFilterKeyPos);
            if (not Result) then
               begin
               if IsSoftSeek then
                  begin
                  if (TempFilterKeyPos < FFilterKeys.Count) then
                     begin
                     FFilterKeyPos:=TempFilterKeyPos;
                     PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[FFilterKeyPos])^.KeyBuffer,RetryPages);
                     if (not RetryPages) then
                        begin
                        if PageFound then
                           begin
                           FBOF:=False;
                           FEOF:=False;
                           end
                        else
                           begin
                           ResetIndexPosition;
                           Exit;
                           end;
                        end;
                     end
                  else
                     begin
                     FFilterKeyPos:=(FFilterKeys.Count-1);
                     PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[FFilterKeyPos])^.KeyBuffer,RetryPages);
                     if (not RetryPages) then
                        begin
                        if PageFound then
                           begin
                           FBOF:=False;
                           FEOF:=True;
                           end
                        else
                           begin
                           ResetIndexPosition;
                           Exit;
                           end;
                        end;
                     end;
                  end;
               end
            else
               begin
               FFilterKeyPos:=TempFilterKeyPos;
               PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[FFilterKeyPos])^.KeyBuffer,RetryPages);
               if (not RetryPages) then
                  begin
                  if PageFound then
                     begin
                     FBOF:=False;
                     FEOF:=False;
                     end
                  else
                     begin
                     ResetIndexPosition;
                     Exit;
                     end;
                  end;               
               end;
            end
         else if FRangeInEffect then
            begin
            if (CompareKeys(Buffer,@FBeginBuffer,FKeySize)=CMP_LESS) then
               GotoFirstIndexPosition
            else if (CompareKeys(Buffer,@FEndBuffer,FKeySize)=CMP_GREATER) then
               GotoLastIndexPosition
            else
               begin
               PageFound:=GetRootPage(ParentPage,RetryPages);
               if (not RetryPages) then
                  begin
                  if PageFound then
                     begin
                     try
                        TempBOF:=False;
                        TempEOF:=False;
                        TempSequenceNumber:=1;
                        TempKeyCounter:=1;
                        while True do
                           begin
                           Result:=FindRangeScan(ParentPage,Buffer,@FEndBuffer,
                                                 TempSequenceNumber,TempKeyCounter,
                                                  IsSoftSeek);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           if FFiltersInEffect then
                              begin
                              Result:=(Result and FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter)));
                              if (not Result) then
                                 begin
                                 if IsSoftSeek then
                                    begin
                                    if (CompareKeys(ParentPage.GetKey(TempKeyCounter),Buffer,
                                                     FKeySize)=CMP_LESS) or
                                       (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                       begin
                                       if (not FilterRangeScanForward(ParentPage,TempSequenceNumber,
                                                                      TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             if PageFound or
                                                (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                                begin
                                                if (not FilterRangeScanBackward(ParentPage,TempSequenceNumber,
                                                                                TempKeyCounter,RetryPages,PageFound)) then
                                                   begin
                                                   if (not RetryPages) then
                                                      begin
                                                      ResetIndexPosition;
                                                      Exit;
                                                      end;
                                                   end;
                                                end;
                                             TempEOF:=True;
                                             end;
                                          end;
                                       end;
                                    if (not RetryPages) then
                                       begin
                                       FCurrentPage.Copy(ParentPage);
                                       FCurKeyCounter:=TempKeyCounter;
                                       FSequenceNumber:=TempSequenceNumber;
                                       FBOF:=TempBOF;
                                       FEOF:=TempEOF;
                                       end;
                                    end;
                                 end
                              else
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end
                           else
                              begin
                              if (not Result) then
                                 begin
                                 if IsSoftSeek then
                                    begin
                                    if (CompareKeys(ParentPage.GetKey(TempKeyCounter),Buffer,
                                                     FKeySize)=CMP_LESS) then
                                       begin
                                       if (not RangeScanForward(ParentPage,TempSequenceNumber,
                                                                TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             if PageFound then
                                                begin
                                                if (not RangeScanBackward(ParentPage,TempSequenceNumber,
                                                                          TempKeyCounter,RetryPages,PageFound)) then
                                                   begin
                                                   if (not RetryPages) then
                                                      begin
                                                      ResetIndexPosition;
                                                      Exit;
                                                      end;
                                                   end;
                                                end;
                                             TempEOF:=True;
                                             end;
                                          end;
                                       end;
                                    if (not RetryPages) then
                                       begin
                                       FCurrentPage.Copy(ParentPage);
                                       FCurKeyCounter:=TempKeyCounter;
                                       FSequenceNumber:=TempSequenceNumber;
                                       FBOF:=TempBOF;
                                       FEOF:=TempEOF;
                                       end;
                                    end;
                                 end
                              else
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end;
                           end;
                     finally
                        PutPage(ParentPage);
                     end;
                     end
                  else
                     begin
                     ResetIndexPosition;
                     Exit;
                     end;
                  end;
               end;
            end
         else if FFiltersInEffect then
            begin
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempBOF:=False;
                     TempEOF:=False;
                     TempSequenceNumber:=1;
                     TempKeyCounter:=1;
                     while True do
                        begin
                        Result:=FindScan(ParentPage,Buffer,TempSequenceNumber,
                                         TempKeyCounter,IsSoftSeek);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                     ChildPage));
                           if RetryPages then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryPages) then
                        begin
                        Result:=(Result and FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter)));
                        if (not Result) then
                           begin
                           if IsSoftSeek then
                              begin
                              if (CompareKeys(ParentPage.GetKey(TempKeyCounter),Buffer,
                                              FKeySize)=CMP_LESS) or
                                 (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                 begin
                                 if (not FilterScanForward(ParentPage,TempSequenceNumber,
                                                           TempKeyCounter,RetryPages,PageFound)) then
                                    begin
                                    if (not RetryPages) then
                                       begin
                                       if PageFound or
                                          (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                          begin
                                          if (not FilterScanBackward(ParentPage,TempSequenceNumber,
                                                                     TempKeyCounter,RetryPages,PageFound)) then
                                             begin
                                             if (not RetryPages) then
                                                begin
                                                ResetIndexPosition;
                                                Exit;
                                                end;
                                             end;
                                          end;
                                       TempEOF:=True;
                                       end;
                                    end;
                                 end;
                              if (not RetryPages) then
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end;
                           end
                        else
                           begin
                           FCurrentPage.Copy(ParentPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  begin
                  ResetIndexPosition;
                  Exit;
                  end;
               end;
            end
         else
            begin
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempBOF:=False;
                     TempEOF:=False;
                     TempSequenceNumber:=1;
                     TempKeyCounter:=1;
                     while True do
                        begin
                        Result:=FindScan(ParentPage,Buffer,TempSequenceNumber,
                                         TempKeyCounter,IsSoftSeek);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                    ChildPage));
                           if RetryPages then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryPages) then
                        begin
                        if (not Result) then
                           begin
                           if IsSoftSeek then
                              begin
                              if (CompareKeys(ParentPage.GetKey(TempKeyCounter),Buffer,
                                              FKeySize)=CMP_LESS) then
                                 begin
                                 if (not ScanForward(ParentPage,TempSequenceNumber,
                                                     TempKeyCounter,RetryPages,PageFound)) then
                                    begin
                                    if (not RetryPages) then
                                       begin
                                       if PageFound then
                                          begin
                                          if (not ScanBackward(ParentPage,TempSequenceNumber,
                                                               TempKeyCounter,RetryPages,PageFound)) then
                                             begin
                                             if (not RetryPages) then
                                                begin
                                                ResetIndexPosition;
                                                Exit;
                                                end;
                                             end;
                                          end;
                                       TempEOF:=True;
                                       end;
                                    end;
                                 end;
                              if (not RetryPages) then
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end;
                           end
                        else
                           begin
                           FCurrentPage.Copy(ParentPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  begin
                  ResetIndexPosition;
                  Exit;
                  end;
               end;
            end;
         { Version 5 }
         if (not RetryPages) then
         { Version 5 }
            begin
            if RestoreFlags then
               begin
               if WasBOF then
                  begin
                  SkipIndexKeys(-1);
                  if not FBOF then
                     SkipIndexKeys(1);
                  end
               else
                  FBOF:=False;
               if WasEOF then
                  begin
                  SkipIndexKeys(1);
                  if not FEOF then
                     SkipIndexKeys(-1);
                  end
               else
                  FEOF:=False;
               end;
            end;
         end
      else
         { Version 5 }
         begin
         ResetIndexPosition;
         Exit;
         end;
         { Version 5 }
      end;
end;

function TDataCursor.FindExactIndexKey(Buffer: PChar): Boolean;
var
   ParentPage: TPage;
   ChildPage: TPage;
   TempKeyCounter: Integer;
   RetryPages: Boolean;
begin
   Result:=False;
   if GetRootPage(ParentPage,RetryPages) then
      begin
      try
         TempKeyCounter:=1;
         while True do
            begin
            if FKeyUnique then
               Result:=SearchScan(ParentPage,Buffer,TempKeyCounter,FKeySize)
            else
               Result:=SearchScan(ParentPage,Buffer,TempKeyCounter,(FKeySize-RECORDID_SIZE));
            if (ParentPage.PageType > INTERNAL_NODE) then
               Break
            else
               begin
               GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
               PutPage(ParentPage);
               ParentPage:=ChildPage;
               end;
            end;
         if Result then
            begin
            FCurrentPage.Copy(ParentPage);
            FCurKeyCounter:=TempKeyCounter;
            FBOF:=False;
            FEOF:=False;
            end;
      finally
         PutPage(ParentPage);
      end;
      end
   else
      ResetIndexPosition;
end;

function TDataCursor.FindFilterKey(Buffer: PChar; var RetryPages: Boolean): Boolean;
var
   ParentPage: TPage;
   ChildPage: TPage;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
   PageFound: Boolean;
begin
   Result:=False;
   if (RecordCount <> 0) then
      begin
      TempSequenceNumber:=FSequenceNumber;
      PageFound:=GetRootPage(ParentPage,RetryPages);
      if RetryPages then
         Exit
      else if PageFound then
         begin
         try
            TempBOF:=False;
            TempEOF:=False;
            TempSequenceNumber:=1;
            TempKeyCounter:=1;
            while True do
               begin
               Result:=FindScan(ParentPage,Buffer,TempSequenceNumber,
                                TempKeyCounter,False);
               if (ParentPage.PageType > INTERNAL_NODE) then
                  Break
               else
                  begin
                  RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                           ChildPage));
                  if RetryPages then
                     begin
                     ParentPage:=nil;
                     Break;
                     end
                  else
                     begin
                     PutPage(ParentPage);
                     ParentPage:=ChildPage;
                     end;
                  end;
               end;
            if (not RetryPages) then
               begin
               if Result then
                  begin
                  FCurrentPage.Copy(ParentPage);
                  FCurKeyCounter:=TempKeyCounter;
                  FSequenceNumber:=TempSequenceNumber;
                  FBOF:=TempBOF;
                  FEOF:=TempEOF;
                  end;
               end;
         finally
            PutPage(ParentPage);
         end;
         end
      else
         { Version 5 }
         ResetIndexPosition;
         { Version 5 }
      end
   else
      ResetIndexPosition;
end;

function TDataCursor.ScanForward(var CurPage: TPage;
                                 var SeqNumber: Integer;
                                 var KeyCounter: Integer;
                                 var RetryPages: Boolean;
                                 var PageFound: Boolean): Boolean;
begin
   Result:=False;
   if (KeyCounter=CurPage.NumberOfKeys) then
      begin
      PageFound:=GotoRightPage(CurPage,RetryPages,KeyCounter);
      if PageFound and (not RetryPages) then
         begin
         Inc(SeqNumber);
         Result:=True;
         end;
      end
   else
      begin
      PageFound:=True;
      Inc(SeqNumber);
      Inc(KeyCounter);
      Result:=True;
      end;
end;

function TDataCursor.ScanBackward(var CurPage: TPage;
                                  var SeqNumber: Integer;
                                  var KeyCounter: Integer;
                                  var RetryPages: Boolean;
                                  var PageFound: Boolean): Boolean;
begin
   Result:=False;
   if (KeyCounter=1) then
      begin
      PageFound:=GotoLeftPage(CurPage,RetryPages,KeyCounter);
      if PageFound and (not RetryPages) then
         begin
         Dec(SeqNumber);
         Result:=True;
         end;
      end
   else
      begin
      PageFound:=True;
      Dec(SeqNumber);
      Dec(KeyCounter);
      Result:=True;
      end;
end;

function TDataCursor.RangeScanForward(var CurPage: TPage;
                                      var SeqNumber: Integer;
                                      var KeyCounter: Integer;
                                      var RetryPages: Boolean;
                                      var PageFound: Boolean): Boolean;
begin
   Result:=False;
   if (KeyCounter=CurPage.NumberOfKeys) then
      begin
      PageFound:=GotoRightPage(CurPage,RetryPages,KeyCounter);
      if PageFound and (not RetryPages) then
         begin
         Inc(SeqNumber);
         if (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_LESS) or
            (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_EQUAL) then
            Result:=True;
         end;
      end
   else
      begin
      PageFound:=True;
      Inc(SeqNumber);
      Inc(KeyCounter);
      if (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_LESS) or
         (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_EQUAL) then
         Result:=True;
      end;
end;

function TDataCursor.RangeScanBackward(var CurPage: TPage;
                                       var SeqNumber: Integer;
                                       var KeyCounter: Integer;
                                       var RetryPages: Boolean;
                                       var PageFound: Boolean): Boolean;
begin
   Result:=False;
   if (KeyCounter=1) then
      begin
      PageFound:=GotoLeftPage(CurPage,RetryPages,KeyCounter);
      if PageFound and (not RetryPages) then
         begin
         Dec(SeqNumber);
         if (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_GREATER) or
            (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_EQUAL) then
            Result:=True;
         end;
      end
   else
      begin
      PageFound:=True;
      Dec(SeqNumber);
      Dec(KeyCounter);
      if (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_GREATER) or
         (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_EQUAL) then
         Result:=True;
      end;
end;

function TDataCursor.FilterRangeScanForward(var CurPage: TPage;
                                            var SeqNumber: Integer;
                                            var KeyCounter: Integer;
                                            var RetryPages: Boolean;
                                            var PageFound: Boolean): Boolean;
begin
   Result:=False;
   while True do
      begin
      if (KeyCounter=CurPage.NumberOfKeys) then
         begin
         PageFound:=GotoRightPage(CurPage,RetryPages,KeyCounter);
         if PageFound and (not RetryPages) then
            begin
            Inc(SeqNumber);
            if (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_GREATER) then
               Break
            else
               begin
               if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
                  begin
                  Result:=True;
                  Break;
                  end;
               end;
            end
         else
            Break;
         end
      else
         begin
         PageFound:=True;
         Inc(SeqNumber);
         Inc(KeyCounter);
         if (CompareKeys(CurPage.GetKey(KeyCounter),@FEndBuffer,FKeySize)=CMP_GREATER) then
            Break
         else
            begin
            if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
               begin
               Result:=True;
               Break;
               end;
            end;
         end;
      end;
end;

function TDataCursor.FilterRangeScanBackward(var CurPage: TPage;
                                             var SeqNumber: Integer;
                                             var KeyCounter: Integer;
                                             var RetryPages: Boolean;
                                             var PageFound: Boolean): Boolean;
begin
   Result:=False;
   while True do
      begin
      if (KeyCounter=1) then
         begin
         PageFound:=GotoLeftPage(CurPage,RetryPages,KeyCounter);
         if PageFound and (not RetryPages) then
            begin
            Dec(SeqNumber);
            if (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_LESS) then
               Break
            else
               begin
               if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
                  begin
                  Result:=True;
                  Break;
                  end;
               end;
            end
         else
            Break;
         end
      else
         begin
         PageFound:=True;
         Dec(SeqNumber);
         Dec(KeyCounter);
         if (CompareKeys(CurPage.GetKey(KeyCounter),@FBeginBuffer,FKeySize)=CMP_LESS) then
            Break
         else
            begin
            if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
               begin
               Result:=True;
               Break;
               end;
            end;
         end;
      end;
end;

function TDataCursor.FilterScanForward(var CurPage: TPage;
                                       var SeqNumber: Integer;
                                       var KeyCounter: Integer;
                                       var RetryPages: Boolean;
                                       var PageFound: Boolean): Boolean;
begin
   Result:=False;
   while True do
      begin
      if (KeyCounter=CurPage.NumberOfKeys) then
         begin
         PageFound:=GotoRightPage(CurPage,RetryPages,KeyCounter);
         if PageFound and (not RetryPages) then
            begin
            Inc(SeqNumber);
            if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
               begin
               Result:=True;
               Break;
               end;
            end
         else
            Break;
         end
      else
         begin
         PageFound:=True;
         Inc(SeqNumber);
         Inc(KeyCounter);
         if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
end;

function TDataCursor.FilterScanBackward(var CurPage: TPage;
                                        var SeqNumber: Integer;
                                        var KeyCounter: Integer;
                                        var RetryPages: Boolean;
                                        var PageFound: Boolean): Boolean;
begin
   Result:=False;
   while True do
      begin
      if (KeyCounter=1) then
         begin
         PageFound:=GotoLeftPage(CurPage,RetryPages,KeyCounter);
         if PageFound and (not RetryPages) then
            begin
            Dec(SeqNumber);
            if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
               begin
               Result:=True;
               Break;
               end;
            end
         else
            Break;
         end
      else
         begin
         PageFound:=True;
         Dec(SeqNumber);
         Dec(KeyCounter);
         if FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(KeyCounter)) then
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
end;

procedure TDataCursor.GotoRecordNumber(Value: Integer);
var
   ParentPage: TPage;
   ChildPage: TPage;
   ValueFound: Boolean;
   RetryPages: Boolean;
   PageFound: Boolean;
   Low: Integer;
   High: Integer;
   CompareResult: Integer;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
begin
   ValueFound:=False;
   if IsPhysicalNavigation then
      begin
      if (RecordCount <> 0) then
         begin
         FBOF:=False;
         FEOF:=False;
         FSequenceNumber:=0;
         FCurRecordNumber:=0;
         if (not FFilterBitmap.GetNextBitsSet(FCurRecordNumber,Value)) then
            FEOF:=True;
         end
      else
         ResetIndexPosition;
      Exit;
      end
   else if FFiltersInEffect and (FFilterKeys.Count > 0) and
            (FFilterKeyIndexPos=FIndexPos) then
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            Low:=0;
            High:=(FFilterKeys.Count-1);
            while (Low <= High) do
               begin
               FFilterKeyPos:=((Low+High) div 2);
               PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[FFilterKeyPos])^.KeyBuffer,RetryPages);
               if (not RetryPages) then
                  begin
                  if PageFound then
                     begin
                     CompareResult:=CompareNumbers(FSequenceNumber,Value);
                     case CompareResult of
                        CMP_GREATER: High:=(FFilterKeyPos-1);
                        CMP_LESS: Low:=(FFilterKeyPos+1);
                        CMP_EQUAL:
                           Break;
                        end;
                     end
                  else
                     begin
                     ResetIndexPosition;
                     Exit;
                     end;
                  end
               else
                  Break;
               end;
            { Version 5 }
            if RetryPages then
               RebuildFilterKeys;
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end
   else
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            GotoFirstIndexPosition;
            if (Value < ((FSequenceNumber-FBeginSequenceNumber)+1)) then
               begin
               FBOF:=True;
               FEOF:=False;
               Exit;
               end;
            GotoLastIndexPosition;
            if (Value > ((FSequenceNumber-FBeginSequenceNumber)+1)) then
               begin
               FBOF:=False;
               FEOF:=True;
               Exit;
               end;
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempBOF:=False;
                     TempEOF:=False;
                     TempSequenceNumber:=1;
                     TempKeyCounter:=1;
                     while True do
                        begin
                        ValueFound:=GotoRecordScan(ParentPage,Value,
                                                          TempSequenceNumber,TempKeyCounter);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                    ChildPage));
                           if RetryPages then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryPages) then
                        begin
                        if FRangeInEffect then
                           begin
                           if FFiltersInEffect then
                              begin
                              ValueFound:=(ValueFound and FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter)));
                              if (not ValueFound) then
                                 begin
                                 if (TempSequenceNumber < Value) or
                                    (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                    begin
                                    if (not FilterRangeScanForward(ParentPage,TempSequenceNumber,
                                                                   TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          if PageFound or
                                             (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                             begin
                                             if (not FilterRangeScanBackward(ParentPage,TempSequenceNumber,
                                                                             TempKeyCounter,RetryPages,PageFound)) then
                                                begin
                                                if (not RetryPages) then
                                                   begin
                                                   ResetIndexPosition;
                                                   Exit;
                                                   end;
                                                end;
                                             end;
                                          TempEOF:=True;
                                          end;
                                       end;
                                    end;
                                 if (not RetryPages) then
                                    begin
                                    FCurrentPage.Copy(ParentPage);
                                    FCurKeyCounter:=TempKeyCounter;
                                    FSequenceNumber:=TempSequenceNumber;
                                    FBOF:=TempBOF;
                                    FEOF:=TempEOF;
                                    end;
                                 end
                              else
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end
                           else
                              begin
                              if (not ValueFound) then
                                 begin
                                 if (TempSequenceNumber < Value) then
                                    begin
                                    if (not RangeScanForward(ParentPage,TempSequenceNumber,
                                                             TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          if PageFound then
                                             begin
                                             if (not RangeScanBackward(ParentPage,TempSequenceNumber,
                                                                       TempKeyCounter,RetryPages,PageFound)) then
                                                begin
                                                if (not RetryPages) then
                                                   begin
                                                   ResetIndexPosition;
                                                   Exit;
                                                   end;
                                                end;
                                             end;
                                          TempEOF:=True;
                                          end;
                                       end;
                                    end;
                                 if (not RetryPages) then
                                    begin
                                    FCurrentPage.Copy(ParentPage);
                                    FCurKeyCounter:=TempKeyCounter;
                                    FSequenceNumber:=TempSequenceNumber;
                                    FBOF:=TempBOF;
                                    FEOF:=TempEOF;
                                    end;
                                 end
                              else
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end;
                           end
                        else if FFiltersInEffect then
                           begin
                           ValueFound:=(ValueFound and FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter)));
                           if (not ValueFound) then
                              begin
                              if (TempSequenceNumber < Value) or
                                 (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                 begin
                                 if (not FilterScanForward(ParentPage,TempSequenceNumber,
                                                           TempKeyCounter,RetryPages,PageFound)) then
                                    begin
                                    if (not RetryPages) then
                                       begin
                                       if PageFound or
                                          (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                          begin
                                          if (not FilterScanBackward(ParentPage,TempSequenceNumber,
                                                                     TempKeyCounter,RetryPages,PageFound)) then
                                             begin
                                             if (not RetryPages) then
                                                begin
                                                ResetIndexPosition;
                                                Exit;
                                                end;
                                             end;
                                          end;
                                       TempEOF:=True;
                                       end;
                                    end;
                                 end;
                              if (not RetryPages) then
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end
                           else
                              begin
                              FCurrentPage.Copy(ParentPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end
                        else
                           begin
                           if (not ValueFound) then
                              begin
                              if (TempSequenceNumber < Value) then
                                 begin
                                 if (not ScanForward(ParentPage,TempSequenceNumber,
                                                     TempKeyCounter,RetryPages,PageFound)) then
                                    begin
                                    if (not RetryPages) then
                                       begin
                                       if PageFound then
                                          begin
                                          if (not ScanBackward(ParentPage,TempSequenceNumber,
                                                               TempKeyCounter,RetryPages,PageFound)) then
                                             begin
                                             if (not RetryPages) then
                                                begin
                                                ResetIndexPosition;
                                                Exit;
                                                end;
                                             end;
                                          end;
                                       TempEOF:=True;
                                       end;
                                    end;
                                 end;
                              if (not RetryPages) then
                                 begin
                                 FCurrentPage.Copy(ParentPage);
                                 FCurKeyCounter:=TempKeyCounter;
                                 FSequenceNumber:=TempSequenceNumber;
                                 FBOF:=TempBOF;
                                 FEOF:=TempEOF;
                                 end;
                              end
                           else
                              begin
                              FCurrentPage.Copy(ParentPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  begin
                  ResetIndexPosition;
                  Exit;
                  end;
               end;
            { Version 5 }
            { Removed ForceRefresh on RetryPages }
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end;
end;

procedure TDataCursor.GotoPhysicalRecordNumber(Value: Integer);
begin
   if IsPhysicalNavigation then
      begin
      if (Value <> 0) then
         begin
         FBOF:=False;
         FEOF:=False;
         FSequenceNumber:=0;
         if (Value < 0) then
            FCurRecordNumber:=1
         else if (Value > PhysicalRecordsUsed) then
            FCurRecordNumber:=PhysicalRecordsUsed
         else
            FCurRecordNumber:=Value;
         VerifyPhysicalRecordPosition;
         end;
      end;
end;

procedure TDataCursor.SetBeginIndexRange(Buffer: PChar);
begin
   FillChar(FBeginBuffer,MAX_KEYLEN,#0);
   Move(Buffer^,FBeginBuffer,FKeySize);
end;

procedure TDataCursor.SetEndIndexRange(Buffer: PChar);
begin
   FillChar(FEndBuffer,MAX_KEYLEN,#0);
   Move(Buffer^,FEndBuffer,FKeySize);
end;

procedure TDataCursor.UpdateRange;
var
   ParentPage: TPage;
   ChildPage: TPage;
   CompareResult: Integer;
   RetryPages: Boolean;
   PageFound: Boolean;
   TempKeyCounter: Integer;
begin
   RetryPages:=True;
   while RetryPages do
      begin
      RetryPages:=False;
      if (not IsPhysicalNavigation) and FRangeInEffect and (not FFiltersInEffect) then
         begin
         { Check to make sure that the begin and end buffers are not crossed }
         CompareResult:=CompareKeys(@FBeginBuffer,@FEndBuffer,
                                    FKeySize);
         if (CompareResult=CMP_LESS) or
            (CompareResult=CMP_EQUAL) then
            begin
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempKeyCounter:=1;
                     FBeginSequenceNumber:=1;
                     while True do
                        begin
                        BeginRangeScan(ParentPage,FBeginSequenceNumber,
                                       TempKeyCounter,@FBeginBuffer);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                    ChildPage));
                           if RetryPages then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryPages) then
                        begin
                        if (CompareKeys(ParentPage.GetKey(TempKeyCounter),@FBeginBuffer,
                                         FKeySize)=CMP_LESS) then
                           begin
                           PageFound:=GotoRightPage(ParentPage,RetryPages,TempKeyCounter);
                           if (not RetryPages) then
                              begin
                              if PageFound then
                                 begin
                                 CompareResult:=CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                                            @FBeginBuffer,FKeySize);
                                 if (CompareResult=CMP_GREATER) or
                                    (CompareResult=CMP_EQUAL) then
                                    Inc(FBeginSequenceNumber,ParentPage.GetLowerKeyCount(TempKeyCounter))
                                 else
                                    FBeginSequenceNumber:=0;
                                 end
                              else
                                 FBeginSequenceNumber:=0;
                              end;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  FBeginSequenceNumber:=0;
               if (not RetryPages) then
                  begin
                  PageFound:=GetRootPage(ParentPage,RetryPages);
                  if (not RetryPages) then
                     begin
                     if PageFound then
                        begin
                        try
                           TempKeyCounter:=1;
                           FEndSequenceNumber:=1;
                           while True do
                              begin
                              EndRangeScan(ParentPage,FEndSequenceNumber,
                                           TempKeyCounter,@FEndBuffer);
                              if (ParentPage.PageType > INTERNAL_NODE) then
                                 Break
                              else
                                 begin
                                 RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                          ChildPage));
                                 if RetryPages then
                                    begin
                                    ParentPage:=nil;
                                    Break;
                                    end
                                 else
                                    begin
                                    PutPage(ParentPage);
                                    ParentPage:=ChildPage;
                                    end;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              if (CompareKeys(ParentPage.GetKey(TempKeyCounter),@FEndBuffer,
                                               FKeySize)=CMP_GREATER) then
                                 begin
                                 PageFound:=GotoLeftPage(ParentPage,RetryPages,TempKeyCounter);
                                 if (not RetryPages) then
                                    begin
                                    if PageFound then
                                       begin
                                       CompareResult:=CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                                                  @FEndBuffer,FKeySize);
                                       if (CompareResult=CMP_LESS) or
                                          (CompareResult=CMP_EQUAL) then
                                          Dec(FEndSequenceNumber,ParentPage.GetLowerKeyCount(TempKeyCounter))
                                       else
                                          FEndSequenceNumber:=0;
                                       end
                                    else
                                       FEndSequenceNumber:=0;
                                    end;
                                 end;
                              end;
                        finally
                           PutPage(ParentPage);
                        end;
                        end
                     else
                        FEndSequenceNumber:=0;
                     end;
                  end;
               end;
            { Version 5 }
            { Removed ForceRefresh on RetryPages }
            { Version 5 }
            end
         else
            begin
            FBeginSequenceNumber:=0;
            FEndSequenceNumber:=0;
            end;
         end
      else
         begin
         FBeginSequenceNumber:=1;
         FEndSequenceNumber:=TotalRecordCount;
         end;
      end;
end;

procedure TDataCursor.ActivateRange;
begin
   FRangeInEffect:=True;
end;

procedure TDataCursor.CancelRange;
begin
   if (not IsRemote) then
      begin
      FillChar(FBeginBuffer,MAX_KEYLEN,#0);
      FillChar(FEndBuffer,MAX_KEYLEN,#0);
      FBeginSequenceNumber:=1;
      FEndSequenceNumber:=TotalRecordCount;
      end;
   FRangeInEffect:=False;
end;

function TDataCursor.SearchIndexKeys(Buffer: PChar): Boolean;
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   TempKeyCounter: Integer;
begin
   Result:=False;
   if GetRootPage(ParentPage,RetryPages) then
      begin
      try
         TempKeyCounter:=1;
         while True do
            begin
            Result:=SearchScan(ParentPage,Buffer,TempKeyCounter,FKeySize);
            if (ParentPage.PageType > INTERNAL_NODE) then
               Break
            else
               begin
               GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
               PutPage(ParentPage);
               ParentPage:=ChildPage;
               end;
            end;
      finally
         PutPage(ParentPage);
      end;
      end;
end;

function TDataCursor.VerifyIndexKey(Buffer: PChar;
                                    RecordNum: Integer): Boolean;
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   TempKeyCounter: Integer;
begin
   Result:=False;
   if GetRootPage(ParentPage,RetryPages) then
      begin
      try
         TempKeyCounter:=1;
         while True do
            begin
            Result:=SearchScan(ParentPage,Buffer,TempKeyCounter,FKeySize);
            if (ParentPage.PageType > INTERNAL_NODE) then
               Break
            else
               begin
               GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
               try
                  { Check to make sure that the descending search keys match }
                  if (CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                  ChildPage.GetKey(1),FKeySize) <> CMP_EQUAL) then
                     begin
                     Result:=False;
                     Exit;
                     end;
               finally
                  PutPage(ParentPage);
                  ParentPage:=ChildPage;
               end;
               end;
            end;
         if Result and (ParentPage.GetRecordNumber(TempKeyCounter) <> RecordNum) then
            Result:=False;
      finally
         PutPage(ParentPage);
      end;
      end;
end;

function TDataCursor.VerifyNextIndexPage(NextPageNum: Integer;
                                         KeyBuffer: PChar;
                                         UpperKeyCount: Integer): Boolean;
var
   NextPage: TPage;
   TempKeyCounter: Integer;
   TempKeyCount: Integer;
begin
   Result:=True;
   GetPage(NextPageNum,NextPage);
   try
      if (NextPage <> nil) then
         begin
         if (NextPage.NumberOfKeys=0) then
            begin
            Result:=False;
            Exit;
            end;
         TempKeyCounter:=1;
         if (KeyBuffer <> nil) and
            (CompareKeys(KeyBuffer,
                         NextPage.GetKey(TempKeyCounter),FKeySize) <> CMP_EQUAL) then
            begin
            Result:=False;
            Exit;
            end;
         { Version 5 }
         TempKeyCount:=0;
         { Version 5 }
         if (NextPage.PageType < EXTERNAL_NODE) then
            begin
            while (TempKeyCounter <= NextPage.NumberOfKeys) do
               begin
               if (not VerifyNextIndexPage(NextPage.GetRecordNumber(TempKeyCounter),
                                           NextPage.GetKey(TempKeyCounter),
                                           NextPage.GetLowerKeyCount(TempKeyCounter))) then
                  begin
                  Result:=False;
                  Break;
                  end;
               { Version 5 }
               Inc(TempKeyCount,NextPage.GetLowerKeyCount(TempKeyCounter));
               { Version 5 }
               Inc(TempKeyCounter);
               end;
            end
         else
            begin
            while (TempKeyCounter <= NextPage.NumberOfKeys) do
               begin
               if (NextPage.GetRecordNumber(TempKeyCounter) < 1) or
                  (NextPage.GetRecordNumber(TempKeyCounter) > PhysicalRecordsUsed) then
                  begin
                  Result:=False;
                  Break;
                  end;
               { Version 5 }
               Inc(TempKeyCount,NextPage.GetLowerKeyCount(TempKeyCounter));
               { Version 5 }
               Inc(TempKeyCounter);
               end;
            end;
         { Version 5 }
         if (TempKeyCount <> UpperKeyCount) then
            begin
            Result:=False;
            Exit;
            end;
         { Version 5 }
         end
      else
         Result:=False;
   finally
      PutPage(NextPage);
   end;
end;

function TDataCursor.IsUniqueIndex(UniquePos: Byte): Boolean;
begin
   Result:=GetIndexDefinition(UniquePos)^.KeyUnique;
end;

function TDataCursor.SearchScan(Page: TPage; KeyBuffer: PChar;
                                var KeyCounter: Integer;
                                CompareLength: Word): Boolean;
var
   KeyPtr: PChar;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
   CompareResult: Integer;
begin
   Result:=False;
   with Page do
      begin
      KeyCounter:=1;
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,KeyBuffer,CompareLength);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS: LowKeyCounter:=KeyCounter+1;
            CMP_EQUAL:
               begin
               if (PageType > INTERNAL_NODE) then
                  Result:=True;
               Break;
               end;
            end;
         end;
      end;
end;

function TDataCursor.FindScan(Page: TPage; KeyBuffer: PChar;
                              var SeqNumber: Integer; var KeyCounter: Integer;
                              IsSoftSeek: Boolean): Boolean;
var
   KeyPtr: PChar;
   CompareResult: Integer;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
begin
   Result:=False;
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,KeyBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (((PageType > INTERNAL_NODE) and (not IsSoftSeek)) or
                   (PageType < EXTERNAL_NODE)) and
                  (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS:
               begin
               LowKeyCounter:=KeyCounter+1;
               if ((PageType > INTERNAL_NODE) and IsSoftSeek) and
                  (LowKeyCounter > HighKeyCounter) and
                  (LowKeyCounter <= NumberOfKeys) then
                  KeyCounter:=LowKeyCounter;
               end;
            CMP_EQUAL:
               begin
               Result:=True;
               Break;
               end;
            end;
         end;
      Inc(SeqNumber,GetPageKeyCount(KeyCounter));
      end;
end;

function TDataCursor.FindRangeScan(Page: TPage; KeyBuffer: PChar;
                                   EndBuffer: PChar; var SeqNumber: Integer;
                                   var KeyCounter: Integer; IsSoftSeek: Boolean): Boolean;
var
   KeyPtr: PChar;
   CompareResult: Integer;
begin
   Result:=False;
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      KeyPtr:=Buffer;
      if (PageType > INTERNAL_NODE) then
         begin
         while True do
            begin
            if (CompareKeys(KeyPtr,EndBuffer,FKeySize)=CMP_GREATER) then
               begin
               if (KeyCounter <> 1) then
                  begin
                  Dec(KeyCounter);
                  Dec(SeqNumber);
                  end;
               Break;
               end
            else
               begin
               CompareResult:=CompareKeys(KeyPtr,KeyBuffer,FKeySize);
               case CompareResult of
                  CMP_EQUAL:
                     begin
                     Result:=True;
                     Break;
                     end;
                  CMP_GREATER:
                     begin
                     if (not IsSoftSeek) and (KeyCounter <> 1) then
                        begin
                        Dec(KeyCounter);
                        Dec(SeqNumber);
                        end;
                     Break;
                     end;
                  end;
               end;
            if (KeyCounter=NumberOfKeys) then
               Break
            else
               begin
               Inc(SeqNumber);
               Inc(KeyPtr,(FKeySize+KEY_DATA));
               Inc(KeyCounter);
               end;
            end;
         end
      else
         begin
         while True do
            begin
            if (CompareKeys(KeyPtr,EndBuffer,FKeySize)=CMP_GREATER) then
               begin
               if (KeyCounter <> 1) then
                  begin
                  Dec(KeyPtr,(FKeySize+KEY_DATA));
                  Dec(KeyCounter);
                  Dec(SeqNumber,pInteger((KeyPtr+FKeySize+RECORD_SIZE))^)
                  end;
               Break;
               end
            else
               begin
               CompareResult:=CompareKeys(KeyPtr,KeyBuffer,FKeySize);
               case CompareResult of
                  CMP_EQUAL: Break;
                  CMP_GREATER:
                     begin
                     if (KeyCounter <> 1) then
                        begin
                        Dec(KeyPtr,(FKeySize+KEY_DATA));
                        Dec(KeyCounter);
                        Dec(SeqNumber,pInteger((KeyPtr+FKeySize+RECORD_SIZE))^)
                        end;
                     Break;
                     end;
                  end;
               end;
            if (KeyCounter=NumberOfKeys) then
               Break
            else
               begin
               Inc(SeqNumber,pInteger((KeyPtr+FKeySize+RECORD_SIZE))^);
               Inc(KeyPtr,(FKeySize+KEY_DATA));
               Inc(KeyCounter);
               end;
            end;
         end;
      end;
end;

function TDataCursor.GotoRecordScan(Page: TPage; Value: Integer;
                                           var SeqNumber: Integer;
                                           var KeyCounter: Integer): Boolean;
begin
   Result:=False;
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      while True do
         begin
         if (((SeqNumber-FBeginSequenceNumber)+1) > FEndSequenceNumber) then
            begin
            { Sequence number is greater than the ending range sequence number }
            if (KeyCounter <> 1) then
               begin
               Dec(KeyCounter);
               Dec(SeqNumber,GetLowerKeyCount(KeyCounter));
               end;
            { If we're on an external node then go ahead and set the
              EOF flag }
            if (PageType > INTERNAL_NODE) then
               FEOF:=True;
            Break;
            end
         else if (((SeqNumber-FBeginSequenceNumber)+1) > Value) then
            begin
            { Sequence number is greater than the value we want }
            if (KeyCounter <> 1) then
               begin
               Dec(KeyCounter);
               Dec(SeqNumber,GetLowerKeyCount(KeyCounter));
               end;
            Break;
            end
         else if (((SeqNumber-FBeginSequenceNumber)+1)=Value) then
            begin
            Result:=True;
            Break;
            end;
         if (KeyCounter=NumberOfKeys) then
            Break
         else
            begin
            Inc(SeqNumber,GetLowerKeyCount(KeyCounter));
            Inc(KeyCounter);
            end;
         end;
      end;
end;

procedure TDataCursor.FirstScan(Page: TPage; var SeqNumber: Integer;
                                var KeyCounter: Integer);
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      SeqNumber:=1;
      end;
end;

procedure TDataCursor.LastScan(Page: TPage; var SeqNumber: Integer;
                               var KeyCounter: Integer);
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=NumberOfKeys;
      Inc(SeqNumber,GetPageKeyCount(KeyCounter));
      end;
end;

procedure TDataCursor.FirstRangeScan(Page: TPage; var SeqNumber: Integer;
                                     var KeyCounter: Integer; BeginBuffer: PChar);
var
   KeyPtr: PChar;
   CompareResult: Integer;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,BeginBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (PageType < EXTERNAL_NODE) and
                  (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS:
               begin
               LowKeyCounter:=KeyCounter+1;
               if (PageType > INTERNAL_NODE) and
                  (LowKeyCounter > HighKeyCounter) and
                  (LowKeyCounter <= NumberOfKeys) then
                  KeyCounter:=LowKeyCounter;
               end;
            CMP_EQUAL: Break;
            end;
         end;
      Inc(SeqNumber,GetPageKeyCount(KeyCounter));
      end;
end;

procedure TDataCursor.LastRangeScan(Page: TPage; var SeqNumber: Integer;
                                    var KeyCounter: Integer; EndBuffer: PChar);
var
   KeyPtr: PChar;
   CompareResult: Integer;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,EndBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS: LowKeyCounter:=KeyCounter+1;
            CMP_EQUAL: Break;
            end;
         end;
      Inc(SeqNumber,Page.GetPageKeyCount(KeyCounter));
      end;
end;

procedure TDataCursor.BeginScan(Page: TPage; var KeyCounter: Integer; BeginBuffer: PChar);
var
   KeyPtr: PChar;
   CompareResult: Integer;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,BeginBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (PageType < EXTERNAL_NODE) and
                  (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS:
               begin
               LowKeyCounter:=KeyCounter+1;
               if (PageType > INTERNAL_NODE) and
                  (LowKeyCounter > HighKeyCounter) and
                  (LowKeyCounter <= NumberOfKeys) then
                  KeyCounter:=LowKeyCounter;
               end;
            CMP_EQUAL: Break;
            end;
         end;
      end;
end;

procedure TDataCursor.EndScan(Page: TPage; var KeyCounter: Integer; EndBuffer: PChar);
var
   KeyPtr: PChar;
   CompareResult: Integer;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      KeyCounter:=1;
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,EndBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS: LowKeyCounter:=KeyCounter+1;
            CMP_EQUAL: Break;
            end;
         end;
      end;
end;


procedure TDataCursor.BeginRangeScan(Page: TPage; var BeginSeqNumber: Integer;
                                     var KeyCounter: Integer; BeginBuffer: PChar);
begin
   BeginScan(Page,KeyCounter,BeginBuffer);
   Inc(BeginSeqNumber,Page.GetPageKeyCount(KeyCounter));
end;

procedure TDataCursor.EndRangeScan(Page: TPage; var EndSeqNumber: Integer;
                                   var KeyCounter: Integer; EndBuffer: PChar);
begin
   EndScan(Page,KeyCounter,EndBuffer);
   Inc(EndSeqNumber,Page.GetPageKeyCount(KeyCounter));
end;

procedure TDataCursor.FilterSetIndexedBits(var Page: TPage;
                                           Bitmap: TRecordsBitmap;
                                           EndBuffer: PChar;
                                           var KeyCounter: Integer;
                                           var RetryFilter: Boolean);
var
   KeyPtr: PChar;
   SecondKeyCounter: Integer;
   PageFound: Boolean;
begin
   while True do
      begin
      if not (CompareKeys(Page.GetKey(KeyCounter),
                          EndBuffer,FKeySize)=CMP_GREATER) then
         begin
         with Page do
            begin
            if (NumberOfKeys=0) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                     FTableName);
            KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(NumberOfKeys-1)));
            if (CompareKeys(KeyPtr,EndBuffer,FKeySize)=CMP_GREATER) then
               begin
               SecondKeyCounter:=KeyCounter;
               { Find the ending key counter for the range on the current page }
               EndScan(Page,SecondKeyCounter,EndBuffer);
               end
            else
               SecondKeyCounter:=NumberOfKeys;
            KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize);
            while (KeyCounter <= SecondKeyCounter) do
               begin
               Bitmap.SetBit(pInteger(KeyPtr)^);
               Inc(KeyCounter);
               Inc(KeyPtr,(FKeySize+KEY_DATA));
               end;
            end;
         if (KeyCounter > Page.NumberOfKeys) then
            begin
            PageFound:=GotoRightPage(Page,RetryFilter,KeyCounter);
            if RetryFilter or (not PageFound) then
               Break;
            end
         else
            Break;
         end
      else
         Break;
      end;
end;

function TDataCursor.CountSequentialRecords(Page: TPage; MaxNumRecords: Integer;
                                            Direction: Byte; KeyCounter: Integer): Integer;
var
   KeyPtr: PChar;
   LastRecordNumber: Integer;
begin
   with Page do
      begin
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      Result:=0;
      KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize);
      if (Direction=READ_FORWARD) then
         begin
         LastRecordNumber:=(pInteger(KeyPtr)^-1);
         while (KeyCounter <= NumberOfKeys) and
               (Result < MaxNumRecords) and
               (LastRecordNumber=(pInteger(KeyPtr)^-1)) do
            begin
            Inc(Result);
            Inc(KeyPtr,(FKeySize+KEY_DATA));
            Inc(KeyCounter);
            Inc(LastRecordNumber);
            end;
         end
      else
         begin
         LastRecordNumber:=(pInteger(KeyPtr)^+1);
         while (KeyCounter >= 1) and
               (Result < MaxNumRecords) and
               (LastRecordNumber=(pInteger(KeyPtr)^+1)) do
            begin
            Inc(Result);
            Dec(KeyPtr,(FKeySize+KEY_DATA));
            Dec(KeyCounter);
            Dec(LastRecordNumber);
            end;
         end;
      end;
end;

function TDataCursor.CheckForKeyViolation(BufferToCheck: PChar): Boolean;
begin
   if SearchIndexKeys(BufferToCheck) then
      Result:=True
   else
      Result:=False;
end;

procedure TDataCursor.RaiseKeyViolationError;
begin
   if (FIndexName='') then
      DataEngine.RaiseError(DBISAM_KEYVIOL,'','',ProperDataDirectoryName,ProperTableName,'','Primary')
   else
      DataEngine.RaiseError(DBISAM_KEYVIOL,'','',ProperDataDirectoryName,ProperTableName,'',FIndexName);
end;

procedure TDataCursor.AddIndexKey(NewBuffer: PChar; NewRecord: Integer);
begin
   BeginIndexKeyInsert(NewBuffer,NewRecord);
end;

procedure TDataCursor.InsertScan(Page: TPage; KeyBuffer: PChar;
                                 var KeyCounter: Integer);
var
   KeyPtr: PChar;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
   CompareResult: Integer;
begin
   with Page do
      begin
      KeyCounter:=0;
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                 FTableName);
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,KeyBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 0) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS: LowKeyCounter:=KeyCounter+1;
            CMP_EQUAL: Break;
            end;
         end;
      end;
end;

procedure TDataCursor.BeginIndexKeyInsert(NewBuffer: PChar; NewRecord: Integer);
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   TempKeyCounter: Integer;
begin
   if GetRootPage(ParentPage,RetryPages) then
      begin
      try
         FCurIndexLevel:=1;
         ClearIndexKeyCounters;
         ClearParentNumbers;
         TempKeyCounter:=1;
         while True do
            begin
            InsertScan(ParentPage,NewBuffer,TempKeyCounter);
            SetIndexKeyCounter(TempKeyCounter);
            if (ParentPage.PageType > INTERNAL_NODE) then
               Break
            else
               begin
               { Update the record stats for the current index to reflect the
                 new key entry, check to see if we're on the first key and
                 handle accordingly }
               if (TempKeyCounter=0) then
                  begin
                  Inc(TempKeyCounter);
                  ParentPage.IncLowerKeyCount(TempKeyCounter);
                  GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
                  end
               else
                  begin
                  ParentPage.IncLowerKeyCount(TempKeyCounter);
                  GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
                  end;
               IncCurIndexLevel;
               if (FCurIndexLevel > MAX_INDEX_LEVELS) then
                  DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
               SetParentNumber(ParentPage.Number);
               PutPage(ParentPage);
               ParentPage:=ChildPage;
               end;
            end;
         { Insert the index key }
         InsertIndexKey(ParentPage,NewBuffer,NewRecord,0);
      finally
         PutPage(ParentPage);
      end;
      end
   else
      begin
      { No keys currently, create a new root page }
      GetNextFreePage(ParentPage);
      try
         ParentPage.PageType:=BOTH_NODE;
         { Insert the first key and write new page to disk }
         TempKeyCounter:=0;
         ParentPage.InsertKey(NewBuffer,TempKeyCounter);
         ParentPage.SetRecordNumber(TempKeyCounter,NewRecord);
         { Recalculate the compression information }
         ParentPage.CalculateCompressedSize(TempKeyCounter,True);
         { Update the index header root pointer }
         SetRootPageNumber(ParentPage.Number);
      finally
         PutPage(ParentPage);
      end;
      end;
end;

procedure TDataCursor.InsertIndexKey(InsertPage: TPage; NewBuffer: PChar;
                                      NewRecord: Integer; NewCount: Integer);
var
   ParentPage: TPage;
   RightPage: TPage;
   OldPageType: Byte;
   TempLevel: Byte;
   TempKeyCounter: Integer;
begin
   with InsertPage do
      begin
      { Insert the key entry }
      TempKeyCounter:=GetIndexKeyCounter;
      InsertKey(NewBuffer,TempKeyCounter);
      SetIndexKeyCounter(TempKeyCounter);
      SetRecordNumber(TempKeyCounter,NewRecord);
      SetLowerKeyCount(TempKeyCounter,NewCount);
      { Recalculate the compression information }
      CalculateCompressedSize(TempKeyCounter,True);
      { Update the upper index key entries }
      UpdateUpperIndexKeys(InsertPage,GetKey(TempKeyCounter));
      { Check to see if we need to split the current page }
      if PageDataOverflowed then
         begin
         { Need to split the page, get the next free page for the right
           page }
         GetNextFreePage(RightPage);
         try
            OldPageType:=PageType;
            SplitPage(InsertPage,RightPage);
            { If we're not splitting the root, then update the
              parent page of the current page with the new
              key counts }
            if (OldPageType in [INTERNAL_NODE,EXTERNAL_NODE]) then
               begin
               if (GetParentNumber=0) then
                  DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                          FTableName);
               { Get the parent page for the current page }
               TempLevel:=FCurIndexLevel;
               try
                  GetPage(GetParentNumber,ParentPage);
                  try
                     DecCurIndexLevel;
                     { Update the key counts for the parent key entry }
                     ParentPage.SetLowerKeyCount(GetIndexKeyCounter,
                                                 TotalLowerKeyCount);
                     { Recursively call the InsertIndexKey procedure for the parent }
                     InsertIndexKey(ParentPage,RightPage.GetKey(1),
                                    RightPage.Number,RightPage.TotalLowerKeyCount);
                  finally
                     PutPage(ParentPage);
                  end;
               finally
                  FCurIndexLevel:=TempLevel;
               end;
               end
            else
               begin
               { If we're not on the first level, then there's something wrong
                 with the index }
               if (FCurIndexLevel <> 1) or (FCurIndexLevel  > MAX_INDEX_LEVELS) then
                  DataEngine.RaiseError(DBISAM_TABLEFULL,'','',ProperDataDirectoryName,
                                        FTableName);
               { Allocate a new root page }
               GetNextFreePage(ParentPage);
               try
                  ParentPage.PageType:=ROOT_NODE;
                  SetRootPageNumber(ParentPage.Number);
                  { Insert the current page and new right page key
                    entries into the new root node }
                  TempKeyCounter:=0;
                  ParentPage.InsertKey(GetKey(1),TempKeyCounter);
                  ParentPage.SetRecordNumber(TempKeyCounter,Number);
                  ParentPage.SetLowerKeyCount(TempKeyCounter,
                                               TotalLowerKeyCount);
                  ParentPage.InsertKey(RightPage.GetKey(1),TempKeyCounter);
                  ParentPage.SetRecordNumber(TempKeyCounter,RightPage.Number);
                  ParentPage.SetLowerKeyCount(TempKeyCounter,
                                               RightPage.TotalLowerKeyCount);
                  SetIndexKeyCounter(TempKeyCounter);
               finally
                  PutPage(ParentPage);
               end;
               end;
         finally
            PutPage(RightPage);
         end;
         end;
      end;
end;

procedure TDataCursor.SplitPage(InsertPage: TPage; SplitPage: TPage);
var
   HalfKeyNumber: Word;
   RightPage: TPage;
begin
   with InsertPage do
      begin
      { Find the half-way key entry }
      HalfKeyNumber:=(NumberOfKeys-(NumberOfKeys div 2));
      { Move half of the keys from the current page data to the
        right page }
      SplitPage.NumberOfKeys:=(NumberOfKeys-HalfKeyNumber);
      Move((Buffer+((HalfKeyNumber*(FKeySize+KEY_DATA))))^,SplitPage.Buffer^,
           (FKeySize+KEY_DATA)*(NumberOfKeys-HalfKeyNumber));
      NumberOfKeys:=HalfKeyNumber;
      if (PageType > INTERNAL_NODE) then
         begin
         PageType:=EXTERNAL_NODE;
         SplitPage.PageType:=EXTERNAL_NODE;
         end
      else
         begin
         PageType:=INTERNAL_NODE;
         SplitPage.PageType:=INTERNAL_NODE;
         end;
      { Update the node pointers }
      if (RightNumber <> 0) then
         begin
         GetPage(RightNumber,RightPage);
         try
            RightPage.LeftNumber:=SplitPage.Number;
            SplitPage.RightNumber:=RightPage.Number;
         finally
            PutPage(RightPage);
         end;
         end;
      RightNumber:=SplitPage.Number;
      SplitPage.LeftNumber:=Number;
      IsDirty:=True;
      SplitPage.IsDirty:=True;
      { Recalculate the compression information }
      RecalculateTotalCompressedSize;
      SplitPage.CalculateCompressedSize(1,True);
      SplitPage.RecalculateTotalCompressedSize;
      if ((PageType > INTERNAL_NODE) and (KeyCompressionType > NO_COMPRESS)) then
         begin
         if (CompressedSize > IndexPageBufferSize) then
            begin
            while (CompressedSize > IndexPageBufferSize) do
               begin
               { If the current page exceeds the total allowable compressed size
                 then we should start moving back one key at a time until
                 the compressed size is acceptable }
               SplitPage.NumberOfKeys:=(SplitPage.NumberOfKeys+1);
               Move(SplitPage.Buffer^,(SplitPage.Buffer+(KeySize+KEY_DATA))^,
                    (KeySize+KEY_DATA)*(SplitPage.NumberOfKeys-1));
               Move((Buffer+((NumberOfKeys-1)*(KeySize+KEY_DATA)))^,
                     SplitPage.Buffer^,(KeySize+KEY_DATA));
               NumberOfKeys:=(NumberOfKeys-1);
               { Recalculate the compression information }
               RecalculateTotalCompressedSize;
               SplitPage.CalculateCompressedSize(1,True);
               SplitPage.RecalculateTotalCompressedSize;
               end;
            if (SplitPage.CompressedSize > IndexPageBufferSize) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                       FTableName,'','','');
            end
         else if (SplitPage.CompressedSize > IndexPageBufferSize) then
            begin
            while (SplitPage.CompressedSize > IndexPageBufferSize) do
               begin
               { If the right page exceeds the total allowable compressed size
                 then we should start moving back one key at a time until
                 the compressed size is acceptable }
               NumberOfKeys:=(NumberOfKeys+1);
               Move(SplitPage.Buffer^,(Buffer+((NumberOfKeys-1)*(KeySize+KEY_DATA)))^,
                    (KeySize+KEY_DATA));
               Move((SplitPage.Buffer+(KeySize+KEY_DATA))^,
                     SplitPage.Buffer^,(KeySize+KEY_DATA)*(SplitPage.NumberOfKeys-1));
               SplitPage.NumberOfKeys:=(SplitPage.NumberOfKeys-1);
               { Recalculate the compression information }
               CalculateCompressedSize(NumberOfKeys,True);
               RecalculateTotalCompressedSize;
               SplitPage.RecalculateTotalCompressedSize;
               end;
            if (CompressedSize > IndexPageBufferSize) then
               DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                       FTableName,'','','');
            end;
         end;
      if (CompressedSize > IndexPageBufferSize) or
         (SplitPage.CompressedSize > IndexPageBufferSize) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      end;
end;

procedure TDataCursor.UpdateUpperIndexKeys(UpdatePage: TPage; NewBuffer: PChar);
var
   ParentPage: TPage;
   TempLevel: Byte;
begin
   with UpdatePage do
      begin
      { If we're sitting on the first key entry, then we need to update
        the upper index keys with the new value }
      if (GetParentNumber <> 0) and (GetIndexKeyCounter=1) then
         begin
         TempLevel:=FCurIndexLevel;
         try
            GetPage(GetParentNumber,ParentPage);
            try
               DecCurIndexLevel;
               if (GetIndexKeyCounter=0) then
                  SetIndexKeyCounter(1);
               ParentPage.UpdateKey(NewBuffer,GetIndexKeyCounter);
               UpdateUpperIndexKeys(ParentPage,ParentPage.GetKey(GetIndexKeyCounter));
            finally
               PutPage(ParentPage);
            end;
         finally
            FCurIndexLevel:=TempLevel;
         end;
         end;
      end;
end;

procedure TDataCursor.UpdateIndexKey(OldBuffer: PChar;
                                     NewBuffer: PChar;
                                     NewRecord: Integer);
begin
   { Check to make sure the key already exists }
   if not SearchIndexKeys(OldBuffer) then
      DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
   BeginIndexKeyDelete(OldBuffer);
   BeginIndexKeyInsert(NewBuffer,NewRecord);
end;

procedure TDataCursor.RemoveIndexKey(OldBuffer: PChar);
begin
   { Check to see if the key already exists }
   if not SearchIndexKeys(OldBuffer) then
      DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
   BeginIndexKeyDelete(OldBuffer);
end;

procedure TDataCursor.DeleteScan(Page: TPage; KeyBuffer: PChar;
                                 var KeyCounter: Integer);
var
   KeyPtr: PChar;
   LowKeyCounter: Integer;
   HighKeyCounter: Integer;
   CompareResult: Integer;
begin
   with Page do
      begin
      KeyCounter:=1;
      if (NumberOfKeys=0) then
         DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                               FTableName);
      LowKeyCounter:=1;
      HighKeyCounter:=NumberOfKeys;
      while (LowKeyCounter <= HighKeyCounter) do
         begin
         KeyCounter:=((LowKeyCounter+HighKeyCounter) div 2);
         KeyPtr:=(Buffer+((FKeySize+KEY_DATA)*(KeyCounter-1)));
         CompareResult:=CompareKeys(KeyPtr,KeyBuffer,FKeySize);
         case CompareResult of
            CMP_GREATER:
               begin
               HighKeyCounter:=KeyCounter-1;
               if (HighKeyCounter < LowKeyCounter) and
                  (HighKeyCounter >= 1) then
                  KeyCounter:=HighKeyCounter;
               end;
            CMP_LESS: LowKeyCounter:=KeyCounter+1;
            CMP_EQUAL: Break;
            end;
         end;
      end;
end;

procedure TDataCursor.BeginIndexKeyDelete(OldBuffer: PChar);
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   TempKeyCounter: Integer;
begin
   if GetRootPage(ParentPage,RetryPages) then
      begin
      try
         FCurIndexLevel:=1;
         ClearIndexKeyCounters;
         ClearParentNumbers;
         TempKeyCounter:=1;
         while True do
            begin
            DeleteScan(ParentPage,OldBuffer,TempKeyCounter);
            SetIndexKeyCounter(TempKeyCounter);
            if (ParentPage.PageType > INTERNAL_NODE) then
               Break
            else
               begin
               { Update the record stats for the current index to reflect the
                 new key entry }
               ParentPage.DecLowerKeyCount(TempKeyCounter);
               GetPage(ParentPage.GetRecordNumber(TempKeyCounter),ChildPage);
               IncCurIndexLevel;
               if (FCurIndexLevel > MAX_INDEX_LEVELS) then
                  DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName);
               SetParentNumber(ParentPage.Number);
               PutPage(ParentPage);
               ParentPage:=ChildPage;
               end;
            end;
         { Delete the index key }
         DeleteIndexKey(ParentPage);
      finally
         PutPage(ParentPage);
      end;
      end
   else
      DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,ProperTableName)
end;

procedure TDataCursor.DeleteIndexKey(DeletePage: TPage);
var
   ParentPage: TPage;
   ChildPage: TPage;
   LeftPage: TPage;
   RightPage: TPage;
   IsLeftPage: Boolean;
   IsRightPage: Boolean;
   TempLevel: Byte;
   TempKeyCounter: Integer;
begin
   with DeletePage do
      begin
      { Delete the key entry }
      TempKeyCounter:=GetIndexKeyCounter;
      { Recalculate the compression information }
      CalculateCompressedSize(TempKeyCounter,False);
      DeleteKey(TempKeyCounter);
      SetIndexKeyCounter(TempKeyCounter);
      { Update the upper index key entries, but only if the number of key
        entries > 0 (which can happen on an external node) }
      if (NumberOfKeys > 0) then
         UpdateUpperIndexKeys(DeletePage,GetKey(TempKeyCounter));
      if (PageType < EXTERNAL_NODE) then
         begin
         if (NumberofKeys < (MaximumKeys div 2)) then
            begin
            { Deleting the current index will cause an underflow, so begin exception
              processing for underflow condition }
            if (GetParentNumber=0) then
               begin
               if (PageType=BOTH_NODE) then
                  begin
                  if (NumberofKeys=0) then
                     begin
                     LeftNumber:=0;
                     RightNumber:=0;
                     SetNextFreePage(DeletePage);
                     SetRootPageNumber(0);
                     end;
                  end
               else
                  begin
                  if (NumberofKeys=1) then
                     begin
                     GetPage(GetRecordNumber(TempKeyCounter),ChildPage);
                     try
                        if (ChildPage.PageType < EXTERNAL_NODE) then
                           ChildPage.PageType:=ROOT_NODE
                        else
                           ChildPage.PageType:=BOTH_NODE;
                        ChildPage.LeftNumber:=0;
                        ChildPage.RightNumber:=0;
                        SetRootPageNumber(ChildPage.Number);
                        { Now free the current page }
                        LeftNumber:=0;
                        RightNumber:=0;
                        SetNextFreePage(DeletePage);
                     finally
                        PutPage(ChildPage);
                     end;
                     end;
                  end;
               end
            else
               begin
               TempLevel:=FCurIndexLevel;
               try
                  GetPage(GetParentNumber,ParentPage);
                  try
                     DecCurIndexLevel;
                     if (GetIndexKeyCounter=ParentPage.NumberOfKeys) then
                        begin
                        IsLeftPage:=True;
                        IsRightPage:=False;
                        end
                     else if (GetIndexKeyCounter=1) then
                        begin
                        IsLeftPage:=False;
                        IsRightPage:=True;
                        end
                     else
                        begin
                        IsLeftPage:=True;
                        IsRightPage:=True;
                        end;
                     if IsLeftPage then
                        begin
                        if (LeftNumber <> 0) then
                           begin
                           GetPage(LeftNumber,LeftPage);
                           try
                              if ((NumberOfKeys+LeftPage.NumberOfKeys) >= MaximumKeys) then
                                 begin
                                 BalanceLeftPage(DeletePage,LeftPage);
                                 { Update the key count stats in the parent page to
                                   reflect the balance with the left page }
                                 TempKeyCounter:=GetIndexKeyCounter;
                                 ParentPage.UpdateKey(GetKey(1),TempKeyCounter);
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             DeletePage.TotalLowerKeyCount);
                                 Dec(TempKeyCounter);
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             LeftPage.TotalLowerKeyCount);
                                 end
                              else
                                 begin
                                 MergeLeftPage(DeletePage,LeftPage);
                                 SetNextFreePage(DeletePage);
                                 { Update the key count stats in the parent page to
                                   reflect the merge with the left page }
                                 TempKeyCounter:=GetIndexKeyCounter;
                                 Dec(TempKeyCounter);
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             LeftPage.TotalLowerKeyCount);
                                 DeleteIndexKey(ParentPage);
                                 end;
                              Exit;
                           finally
                              PutPage(LeftPage);
                           end;
                           end
                        else
                           DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                                 FTableName);
                        end;
                     if IsRightPage then
                        begin
                        if (RightNumber <> 0) then
                           begin
                           GetPage(RightNumber,RightPage);
                           try
                              if ((NumberOfKeys+RightPage.NumberOfKeys) >= MaximumKeys) then
                                 begin
                                 BalanceRightPage(DeletePage,RightPage);
                                 { Update the key count stats in the parent page to
                                   reflect the balance with the right page }
                                 TempKeyCounter:=GetIndexKeyCounter;
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             DeletePage.TotalLowerKeyCount);
                                 Inc(TempKeyCounter);
                                 ParentPage.UpdateKey(RightPage.GetKey(1),
                                                      TempKeyCounter);
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             RightPage.TotalLowerKeyCount);
                                 end
                              else
                                 begin
                                 MergeRightPage(DeletePage,RightPage);
                                 SetNextFreePage(DeletePage);
                                 { Update the key count stats in the parent page to
                                   reflect the merge with the right page }
                                 TempKeyCounter:=GetIndexKeyCounter;
                                 Inc(TempKeyCounter);
                                 ParentPage.UpdateKey(RightPage.GetKey(1),
                                                      TempKeyCounter);
                                 ParentPage.SetLowerKeyCount(TempKeyCounter,
                                                             RightPage.TotalLowerKeyCount);
                                 DeleteIndexKey(ParentPage);
                                 end;
                              Exit;
                           finally
                              PutPage(RightPage);
                           end;
                           end
                        else
                           DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                                                 FTableName);
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
               finally
                  FCurIndexLevel:=TempLevel;
               end;
               end;
            end;
         end
      else
         begin
         { If we are on an external node then we only need to remove the
           page if it is empty, not exactly balanced but it allows for
           the key compression }
         if (NumberofKeys=0) then
            begin
            if (GetParentNumber=0) then
               begin
               if (PageType=BOTH_NODE) then
                  begin
                  if (NumberofKeys=0) then
                     begin
                     LeftNumber:=0;
                     RightNumber:=0;
                     SetNextFreePage(DeletePage);
                     SetRootPageNumber(0);
                     end;
                  end
               else
                  begin
                  if (NumberofKeys=1) then
                     begin
                     GetPage(GetRecordNumber(TempKeyCounter),ChildPage);
                     try
                        if (ChildPage.PageType < EXTERNAL_NODE) then
                           ChildPage.PageType:=ROOT_NODE
                        else
                           ChildPage.PageType:=BOTH_NODE;
                        ChildPage.LeftNumber:=0;
                        ChildPage.RightNumber:=0;
                        SetRootPageNumber(ChildPage.Number);
                        { Now free the current page }
                        LeftNumber:=0;
                        RightNumber:=0;
                        SetNextFreePage(DeletePage);
                     finally
                        PutPage(ChildPage);
                     end;
                     end;
                  end;
               end
            else
               begin
               TempLevel:=FCurIndexLevel;
               try
                  GetPage(GetParentNumber,ParentPage);
                  try
                     DecCurIndexLevel;
                     if (RightNumber <> 0) then
                        begin
                        GetPage(RightNumber,RightPage);
                        try
                           RightPage.LeftNumber:=LeftNumber;
                        finally
                           PutPage(RightPage);
                        end;
                        end;
                     if (LeftNumber <> 0) then
                        begin
                        GetPage(LeftNumber,LeftPage);
                        try
                           LeftPage.RightNumber:=RightNumber;
                        finally
                           PutPage(LeftPage);
                        end;
                        end;
                     LeftNumber:=0;
                     RightNumber:=0;
                     SetNextFreePage(DeletePage);
                     DeleteIndexKey(ParentPage);
                  finally
                     PutPage(ParentPage);
                  end;
               finally
                  FCurIndexLevel:=TempLevel;
               end;
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.BalanceLeftPage(DeletePage: TPage; LeftPage: TPage);
var
   TempPageBuffer: PChar;
   HalfKeyNumber: Word;
begin
   with DeletePage do
      begin
      { Allocate memory for the temporary page buffer }
      TempPageBuffer:=AllocMem(IndexPageBufferSize*3);
      try
         { Move the left page's keys to the temporary page buffer }
         Move(LeftPage.Buffer^,TempPageBuffer^,
              ((FKeySize+KEY_DATA)*LeftPage.NumberOfKeys));
         { Move the current page's keys to the temporary page buffer }
         Move(Buffer^,(TempPageBuffer+(((FKeySize+KEY_DATA)*LeftPage.NumberOfKeys)))^,
              ((FKeySize+KEY_DATA)*NumberOfKeys));
         { Find the half-way key entry }
         HalfKeyNumber:=((NumberOfKeys+LeftPage.NumberOfKeys)-
                        ((NumberOfKeys+LeftPage.NumberOfKeys) div 2));
         { Move half of the keys from temporary key buffer to the left
           page }
         Move(TempPageBuffer^,LeftPage.Buffer^,((FKeySize+KEY_DATA)*HalfKeyNumber));
         NumberOfKeys:=((NumberOfKeys+LeftPage.NumberOfKeys)-HalfKeyNumber);
         { Move the other half of the keys from temporary key buffer to the
           current page }
         Move((TempPageBuffer+((HalfKeyNumber*(FKeySize+KEY_DATA))))^,
              Buffer^,((FKeySize+KEY_DATA)*NumberOfKeys));
         LeftPage.NumberOfKeys:=HalfKeyNumber;
         IsDirty:=True;
         LeftPage.IsDirty:=True;
      finally
         DeAllocMem(TempPageBuffer);
      end;
      end;
end;

procedure TDataCursor.BalanceRightPage(DeletePage: TPage; RightPage: TPage);
var
   TempPageBuffer: PChar;
   HalfKeyNumber: Word;
begin
   with DeletePage do
      begin
      { Allocate memory for the temporary page buffer }
      TempPageBuffer:=AllocMem(IndexPageBufferSize*3);
      try
         { Move the current page's keys to the temporary page buffer }
         Move(Buffer^,TempPageBuffer^,((FKeySize+KEY_DATA)*NumberOfKeys));
         { Move the right page's keys to the temporary page buffer }
         Move(RightPage.Buffer^,(TempPageBuffer+(((FKeySize+KEY_DATA)*NumberOfKeys)))^,
              ((FKeySize+KEY_DATA)*RightPage.NumberOfKeys));
         { Find the half-way key entry }
         HalfKeyNumber:=((NumberOfKeys+RightPage.NumberOfKeys)-
                        ((NumberOfKeys+RightPage.NumberOfKeys) div 2));
         NumberOfKeys:=((NumberOfKeys+RightPage.NumberOfKeys)-HalfKeyNumber);
         { Move half of the keys from temporary key buffer to the current
           page }
         Move(TempPageBuffer^,Buffer^,((FKeySize+KEY_DATA)*NumberOfKeys));
         { Move the other half of the keys from temporary key buffer to the
           right page }
         Move((TempPageBuffer+((NumberOfKeys*(FKeySize+KEY_DATA))))^,
              RightPage.Buffer^,((FKeySize+KEY_DATA)*HalfKeyNumber));
         RightPage.NumberOfKeys:=HalfKeyNumber;
         IsDirty:=True;
         RightPage.IsDirty:=True;
      finally
         DeAllocMem(TempPageBuffer);
      end;
      end;
end;

procedure TDataCursor.MergeLeftPage(DeletePage: TPage; LeftPage: TPage);
var
   TempPageBuffer: PChar;
   RightPage: TPage;
begin
   with DeletePage do
      begin
      { Allocate memory for the temporary page buffer }
      TempPageBuffer:=AllocMem(IndexPageBufferSize*3);
      try
         { Move the left page's keys to the temporary page buffer }
         Move(LeftPage.Buffer^,TempPageBuffer^,
               ((FKeySize+KEY_DATA)*LeftPage.NumberOfKeys));
         { Move the current page's keys to the temporary page buffer }
         Move(Buffer^,(TempPageBuffer+(((FKeySize+KEY_DATA)*LeftPage.NumberOfKeys)))^,
              ((FKeySize+KEY_DATA)*NumberOfKeys));
         LeftPage.NumberOfKeys:=(NumberOfKeys+LeftPage.NumberOfKeys);
         { Move all of the keys from temporary key buffer to the left
           page }
         Move(TempPageBuffer^,LeftPage.Buffer^,((FKeySize+KEY_DATA)*
              LeftPage.NumberOfKeys));
         NumberOfKeys:=0;
         if (RightNumber <> 0) then
            begin
            GetPage(RightNumber,RightPage);
            try
               RightPage.LeftNumber:=LeftPage.Number;
               LeftPage.RightNumber:=RightPage.Number;
            finally
               PutPage(RightPage);
            end;
            end
         else
            LeftPage.RightNumber:=0;
         LeftNumber:=0;
         RightNumber:=0;
         IsDirty:=True;
         LeftPage.IsDirty:=True;
      finally
         DeAllocMem(TempPageBuffer);
      end;
      end;
end;

procedure TDataCursor.MergeRightPage(DeletePage: TPage; RightPage: TPage);
var
   TempPageBuffer: PChar;
   LeftPage: TPage;
begin
   with DeletePage do
      begin
      { Allocate memory for the temporary page buffer }
      TempPageBuffer:=AllocMem(IndexPageBufferSize*3);
      try
         { Move the current page's keys to the temporary page buffer }
         Move(Buffer^,TempPageBuffer^,((FKeySize+KEY_DATA)*NumberOfKeys));
         { Move the right page's keys to the temporary page buffer }
         Move(RightPage.Buffer^,(TempPageBuffer+(((FKeySize+KEY_DATA)*NumberOfKeys)))^,
              ((FKeySize+KEY_DATA)*RightPage.NumberOfKeys));
         RightPage.NumberOfKeys:=(NumberOfKeys+RightPage.NumberOfKeys);
         { Move all of the keys from temporary key buffer to the right
           page }
         Move(TempPageBuffer^,RightPage.Buffer^,((FKeySize+KEY_DATA)*
              RightPage.NumberOfKeys));
         NumberOfKeys:=0;
         if (LeftNumber <> 0) then
            begin
            GetPage(LeftNumber,LeftPage);
            try
               LeftPage.RightNumber:=RightPage.Number;
               RightPage.LeftNumber:=LeftPage.Number;
            finally
               PutPage(LeftPage);
            end;
            end
         else
            RightPage.LeftNumber:=0;
         LeftNumber:=0;
         RightNumber:=0;
         IsDirty:=True;
         RightPage.IsDirty:=True;
      finally
         DeAllocMem(TempPageBuffer);
      end;
      end;
end;

function TDataCursor.GetKey: PChar;
begin
   Result:=FCurrentPage.GetKey(FCurKeyCounter);
end;

function TDataCursor.GetInTransaction: Boolean;
begin
   Result:=FDataTable.InTransaction;
end;

function TDataCursor.GetRecordNumber: Integer;
begin
   if IsRemote then
      Result:=FSequenceNumber
   else
      begin
      { Version 5 }
      if (RecordCount <> 0) then
         begin
         if (FSequenceNumber > 0) then
            Result:=(FSequenceNumber-FBeginSequenceNumber)+1
         else
            Result:=0;
         end
      else
         Result:=0;
      { Version 5 }
      end;
end;

function TDataCursor.GetPhysicalRecordNumber: Integer;
begin
   if IsRemote then
      Result:=FCurRecordNumber
   else
      begin
      if (RecordCount <> 0) then
         begin
         if IsPhysicalNavigation then
            Result:=FCurRecordNumber
         else
            Result:=FCurrentPage.GetRecordNumber(FCurKeyCounter);
         end
      else
         Result:=0;
      end;
end;

function TDataCursor.GetRecordCount: Integer;
begin
   if IsRemote then
      Result:=FRecordCount
   else
      begin
      if not FFiltersInEffect then
         begin
         if (FBeginSequenceNumber > 0) and (FEndSequenceNumber > 0) then
            Result:=(FEndSequenceNumber-FBeginSequenceNumber)+1
         else
            Result:=0;
         end
      else
         Result:=FFilterRecordCount;
      end;
end;

function TDataCursor.GetTotalRecordCount: Integer;
begin
   Result:=FDataTable.RecordCount;
end;

procedure TDataCursor.SetTotalRecordCount(Value: Integer);
begin
   FDataTable.RecordCount:=Value;
end;

procedure TDataCursor.IncTotalRecordCount;
begin
   FDataTable.IncRecordCount;
end;

procedure TDataCursor.DecTotalRecordCount;
begin
   FDataTable.DecRecordCount;
end;

procedure TDataCursor.AddPrimaryIndex(NewIndexDefinition: pIndexDefinition;
                                      SuppressKeyViolation: Boolean;
                                      SendProgress: Boolean);
var
   I: Byte;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   CurIndexPos: Byte;
   ContinueIndexing: Boolean;
   StopAsking: Boolean;
begin
   CheckTransaction;
   CheckExclusive;
   CheckNotReadOnly;
   ContinueIndexing:=True;
   StopAsking:=False;
   I:=1;
   NewIndexDefinition^.KeySize:=0;
   while (NewIndexDefinition^.KeyFields[I] <> 0) and (I <= MAX_NUM_FLDSINKEY) do
      begin
      Inc(NewIndexDefinition.KeySize,FLDCHG_DATA+
          GetIndexedSize(GetPhysicalFieldDefinition(NewIndexDefinition^.KeyFields[I])));
      Inc(I);
      end;
   if (NewIndexDefinition^.KeySize > MAX_KEYLEN) or
      (NewIndexDefinition^.KeySize > (IndexPageBufferSize div 3)) then
      DataEngine.RaiseError(DBISAM_INVALIDKEY,'','',ProperDataDirectoryName,ProperTableName,'','Primary');
   NewIndexDefinition^.KeyFieldCount:=(I-1);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDPRIMARYINDEX);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(NewIndexDefinition^,SizeOf(TIndexDefinition));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         FDataTable.AddPrimaryIndex(NewIndexDefinition);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      InternalBackupIndex(FDataDirectory);
      FDataTable.AddPrimaryIndex(NewIndexDefinition);
      CurIndexPos:=FIndexPos;
      if (RecordCount > 0) then
         begin
         InternalSetIndexPos(PHYSICAL_INDEX_POS);
         TempRecordNumber:=1;
         TempLastPercentDone:=0;
         while (TempRecordNumber <= PhysicalRecordsUsed) do
            begin
            GetRecord(TempRecordNumber,True,READ_FORWARD,
                      TempRecord);
            try
               if (TempRecord.Status <> RECORD_DELETED) then
                  begin
                  InternalSetIndexPos(0);
                  try
                     try
                        GetKeyValues(TempRecord.Buffer,
                                     @TempKeyBuffer);
                        if CheckForKeyViolation(@TempKeyBuffer) then
                           begin
                           if (not SuppressKeyViolation) then
                              RaiseKeyViolationError
                           else
                              RemoveDuplicateRecord(TempRecord,FIndexPos);
                           end
                        else
                           AddIndexKey(@TempKeyBuffer,TempRecordNumber);
                     except
                        on E: Exception do
                           begin
                           if (E is EDBISAMEngineError) then
                              begin
                              with EDBISAMEngineError(E) do
                                 begin
                                 if not StopAsking then
                                    begin
                                    if (ErrorCode=DBISAM_KEYVIOL) then
                                       begin
                                       DoDataLost(DATALOSS_KEYVIOLATION,ErrorIndexName,
                                                  ContinueIndexing,StopAsking);
                                       if ContinueIndexing then
                                          RemoveDuplicateRecord(TempRecord,FIndexPos);
                                       end
                                    else
                                       DoDataLost(DATALOSS_UNKNOWN,'',
                                          ContinueIndexing,StopAsking);
                                    end
                                 else
                                    begin
                                    if (ErrorCode=DBISAM_KEYVIOL) then
                                       RemoveDuplicateRecord(TempRecord,FIndexPos);
                                    end;
                                 end;
                              end
                           else
                              DoDataLost(DATALOSS_UNKNOWN,'',
                                         ContinueIndexing,StopAsking);
                           if not ContinueIndexing then
                              Break;
                           end;
                     end;
                  finally
                     InternalSetIndexPos(PHYSICAL_INDEX_POS);
                  end;
                  end;
               TempPercentDone:=Trunc(((TempRecordNumber/PhysicalRecordsUsed)*100));
               if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                  begin
                  DoProgress(TempPercentDone);
                  TempLastPercentDone:=TempPercentDone;
                  end;
               Inc(TempRecordNumber);
            finally
               PutRecord(TempRecord);
            end;
            end;
         if (TempLastPercentDone <> 100) then
            DoProgress(100);
         end;
      if ContinueIndexing then
         InternalRestoreIndex(FDataDirectory,True,True)
      else
         begin
         InternalRestoreIndex(FDataDirectory,False,True);
         FreeBuffers(False,True,True);
         end;
      CancelRange;
      InternalSetIndexPos(CurIndexPos);
      CheckForActiveFilters;
      RefreshRangeAndFilters;
      SetToBegin;
      end;
end;

procedure TDataCursor.AddSecondaryIndex(NewIndexDefinition: pIndexDefinition;
                                        SuppressKeyViolation: Boolean;
                                        SendProgress: Boolean);
var
   I: Byte;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   CurIndexPos: Byte;
   ContinueIndexing: Boolean;
   StopAsking: Boolean;
begin
   CheckTransaction;
   CheckExclusive;
   CheckNotReadOnly;
   ContinueIndexing:=True;
   StopAsking:=False;
   I:=1;
   NewIndexDefinition^.KeySize:=0;
   while (NewIndexDefinition^.KeyFields[I] <> 0) and (I <= MAX_NUM_FLDSINKEY) do
      begin
      Inc(NewIndexDefinition^.KeySize,FLDCHG_DATA+
          GetIndexedSize(GetPhysicalFieldDefinition(NewIndexDefinition^.KeyFields[I])));
      Inc(I);
      end;
   if (NewIndexDefinition^.KeySize=0) or
      (NewIndexDefinition^.KeySize > MAX_KEYLEN) or
      (NewIndexDefinition^.KeySize > (IndexPageBufferSize div 3)) then
      DataEngine.RaiseError(DBISAM_INVALIDKEY,'','',ProperDataDirectoryName,ProperTableName,'',NewIndexDefinition^.IndexName);
   if (not NewIndexDefinition^.KeyUnique) then
      Inc(NewIndexDefinition^.KeySize,RECORDID_SIZE);
   NewIndexDefinition^.KeyFieldCount:=(I-1);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDSECONDARYINDEX);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(NewIndexDefinition^,SizeOf(TIndexDefinition));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         FDataTable.AddSecondaryIndex(NewIndexDefinition);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      InternalBackupIndex(FDataDirectory);
      FDataTable.AddSecondaryIndex(NewIndexDefinition);
      CurIndexPos:=FIndexPos;
      if (RecordCount > 0) then
         begin
         InternalSetIndexPos(PHYSICAL_INDEX_POS);
         TempRecordNumber:=1;
         TempLastPercentDone:=0;
         while (TempRecordNumber <= PhysicalRecordsUsed) do
            begin
            GetRecord(TempRecordNumber,True,READ_FORWARD,
                      TempRecord);
            try
               if (TempRecord.Status <> RECORD_DELETED) then
                  begin
                  InternalSetIndexPos(IndexCount);
                  try
                     try
                        GetKeyValues(TempRecord.Buffer,
                                     @TempKeyBuffer);
                        if IsUniqueIndex(IndexCount) then
                           begin
                           if CheckForKeyViolation(@TempKeyBuffer) then
                              begin
                              if (not SuppressKeyViolation) then
                                 RaiseKeyViolationError
                              else
                                 RemoveDuplicateRecord(TempRecord,FIndexPos);
                              end
                           else
                              AddIndexKey(@TempKeyBuffer,TempRecordNumber);
                           end
                        else
                           AddIndexKey(@TempKeyBuffer,TempRecordNumber);
                     except
                        on E: Exception do
                           begin
                           if (E is EDBISAMEngineError) then
                              begin
                              with EDBISAMEngineError(E) do
                                 begin
                                 if not StopAsking then
                                    begin
                                    if (ErrorCode=DBISAM_KEYVIOL) then
                                       begin
                                       DoDataLost(DATALOSS_KEYVIOLATION,ErrorIndexName,
                                                  ContinueIndexing,StopAsking);
                                       if ContinueIndexing then
                                          RemoveDuplicateRecord(TempRecord,FIndexPos);
                                       end
                                    else
                                       DoDataLost(DATALOSS_UNKNOWN,'',
                                          ContinueIndexing,StopAsking);
                                    end
                                 else
                                    begin
                                    if (ErrorCode=DBISAM_KEYVIOL) then
                                       RemoveDuplicateRecord(TempRecord,FIndexPos);
                                    end;
                                 end;
                              end
                           else
                              DoDataLost(DATALOSS_UNKNOWN,'',
                                         ContinueIndexing,StopAsking);
                           if not ContinueIndexing then
                              Break;
                           end;
                     end;
                  finally
                     InternalSetIndexPos(PHYSICAL_INDEX_POS);
                  end;
                  end;
               TempPercentDone:=Trunc(((TempRecordNumber/PhysicalRecordsUsed)*100));
               if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                  begin
                  DoProgress(TempPercentDone);
                  TempLastPercentDone:=TempPercentDone;
                  end;
               Inc(TempRecordNumber);
            finally
               PutRecord(TempRecord);
            end;
            end;
         if (TempLastPercentDone <> 100) then
            DoProgress(100);
         end;
      if ContinueIndexing then
         InternalRestoreIndex(FDataDirectory,True,True)
      else
         begin
         InternalRestoreIndex(FDataDirectory,False,True);
         FreeBuffers(False,True,True);
         end;
      CancelRange;
      InternalSetIndexPos(CurIndexPos);
      CheckForActiveFilters;
      RefreshRangeAndFilters;
      SetToBegin;
      end;
end;

procedure TDataCursor.RebuildMissingIndex;
begin
   WriteLockTable;
   try
      try
         with GetIndexDefinition(0)^ do
            begin
            IndexName:='';
            KeyUnique:=True;
            KeyDescending:=False;
            KeyCaseInsensitive:=False;
            KeyFieldCount:=1;
            FillChar(KeyFields,SizeOf(TKeyFields),#0);
            KeyFields[1]:=RECORDID_FIELD_NUM;
            KeySize:=AUTO_PRIMARYKEY_SIZE;
            FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
            NoKeyStatistics:=False;
            KeyCompressionType:=NO_COMPRESS;
            end;
         AddAutoPrimaryIndex;
         { Remember to add text index also }
         with GetIndexDefinition(TEXT_INDEX_POS)^ do
            begin
            IndexName:=TEXT_INDEX_NAME;
            KeySize:=TEXT_KEY_SIZE;
            KeyDescending:=False;
            KeyCaseInsensitive:=False;
            KeyUnique:=False;
            KeyCompressionType:=BOTH_COMPRESS;
            KeyFieldCount:=0;
            FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
            FillChar(KeyFields,SizeOf(TKeyFields),#0);
            NoKeyStatistics:=True;
            IndexChanged:=False;
            RemoveIndex:=False;
            end;
         FDataTable.IndexFile.FIndexesAreDirty:=True;
      finally
         FlushBuffers(True,False,False,True,False);
      end;
   finally
      WriteUnlockTable;
   end;
end;

procedure TDataCursor.AddAutoPrimaryIndex;
var
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   TotalRecordCount:=0;
   TempRecordNumber:=1;
   InternalSetIndexPos(PHYSICAL_INDEX_POS);
   while (TempRecordNumber <= PhysicalRecordsUsed) do
      begin
      GetRecord(TempRecordNumber,True,READ_FORWARD,
                TempRecord);
      try
         if (TempRecord.Status <> RECORD_DELETED) then
            begin
            InternalSetIndexPos(0);
            try
               IncTotalRecordCount;
               GetKeyValues(TempRecord.Buffer,
                            @TempKeyBuffer);
               AddIndexKey(@TempKeyBuffer,TempRecordNumber);
            finally
               InternalSetIndexPos(PHYSICAL_INDEX_POS);
            end;
            end;
         Inc(TempRecordNumber);
      finally
         PutRecord(TempRecord);
      end;
      end;
end;

procedure TDataCursor.DeleteIndex(const DeleteIndexName: string);

var
   I: Byte;
   IndexFound: Boolean;
   TempIndexPos: Byte;
begin
   CheckExclusive;
   CheckNotReadOnly;
   IndexFound:=False;
   TempIndexPos:=0;
   for I:=0 to IndexCount do
      begin
      if (AnsiCompareText(Trim(GetIndexDefinition(I)^.IndexName),
                          Trim(DeleteIndexName))=0) then
         begin
         IndexFound:=True;
         TempIndexPos:=I;
         Break;
         end;
      end;
   if IndexFound then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_DELETEINDEX);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(DeleteIndexName[1],Length(DeleteIndexName));
            EndPack;
            SendReceive;
            CheckForException;
            CancelRange;
            DeleteIndexByPos(TempIndexPos,True,True);
            InternalSetIndexPos(0);
            UnpackCursorInfo;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         CancelRange;
         DeleteIndexByPos(TempIndexPos,True,True);
         InternalSetIndexPos(0);
         RefreshRangeAndFilters;
         SetToBegin;
         end;
      end
   else
      DataEngine.RaiseError(DBISAM_INVALIDINDEXNAME,'','',ProperDataDirectoryName,ProperTableName,'',DeleteIndexName);
end;

procedure TDataCursor.DeleteIndexByPos(CurIndexPos: Byte;
                                       AddPrimaryIfNeeded: Boolean;
                                       AdjustIndexDefinitions: Boolean);
var
   SaveIndexPos: Byte;
   WasAutoPrimaryIndex: Boolean;
begin
   WasAutoPrimaryIndex:=AutoPrimaryIndex;
   if (not IsRemote) then
      begin
      if (CurIndexPos > 0) or ((CurIndexPos=0) and (not WasAutoPrimaryIndex)) then
         begin
         SaveIndexPos:=FIndexPos;
         InternalSetIndexPos(CurIndexPos);
         try
            if (GetRootPageNumber > 0) then
               DeleteNextIndexPage(GetRootPageNumber);
         finally
            InternalSetIndexPos(SaveIndexPos);
         end;
         end;
      end;
   { Be sure to add an automatic primary index if we
     just deleted the primary index }
   FDataTable.DeleteIndex(CurIndexPos,AdjustIndexDefinitions);
   if (not IsRemote) then
      begin
      if (CurIndexPos=0) and (not WasAutoPrimaryIndex) and AddPrimaryIfNeeded then
         begin
         SaveIndexPos:=FIndexPos;
         InternalSetIndexPos(CurIndexPos);
         try
            AddAutoPrimaryIndex;
         finally
            InternalSetIndexPos(SaveIndexPos);
         end;
         end;
      end;
end;

procedure TDataCursor.DeleteAllIndexes;
var
   I: Byte;
begin
   CheckExclusive;
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETEALLINDEXES);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         CancelRange;
         for I:=IndexCount downto 0 do
            DeleteIndexByPos(I,True,True);
         InternalSetIndexPos(0);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CancelRange;
      for I:=IndexCount downto 0 do
         DeleteIndexByPos(I,True,True);
      InternalSetIndexPos(0);
      RefreshRangeAndFilters;
      SetToBegin;
      end;
end;

procedure TDataCursor.DeleteNextIndexPage(NextPageNum: Integer);
var
   NextPage: TPage;
   TempKeyCounter: Integer;
begin
   GetPage(NextPageNum,NextPage);
   try
      TempKeyCounter:=1;
      if (NextPage.PageType < EXTERNAL_NODE) then
         begin
         while (TempKeyCounter <= NextPage.NumberOfKeys) do
            begin
            DeleteNextIndexPage(NextPage.GetRecordNumber(TempKeyCounter));
            Inc(TempKeyCounter);
            end;
         SetNextFreePage(NextPage);
         end
      else
         SetNextFreePage(NextPage);
   finally
      PutPage(NextPage);
   end;
end;

procedure TDataCursor.GetIndexFreeSpaceStats(IndexPosToCheck: Byte;
                                             var InternalCount: Integer;
                                             var InternalSpace: Integer;
                                             var ExternalCount: Integer;
                                             var ExternalSpace: Integer);
var
   SaveIndexPos: Byte;
begin
   ReadLockTable;
   try
      InternalCount:=0;
      InternalSpace:=0;
      ExternalCount:=0;
      ExternalSpace:=0;
      SaveIndexPos:=FIndexPos;
      try
         InternalSetIndexPos(IndexPosToCheck);
         if (GetRootPageNumber > 0) then
            GetNextIndexPageFreeSpaceStats(GetRootPageNumber,
                                           InternalCount,InternalSpace,
                                           ExternalCount,ExternalSpace);
      finally
         InternalSetIndexPos(SaveIndexPos);
      end;
   finally
      ReadUnlockTable;
   end;
end;

procedure TDataCursor.GetNextIndexPageFreeSpaceStats(NextPageNum: Integer;
                                                     var InternalCount: Integer;
                                                     var InternalSpace: Integer;
                                                     var ExternalCount: Integer;
                                                     var ExternalSpace: Integer);
var
   NextPage: TPage;
   TempKeyCounter: Integer;
   TempSpace: Integer;
begin
   GetPage(NextPageNum,NextPage);
   try
      TempKeyCounter:=1;
      if (NextPage.PageType < EXTERNAL_NODE) then
         begin
         while (TempKeyCounter <= NextPage.NumberOfKeys) do
            begin
            GetNextIndexPageFreeSpaceStats(NextPage.GetRecordNumber(TempKeyCounter),
                                           InternalCount,InternalSpace,
                                           ExternalCount,ExternalSpace);
            Inc(TempKeyCounter);
            end;
         TempSpace:=(IndexPageBufferSize-(NextPage.NumberOfKeys*(FKeySize+(KEY_DATA-BOTH_SIZE))));
         Inc(InternalCount);
         Inc(InternalSpace,TempSpace);
         end
      else
         begin
         if (FKeyCompressionType > NO_COMPRESS) and
            (NextPage.NumberOfKeys > NextPage.MaximumKeys) then
            TempSpace:=(IndexPageBufferSize-NextPage.CompressedSize)
         else
            TempSpace:=(IndexPageBufferSize-(NextPage.NumberOfKeys*(FKeySize+(KEY_DATA-KEYCOUNT_SIZE-BOTH_SIZE))));
         Inc(ExternalCount);
         Inc(ExternalSpace,TempSpace);
         end;
   finally
      PutPage(NextPage);
   end;
end;

procedure TDataCursor.GetIndexSpaceStats(IndexPosToCheck: Byte;
                                         var InternalCount: Integer;
                                         var InternalSpace: Integer;
                                         var ExternalCount: Integer;
                                         var ExternalSpace: Integer;
                                         var KeyCount: Integer);
var
   SaveIndexPos: Byte;
begin
   ReadLockTable;
   try
      InternalCount:=0;
      InternalSpace:=0;
      ExternalCount:=0;
      ExternalSpace:=0;
      KeyCount:=0;
      SaveIndexPos:=FIndexPos;
      try
         InternalSetIndexPos(IndexPosToCheck);
         if (GetRootPageNumber > 0) then
            GetNextIndexPageSpaceStats(GetRootPageNumber,
                                       InternalCount,InternalSpace,
                                       ExternalCount,ExternalSpace,
                                       KeyCount);
      finally
         InternalSetIndexPos(SaveIndexPos);
      end;
   finally
      ReadUnlockTable;
   end;
end;

procedure TDataCursor.GetNextIndexPageSpaceStats(NextPageNum: Integer;
                                                 var InternalCount: Integer;
                                                 var InternalSpace: Integer;
                                                 var ExternalCount: Integer;
                                                 var ExternalSpace: Integer;
                                                 var KeyCount: Integer);
var
   NextPage: TPage;
   TempKeyCounter: Integer;
begin
   GetPage(NextPageNum,NextPage);
   try
      TempKeyCounter:=1;
      if (NextPage.PageType < EXTERNAL_NODE) then
         begin
         while (TempKeyCounter <= NextPage.NumberOfKeys) do
            begin
            GetNextIndexPageSpaceStats(NextPage.GetRecordNumber(TempKeyCounter),
                                       InternalCount,InternalSpace,
                                       ExternalCount,ExternalSpace,KeyCount);
            Inc(TempKeyCounter);
            end;
         Inc(InternalCount);
         Inc(InternalSpace,(NextPage.NumberOfKeys*(NextPage.KeySize+(KEY_DATA-BOTH_SIZE))));
         end
      else
         begin
         Inc(ExternalCount);
         if (NextPage.KeyCompressionType=NO_COMPRESS) then
            Inc(ExternalSpace,(NextPage.NumberOfKeys*(NextPage.KeySize+(KEY_DATA-KEYCOUNT_SIZE-BOTH_SIZE))))
         else
            Inc(ExternalSpace,NextPage.CompressedSize);
         Inc(KeyCount,NextPage.NumberOfKeys);
         end;
   finally
      PutPage(NextPage);
   end;
end;

function TDataCursor.GetAutoPrimaryIndex: Boolean;
begin
   Result:=FDataTable.AutoPrimaryIndex;
end;

function TDataCursor.GetIndexCount: Byte;
begin
   Result:=FDataTable.IndexCount;
end;

procedure TDataCursor.SetIndexCount(Value: Byte);
begin
   FDataTable.IndexCount:=Value;
end;

procedure TDataCursor.InternalSetIndexPos(Value: Byte);
begin
   if (Value <> FIndexPos) then
      begin
      FIndexPos:=Value;
      InternalUpdateKeyInformation;
      if IsPhysicalNavigation then
         FFiltersInEffect:=True;
      end;
end;

procedure TDataCursor.SetIndexPos(Value: Byte);
begin
   if (Value <> FIndexPos) then
      begin
      CheckForChangeDetection;
      try
         CancelRange;
         InternalSetIndexPos(Value);
         CheckForActiveFilters;
         RefreshRangeAndFilters;
         RepositionCurrentRecord;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.SetIndexName(const Value: string);
var
   I: Byte;
   IndexFound: Boolean;
   TempIndexPos: Byte;
begin
   if (AnsiCompareText(Value,FIndexName) <> 0) or IsPhysicalNavigation then
      begin
      IndexFound:=False;
      TempIndexPos:=0;
      for I:=0 to IndexCount do
         begin
         if (AnsiCompareText(Value,GetIndexDefinition(I)^.IndexName)=0) then
            begin
            IndexFound:=True;

            TempIndexPos:=I;
            Break;
            end;
         end;
      if IndexFound then
         begin
         if IsRemote then
            begin
            StartRemoteRequest;
            try
               CheckForConnection;
               SetRequestCode(REQUEST_SETINDEXNAME);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               Pack(FBookmarkBuffer,BookmarkSize);
               Pack(FBOF,SizeOf(Boolean));
               Pack(FEOF,SizeOf(Boolean));
               Pack(Value[1],Length(Value));
               EndPack;
               SendReceive;
               CheckForException;
               CancelRange;
               InternalSetIndexPos(TempIndexPos);
               CheckForActiveFilters;
               UnpackCursorInfo;
            finally
               EndRemoteRequest;
            end;
            end
         else
            begin
            CheckForChangeDetection;
            try
               CancelRange;
               InternalSetIndexPos(TempIndexPos);
               CheckForActiveFilters;
               RefreshRangeAndFilters;
               RepositionCurrentRecord;
            finally
               ReadUnlockTable;
            end;
            end;
         end
      else
         DataEngine.RaiseError(DBISAM_INVALIDINDEXNAME,'','',ProperDataDirectoryName,
                               FTableName,'',Value);
      end;
end;

procedure TDataCursor.InternalUpdateKeyInformation;
var
   I: Byte;
begin
   if (FIndexPos <> PHYSICAL_INDEX_POS) then
      begin
      with GetIndexDefinition(FIndexPos)^ do
         begin
         FIndexName:=IndexName;
         FKeySize:=KeySize;
         FKeyFieldCount:=KeyFieldCount;
         FKeyFields:=KeyFields;
         FKeyDescending:=KeyDescending;
         FKeyDescendingFields:=KeyDescendingFields;
         FKeyCaseInsensitive:=KeyCaseInsensitive;
         FKeyUnique:=KeyUnique;
         FKeyCompressionType:=KeyCompressionType;
         FNoKeyStatistics:=NoKeyStatistics;
         FillChar(FKeyFieldDefinitions,SizeOf(FKeyFieldDefinitions),#0);
         for I:=1 to FKeyFieldCount do
            FKeyFieldDefinitions[I]:=GetPhysicalFieldDefinition(FKeyFields[I]);
         end;
      end
   else
      begin
      FIndexName:='';
      FKeySize:=0;
      FKeyFieldCount:=0;
      FillChar(FKeyFields,SizeOf(FKeyFields),#0);
      FKeyDescending:=False;
      FillChar(FKeyDescendingFields,SizeOf(FKeyDescendingFields),#0);
      FKeyCaseInsensitive:=False;
      FKeyUnique:=False;
      FKeyCompressionType:=NO_COMPRESS;
      FNoKeyStatistics:=False;
      FillChar(FKeyFieldDefinitions,SizeOf(FKeyFieldDefinitions),#0);
      end;
end;

function TDataCursor.GetBookmarkSize: Word;
begin
   if IsPhysicalNavigation then
      Result:=SizeOf(Integer)
   else
      Result:=FKeySize;
end;

procedure TDataCursor.GetKeyValues(RecordBuffer: PChar;
                                   KeyBuffer: PChar);
var
   I: Byte;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
   BufferOffset: Word;
begin
   BufferOffset:=0;
   FillChar(KeyBuffer^,FKeySize,#0);
   for I:=1 to FKeyFieldCount do
      begin
      GetPhysicalField(FKeyFields[I],RecordBuffer,
                       @TempFieldBuffer,IsBlank);
      Boolean((KeyBuffer+BufferOffset)^):=(not IsBlank);
      PrepareDataForIndex(FKeyFieldDefinitions[I],@TempFieldBuffer,
                          (KeyBuffer+BufferOffset),
                          FKeyCaseInsensitive,
                          FLocaleID);
      Inc(BufferOffset,FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
      end;
   { If we're on a secondary index and the secondary index is not
     unique, then add the record ID values from the RecordIDBuffer
     to the end of the key to ensure uniqueness }
   if (not FKeyUnique) then
      begin
      pInteger(@TempFieldBuffer)^:=pRecordHeader(RecordBuffer)^.ID;
      FlipIntegerBits(pInteger(@TempFieldBuffer)^,(KeyBuffer+BufferOffset));
      end;
end;

{ Version 5 }
procedure TDataCursor.RepositionCurrentRecord;
begin
   { Handle special case of physical record reads }
   if IsPhysicalNavigation then
      begin
      FSequenceNumber:=0;
      VerifyPhysicalRecordPosition;
      end
   else
      VerifyRecordPosition;
   RefreshCurrentRecord(READ_CURRENT);
   VerifyCurrentRecord(READ_CURRENT);
end;
{ Version 5 }

procedure TDataCursor.RefreshRangeAndFilters;
begin
   UpdateRange;
   if FFiltersInEffect then
      begin
      UpdateAllFilters;
      RebuildFilterBitmap;
      RebuildFilterKeys;
      end;
end;

procedure TDataCursor.RefreshRangeAndFilterUpdate(RecordUpdated: Integer;
                                                  RecordBuffer: PChar;
                                                  OldRecordBuffer: PChar);
begin
   UpdateRange;
   if FFiltersInEffect then
      begin
      UpdateRecordInBitmap(RecordUpdated,RecordBuffer);
      RebuildFilterBitmap;
      UpdateRecordFilterKey(RecordUpdated,RecordBuffer,OldRecordBuffer);
      end;
end;

procedure TDataCursor.RefreshRangeAndFilterDelete(RecordDeleted: Integer;
                                                  RecordBuffer: PChar);
begin
   UpdateRange;
   if FFiltersInEffect then
      begin
      DeleteRecordInBitmap(RecordDeleted);
      RebuildFilterBitmap;
      DeleteRecordFilterKey(RecordBuffer);
      end;
end;

{ Version 5 }
procedure TDataCursor.VerifyCurrentRecord(Direction: Byte);
begin
   if (Direction in [READ_CURRENT,READ_FORWARD]) then
      begin
      while (not FEOF) do
         begin
         if (not VerifyRecordInSet(FCurrentRecord.Number,
                                   FCurrentRecord.Buffer)) then
            begin
            RebuildFilterBitmap;
            DeleteRecordFilterKey(FCurrentRecord.Buffer);
            SkipIndexKeys(1);
            RefreshCurrentRecord(Direction);
            end
         else
            Exit;
         end;
      while (not FBOF) do
         begin
         if (not VerifyRecordInSet(FCurrentRecord.Number,
                                   FCurrentRecord.Buffer)) then
            begin
            RebuildFilterBitmap;
            DeleteRecordFilterKey(FCurrentRecord.Buffer);
            SkipIndexKeys(-1);
            RefreshCurrentRecord(READ_BACKWARD);
            end
         else
            begin
            FEOF:=True;
            Exit;
            end;
         end;
      FBOF:=True;
      FEOF:=True;
      end
   else
      begin
      while (not FBOF) do
         begin
         if (not VerifyRecordInSet(FCurrentRecord.Number,
                                   FCurrentRecord.Buffer)) then
            begin
            RebuildFilterBitmap;
            DeleteRecordFilterKey(FCurrentRecord.Buffer);
            SkipIndexKeys(-1);
            RefreshCurrentRecord(Direction);
            end
         else
            Exit;
         end;
      while (not FEOF) do
         begin
         if (not VerifyRecordInSet(FCurrentRecord.Number,
                                   FCurrentRecord.Buffer)) then
            begin
            RebuildFilterBitmap;
            DeleteRecordFilterKey(FCurrentRecord.Buffer);
            SkipIndexKeys(1);
            RefreshCurrentRecord(READ_FORWARD);
            end
         else
            begin
            FBOF:=True;
            Exit;
            end;
         end;
      FBOF:=True;
      FEOF:=True;
      end;
end;
{ Version 5 }

procedure TDataCursor.CheckError(ErrorCode: Word; const ErrorMsg: string);
begin
   if (ErrorCode <> DBISAM_NONE) then
      DataEngine.RaiseError(ErrorCode,'','',ProperDataDirectoryName,
                             FTableName,'','',ErrorMsg);
end;

procedure TDataCursor.SetToBegin;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SETTOBEGIN);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GotoFirstIndexPosition;
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
         SkipIndexKeys(-1);
         RefreshCurrentRecord(READ_BACKWARD);
         VerifyCurrentRecord(READ_BACKWARD);
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.SetToEnd;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SETTOEND);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GotoLastIndexPosition;
         RefreshCurrentRecord(READ_BACKWARD);
         VerifyCurrentRecord(READ_BACKWARD);
         SkipIndexKeys(1);
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.SetToRecordNumber(Value: Integer): Boolean;
begin
   Result:=True;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SETTORECNO);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(Value,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GotoRecordNumber(Value);
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
         Result:=(RecordNumber=Value);
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.ResetIndexPosition;
begin
   FSequenceNumber:=0;
   { Version 5 }
   FBeginSequenceNumber:=0;
   FEndSequenceNumber:=0;
   FFilterRecordCount:=0;
   { Version 5 }
   FBOF:=True;
   FEOF:=True;
   FCurrentPage.Initialize(FIndexPos);
   FCurRecordNumber:=0;
   FFilterKeyPos:=0;
end;

function TDataCursor.CheckWithinRangeBounds(var CurPage: TPage;
                                            var CurSequenceNumber: Integer;
                                            var CurKeyCounter: Integer;
                                            var FoundChanges: Boolean): Boolean;
var
   RightPage: TPage;
   LeftPage: TPage;
   CompareResult: Integer;
begin
   Result:=True;
   FoundChanges:=False;
   if (CompareKeys(CurPage.GetKey(CurKeyCounter),@FBeginBuffer,FKeySize)=CMP_LESS) then
      begin
      if (CurPage.RightNumber <> 0) then
         begin
         FoundChanges:=(not GetPage(CurPage.RightNumber,RightPage));
         if FoundChanges then
            begin
            CurPage:=nil;
            Result:=False;
            end
         else
            begin
            CompareResult:=CompareKeys(RightPage.GetKey(1),@FBeginBuffer,
                                       FKeySize);
            if (CompareResult=CMP_GREATER) or
               (CompareResult=CMP_EQUAL) then
               begin
               Inc(CurSequenceNumber,CurPage.GetLowerKeyCount(CurKeyCounter));
               PutPage(CurPage);
               CurPage:=RightPage;
               CurKeyCounter:=1;
               if (CompareKeys(CurPage.GetKey(CurKeyCounter),@FEndBuffer,
                                FKeySize)=CMP_GREATER) then
                  begin
                  Result:=False;
                  PutPage(RightPage);
                  end;
               end
            else
               begin
               Result:=False;
               PutPage(RightPage);
               end;
            end;
         end
      else
         Result:=False;
      end
   else if (CompareKeys(CurPage.GetKey(CurKeyCounter),@FEndBuffer,
                        FKeySize)=CMP_GREATER) then
      begin
      if (CurPage.LeftNumber <> 0) then
         begin
         FoundChanges:=(not GetPage(CurPage.LeftNumber,LeftPage));
         if FoundChanges then
            begin
            CurPage:=nil;
            Result:=False
            end
         else
            begin
            CompareResult:=CompareKeys(LeftPage.GetKey(LeftPage.NumberOfKeys),
                                       @FEndBuffer,FKeySize);
            if (CompareResult=CMP_LESS) or
               (CompareResult=CMP_EQUAL) then
               begin
               Inc(CurSequenceNumber,CurPage.GetLowerKeyCount(CurKeyCounter));
               PutPage(CurPage);
               CurPage:=LeftPage;
               CurKeyCounter:=LeftPage.NumberOfKeys;
               if (CompareKeys(CurPage.GetKey(CurKeyCounter),@FBeginBuffer,
                                FKeySize)=CMP_LESS) then
                  begin
                  Result:=False;
                  PutPage(LeftPage);
                  end;
               end
            else
               begin
               Result:=False;
               PutPage(LeftPage);
               end;
            end;
         end
      else
         Result:=False;
      end;
end;

procedure TDataCursor.GotoFirstIndexPosition;
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   PageFound: Boolean;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
   TempFilterKeyPos: Integer;
begin
   if IsPhysicalNavigation then
      begin
      if (RecordCount <> 0) then
         begin
         FBOF:=False;
         FEOF:=False;
         FSequenceNumber:=0;
         FCurRecordNumber:=0;
         FFilterBitmap.GetNextBitsSet(FCurRecordNumber,1);
         end
      else
         ResetIndexPosition;
      end
   else if FFiltersInEffect and (FFilterKeys.Count > 0) and
            (FFilterKeyIndexPos=FIndexPos) then
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            TempFilterKeyPos:=0;
            PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
            { Version 5 }
            if (not RetryPages) then
            { Version 5 }
               begin
               if PageFound then
                  begin
                  FBOF:=False;
                  FEOF:=False;
                  FFilterKeyPos:=TempFilterKeyPos;
                  end
               else
                  ResetIndexPosition;
               Exit;
               end
            else
               { Version 5 }
               RebuildFilterKeys;
               { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end
   else
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempBOF:=False;
                     TempEOF:=False;
                     TempSequenceNumber:=1;
                     TempKeyCounter:=1;
                     if FRangeInEffect then
                        begin
                        while True do
                           begin
                           FirstRangeScan(ParentPage,TempSequenceNumber,
                                          TempKeyCounter,@FBeginBuffer);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           PageFound:=CheckWithinRangeBounds(ParentPage,TempSequenceNumber,
                                                             TempKeyCounter,RetryPages);
                           if (not RetryPages) then
                              begin
                              if PageFound then
                                 begin
                                 if FFiltersInEffect then
                                    begin
                                    if (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                       begin
                                       if (not FilterRangeScanForward(ParentPage,TempSequenceNumber,
                                                                      TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    end;
                                 if (not RetryPages) then
                                    begin
                                    FCurrentPage.Copy(ParentPage);
                                    FCurKeyCounter:=TempKeyCounter;
                                    FSequenceNumber:=TempSequenceNumber;
                                    FBOF:=TempBOF;
                                    FEOF:=TempEOF;
                                    end;
                                 end
                              else
                                 { Version 5 }
                                 begin
                                 ResetIndexPosition;
                                 Exit;
                                 end;
                                 { Version 5 }
                              end;
                           end;
                        end
                     else if FFiltersInEffect then
                        begin
                        while True do
                           begin
                           FirstScan(ParentPage,TempSequenceNumber,TempKeyCounter);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           if (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                              begin
                              if (not FilterScanForward(ParentPage,TempSequenceNumber,
                                                        TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    ResetIndexPosition;
                                    Exit;
                                    end;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(ParentPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end;
                        end
                     else
                        begin
                        while True do
                           begin
                           FirstScan(ParentPage,TempSequenceNumber,TempKeyCounter);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(ParentPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  begin
                  ResetIndexPosition;
                  Exit;
                  end;
               end;
            { Version 5 }
            { Removed ForceRefresh on RetryPages }
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end;
end;

procedure TDataCursor.GotoLastIndexPosition;
var
   ParentPage: TPage;
   ChildPage: TPage;
   RetryPages: Boolean;
   PageFound: Boolean;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
   TempFilterKeyPos: Integer;
begin
   if IsPhysicalNavigation then
      begin
      if (RecordCount <> 0) then
         begin
         FBOF:=False;
         FEOF:=False;
         FSequenceNumber:=0;
         FCurRecordNumber:=PhysicalRecordsUsed+1;
         FFilterBitmap.GetPreviousBitsSet(FCurRecordNumber,1);
         end
      else
         ResetIndexPosition;
      end
   else if FFiltersInEffect and (FFilterKeys.Count > 0) and
            (FFilterKeyIndexPos=FIndexPos) then
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            TempFilterKeyPos:=(FFilterKeys.Count-1);
            PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
            { Version 5 }
            if (not RetryPages) then
            { Version 5 }
               begin
               if PageFound then
                  begin
                  FBOF:=False;
                  FEOF:=False;
                  FFilterKeyPos:=TempFilterKeyPos;
                  end
               else
                  ResetIndexPosition;
               Exit;
               end
            else
               { Version 5 }
               RebuildFilterKeys;
               { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end
   else
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            PageFound:=GetRootPage(ParentPage,RetryPages);
            if (not RetryPages) then
               begin
               if PageFound then
                  begin
                  try
                     TempBOF:=False;
                     TempEOF:=False;
                     TempSequenceNumber:=1;
                     TempKeyCounter:=1;
                     if FRangeInEffect then
                        begin
                        while True do
                           begin
                           LastRangeScan(ParentPage,TempSequenceNumber,
                                         TempKeyCounter,@FEndBuffer);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           PageFound:=CheckWithinRangeBounds(ParentPage,TempSequenceNumber,
                                                             TempKeyCounter,RetryPages);
                           if (not RetryPages) then
                              begin
                              if PageFound then
                                 begin
                                 if FFiltersInEffect then
                                    begin
                                    if (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                                       begin
                                       if (not FilterRangeScanBackward(ParentPage,TempSequenceNumber,
                                                                       TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    end;
                                 if (not RetryPages) then
                                    begin
                                    FCurrentPage.Copy(ParentPage);
                                    FCurKeyCounter:=TempKeyCounter;
                                    FSequenceNumber:=TempSequenceNumber;
                                    FBOF:=TempBOF;
                                    FEOF:=TempEOF;
                                    end;
                                 end
                              else
                                 { Version 5 }
                                 begin
                                 ResetIndexPosition;
                                 Exit;
                                 end;
                                 { Version 5 }
                              end;
                           end;
                        end
                     else if FFiltersInEffect then
                        begin
                        while True do
                           begin
                           LastScan(ParentPage,TempSequenceNumber,TempKeyCounter);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           if (not FFilterBitmap.IsBitSet(ParentPage.GetRecordNumber(TempKeyCounter))) then
                              begin
                              if (not FilterScanBackward(ParentPage,TempSequenceNumber,
                                                         TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    ResetIndexPosition;
                                    Exit;
                                    end;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(ParentPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end;
                        end
                     else
                        begin
                        while True do
                           begin
                           LastScan(ParentPage,TempSequenceNumber,TempKeyCounter);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryPages:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                       ChildPage));
                              if RetryPages then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(ParentPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  begin
                  ResetIndexPosition;
                  Exit;
                  end;
               end;
            { Version 5 }
            { Removed ForceRefresh on RetryPages }
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end;
end;

function TDataCursor.GotoRightPage(var CurPage: TPage; var FoundChanges: Boolean;
                                   var KeyCounter: Integer): Boolean;
var
   RightPage: TPage;
begin
   Result:=False;
   if (CurPage.RightNumber <> 0) then
      begin
      FoundChanges:=(not GetPage(CurPage.RightNumber,RightPage));
      if (not FoundChanges) then
         begin
         PutPage(CurPage);
         { Version 5 }
         if (RightPage.NumberOfKeys=0) then
            begin
            PutPage(RightPage);
            FoundChanges:=True;
            end
         { Version 5 }
         else
            begin
            CurPage:=RightPage;
            KeyCounter:=1;
            Result:=True;
            end;
         end
      else
         CurPage:=nil;
      end
   else
      FoundChanges:=False;
end;

function TDataCursor.GotoLeftPage(var CurPage: TPage; var FoundChanges: Boolean;
                                  var KeyCounter: Integer): Boolean;
var
   LeftPage: TPage;
begin
   Result:=False;
   if (CurPage.LeftNumber <> 0) then
      begin
      FoundChanges:=(not GetPage(CurPage.LeftNumber,LeftPage));
      if (not FoundChanges) then
         begin
         PutPage(CurPage);
         { Version 5 }
         if (LeftPage.NumberOfKeys=0) then
            begin
            PutPage(LeftPage);
            FoundChanges:=True;
            end
         { Version 5 }
         else
            begin
            CurPage:=LeftPage;
            KeyCounter:=CurPage.NumberOfKeys;
            Result:=True;
            end;
         end
      else
         CurPage:=nil;
      end
   else
      FoundChanges:=False;
end;

{ Version 5 }
procedure TDataCursor.VerifyPhysicalRecordPosition;
var
   TempRecordNumber: Integer;
begin
   if (RecordCount <> 0) then
      begin
      TempRecordNumber:=FCurRecordNumber;
      if (TempRecordNumber > 0) then
         Dec(TempRecordNumber);
      if (not FFilterBitmap.GetNextBitsSet(TempRecordNumber,1)) then
         begin
         TempRecordNumber:=FCurRecordNumber;
         Inc(TempRecordNumber);
         if not FFilterBitmap.GetPreviousBitsSet(TempRecordNumber,1) then
            ResetIndexPosition
         else
            FCurRecordNumber:=TempRecordNumber;
         end
      else
         FCurRecordNumber:=TempRecordNumber;
      end
   else
      ResetIndexPosition;
end;

procedure TDataCursor.VerifyRecordPosition;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   if (RecordCount <> 0) then
      begin
      GetKeyValues(FCurrentRecord.Buffer,
                   @TempKeyBuffer);
      FindIndexKey(@TempKeyBuffer,True,True);
      end
   else
      ResetIndexPosition;
end;
{ Version 5 }

procedure TDataCursor.SkipIndexKeys(Value: Integer);
var
   RemainingKeys: Integer;
   RetryPages: Boolean;
   PageFound: Boolean;
   CurPage: TPage;
   TempSequenceNumber: Integer;
   TempKeyCounter: Integer;
   TempBOF: Boolean;
   TempEOF: Boolean;
   TempFilterKeyPos: Integer;
begin
   if (Value=0) then Exit;
   if IsPhysicalNavigation then
      begin
      if Value=0 then Exit;
      if (RecordCount <> 0) then
         begin
         if (Value > 0) then
            begin
            RemainingKeys:=Value;
            if (not FFilterBitmap.GetNextBitsSet(FCurRecordNumber,RemainingKeys)) then
               begin
               FBOF:=False;
               FEOF:=True;
               end;
            end
         else
            begin
            RemainingKeys:=Abs(Value);
            if (not FFilterBitmap.GetPreviousBitsSet(FCurRecordNumber,RemainingKeys)) then
               begin
               FBOF:=True;
               FEOF:=False;
               end;
            end;
         end
      else
         ResetIndexPosition;
      end
   else if FFiltersInEffect and (FFilterKeys.Count > 0) and
            (FFilterKeyIndexPos=FIndexPos) then
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            TempFilterKeyPos:=FFilterKeyPos;
            if (Value > 0) then
               begin
               RemainingKeys:=Value;
               if ((TempFilterKeyPos+RemainingKeys) > (FFilterKeys.Count-1)) then
                  begin
                  TempFilterKeyPos:=(FFilterKeys.Count-1);
                  PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
                  if (not RetryPages) then
                     begin
                     if PageFound then
                        begin
                        FBOF:=False;
                        FEOF:=True;
                        FFilterKeyPos:=TempFilterKeyPos;
                        end
                     else
                        ResetIndexPosition;
                     Exit;
                     end;
                  end
               else
                  begin
                  Inc(TempFilterKeyPos,RemainingKeys);
                  PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
                  if (not RetryPages) then
                     begin
                     if PageFound then
                        begin
                        FBOF:=False;
                        FEOF:=False;
                        FFilterKeyPos:=TempFilterKeyPos;
                        end
                     else
                        ResetIndexPosition;
                     Exit;
                     end;
                  end;
               end
            else
               begin
               RemainingKeys:=Abs(Value);
               if ((TempFilterKeyPos-RemainingKeys) < 0) then
                  begin
                  TempFilterKeyPos:=0;
                  PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
                  if (not RetryPages) then
                     begin
                     if PageFound then
                        begin
                        FBOF:=True;
                        FEOF:=False;
                        FFilterKeyPos:=TempFilterKeyPos;
                        end
                     else
                        ResetIndexPosition;
                     Exit;
                     end;
                  end
               else
                  begin
                  Dec(TempFilterKeyPos,RemainingKeys);
                  PageFound:=FindFilterKey(@pFilterKeyBuffer(FFilterKeys[TempFilterKeyPos])^.KeyBuffer,RetryPages);
                  if (not RetryPages) then
                     begin
                     if PageFound then
                        begin
                        FBOF:=False;
                        FEOF:=False;
                        FFilterKeyPos:=TempFilterKeyPos;
                        end
                     else
                        ResetIndexPosition;
                     Exit;
                     end;
                  end;
               end;
            { Version 5 }
            if RetryPages then
               RebuildFilterKeys;
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end
   else
      begin
      RetryPages:=True;
      while RetryPages do
         begin
         RetryPages:=False;
         if (RecordCount <> 0) then
            begin
            RetryPages:=(not GetPage(FCurrentPage.Number,CurPage));
            { Version 5 }
            if (CurPage.NumberOfKeys=0) then
               begin
               PutPage(CurPage);
               RetryPages:=True;
               end;
            { Version 5 }
            if (not RetryPages) then
               begin
               try
                  TempBOF:=FBOF;
                  TempEOF:=FEOF;
                  TempSequenceNumber:=FSequenceNumber;
                  TempKeyCounter:=FCurKeyCounter;
                  if (TempKeyCounter > CurPage.NumberOfKeys) then
                     TempKeyCounter:=CurPage.NumberOfKeys;
                  if FRangeInEffect then
                     begin
                     if FFiltersInEffect then
                        begin
                        if (Value > 0) then
                           begin
                           RemainingKeys:=Value;
                           while (RemainingKeys > 0) do
                              begin
                              if (not FilterRangeScanForward(CurPage,TempSequenceNumber,
                                                             TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    if PageFound or
                                       (not FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(TempKeyCounter))) then
                                       begin
                                       if (not FilterRangeScanBackward(CurPage,TempSequenceNumber,
                                                                       TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    TempBOF:=False;
                                    TempEOF:=True;
                                    end;
                                 Break;
                                 end
                              else
                                 begin
                                 Dec(RemainingKeys);
                                 TempBOF:=False;
                                 TempEOF:=False;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(CurPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end
                        else
                           begin
                           RemainingKeys:=Abs(Value);
                           while (RemainingKeys > 0) do
                              begin
                              if (not FilterRangeScanBackward(CurPage,TempSequenceNumber,
                                                              TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    if PageFound or
                                       (not FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(TempKeyCounter))) then
                                       begin
                                       if (not FilterRangeScanForward(CurPage,TempSequenceNumber,
                                                                      TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    TempBOF:=True;
                                    TempEOF:=False;
                                    end;
                                 Break;
                                 end
                              else
                                 begin
                                 Dec(RemainingKeys);
                                 TempBOF:=False;
                                 TempEOF:=False;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(CurPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end;
                        end
                     else
                        begin
                        if (Value > 0) then
                           begin
                           RemainingKeys:=Value;
                           while (RemainingKeys > 0) do
                              begin
                              if (not RangeScanForward(CurPage,TempSequenceNumber,
                                                       TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    if PageFound then
                                       begin
                                       if (not RangeScanBackward(CurPage,TempSequenceNumber,
                                                                 TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    TempBOF:=False;
                                    TempEOF:=True;
                                    end;
                                 Break;
                                 end
                              else
                                 begin
                                 Dec(RemainingKeys);
                                 TempBOF:=False;
                                 TempEOF:=False;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(CurPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end
                        else
                           begin
                           RemainingKeys:=Abs(Value);
                           while (RemainingKeys > 0) do
                              begin
                              if (not RangeScanBackward(CurPage,TempSequenceNumber,
                                                         TempKeyCounter,RetryPages,PageFound)) then
                                 begin
                                 if (not RetryPages) then
                                    begin
                                    if PageFound then
                                       begin
                                       if (not RangeScanForward(CurPage,TempSequenceNumber,
                                                                TempKeyCounter,RetryPages,PageFound)) then
                                          begin
                                          if (not RetryPages) then
                                             begin
                                             ResetIndexPosition;
                                             Exit;
                                             end;
                                          end;
                                       end;
                                    TempBOF:=True;
                                    TempEOF:=False;
                                    end;
                                 Break;
                                 end
                              else
                                 begin
                                 Dec(RemainingKeys);
                                 TempBOF:=False;
                                 TempEOF:=False;
                                 end;
                              end;
                           if (not RetryPages) then
                              begin
                              FCurrentPage.Copy(CurPage);
                              FCurKeyCounter:=TempKeyCounter;
                              FSequenceNumber:=TempSequenceNumber;
                              FBOF:=TempBOF;
                              FEOF:=TempEOF;
                              end;
                           end;
                        end;
                     end
                  else if FFiltersInEffect then
                     begin
                     if (Value > 0) then
                        begin
                        RemainingKeys:=Value;
                        while (RemainingKeys > 0) do
                           begin
                           if (not FilterScanForward(CurPage,TempSequenceNumber,
                                                     TempKeyCounter,RetryPages,PageFound)) then
                              begin
                              if (not RetryPages) then
                                 begin
                                 if PageFound or
                                    (not FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(TempKeyCounter))) then
                                    begin
                                    if (not FilterScanBackward(CurPage,TempSequenceNumber,
                                                               TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          ResetIndexPosition;
                                          Exit;
                                          end;
                                       end;
                                    end;
                                 TempBOF:=False;
                                 TempEOF:=True;
                                 end;
                              Break;
                              end
                           else
                              begin
                              Dec(RemainingKeys);
                              TempBOF:=False;
                              TempEOF:=False;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(CurPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end
                     else
                        begin
                        RemainingKeys:=Abs(Value);
                        while (RemainingKeys > 0) do
                           begin
                           if (not FilterScanBackward(CurPage,TempSequenceNumber,
                                                        TempKeyCounter,RetryPages,PageFound)) then
                              begin
                              if (not RetryPages) then
                                 begin
                                 if PageFound or
                                    (not FFilterBitmap.IsBitSet(CurPage.GetRecordNumber(TempKeyCounter))) then
                                    begin
                                    if (not FilterScanForward(CurPage,TempSequenceNumber,
                                                              TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          ResetIndexPosition;
                                          Exit;
                                          end;
                                       end;
                                    end;
                                 TempBOF:=True;
                                 TempEOF:=False;
                                 end;
                              Break;
                              end
                           else
                              begin
                              Dec(RemainingKeys);
                              TempBOF:=False;
                              TempEOF:=False;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(CurPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end;
                     end
                  else
                     begin
                     if (Value > 0) then
                        begin
                        RemainingKeys:=Value;
                        while (RemainingKeys > 0) do
                           begin
                           if (not ScanForward(CurPage,TempSequenceNumber,
                                                 TempKeyCounter,RetryPages,PageFound)) then
                              begin
                              if (not RetryPages) then
                                 begin
                                 if PageFound then
                                    begin
                                    if (not ScanBackward(CurPage,TempSequenceNumber,
                                                         TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          ResetIndexPosition;
                                          Exit;
                                          end;
                                       end;
                                    end;
                                 TempBOF:=False;
                                 TempEOF:=True;
                                 end;
                              Break;
                              end
                           else
                              begin
                              Dec(RemainingKeys);
                              TempBOF:=False;
                              TempEOF:=False;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(CurPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end
                     else
                        begin
                        RemainingKeys:=Abs(Value);
                        while (RemainingKeys > 0) do
                           begin
                           if (not ScanBackward(CurPage,TempSequenceNumber,
                                                TempKeyCounter,RetryPages,PageFound)) then
                              begin
                              if (not RetryPages) then
                                 begin
                                 if PageFound then
                                    begin
                                    if (not ScanForward(CurPage,TempSequenceNumber,
                                                        TempKeyCounter,RetryPages,PageFound)) then
                                       begin
                                       if (not RetryPages) then
                                          begin
                                          ResetIndexPosition;
                                          Exit;
                                          end;
                                       end;
                                    end;
                                 TempBOF:=True;
                                 TempEOF:=False;
                                 end;
                              Break;
                              end
                           else
                              begin
                              Dec(RemainingKeys);
                              TempBOF:=False;
                              TempEOF:=False;
                              end;
                           end;
                        if (not RetryPages) then
                           begin
                           FCurrentPage.Copy(CurPage);
                           FCurKeyCounter:=TempKeyCounter;
                           FSequenceNumber:=TempSequenceNumber;
                           FBOF:=TempBOF;
                           FEOF:=TempEOF;
                           end;
                        end;
                     end;
               finally
                  PutPage(CurPage);
               end;
               end;
            { Version 5 }
            if RetryPages then
               VerifyRecordPosition;
            { Version 5 }
            end
         else
            begin
            ResetIndexPosition;
            Exit;
            end;
         end;
      end;
end;

function TDataCursor.GetNumReadAheadRecords(MaxNumReadAheadRecords: Integer;
                                            Direction: Byte): Integer;
begin
   if IsPhysicalNavigation then
      Result:=CountSequentialPhysicalRecords(MaxNumReadAheadRecords,
                                        Direction)
   else
      Result:=CountSequentialRecords(FCurrentPage,MaxNumReadAheadRecords,
                                     Direction,FCurKeyCounter);
   Inc(FTotalReadAheads);
   Inc(FTotalSizeReadAheads,Result);
end;

function TDataCursor.CountSequentialPhysicalRecords(MaxNumRecords: Integer;
                                                    Direction: Byte): Integer;
var
   TempRecordNumber: Integer;
   { Version 5 }
   TempSpreadStart: Integer;
   { Version 5 }
begin
   Result:=0;
   TempRecordNumber:=FCurRecordNumber;
   if (Direction=READ_FORWARD) then
      begin
      Inc(Result);
      Inc(TempRecordNumber);
      { Version 5 }
      while (Result < MaxNumRecords) and
            (TempRecordNumber <= FFilterBitmap.NumOfBits) do
         begin
         while (Result < MaxNumRecords) and
               (TempRecordNumber <= FFilterBitmap.NumOfBits) and
               FFilterBitmap.IsBitSet(TempRecordNumber) do
            begin
            Inc(Result);
            Inc(TempRecordNumber);
            end;
         { Check for record spread }
         Inc(TempRecordNumber);
         TempSpreadStart:=TempRecordNumber;
         while (Result < MaxNumRecords) and
               (TempRecordNumber <= FFilterBitmap.NumOfBits) and
               (not FFilterBitmap.IsBitSet(TempRecordNumber)) and
               ((TempRecordNumber-TempSpreadStart) <= (MaxNumRecords div 4)) do
            Inc(TempRecordNumber);
         if (TempRecordNumber > FFilterBitmap.NumOfBits) or
            (not FFilterBitmap.IsBitSet(TempRecordNumber)) then
            Break;
         end;
      { Version 5 }
      end
   else
      begin
      Inc(Result);
      Dec(TempRecordNumber);
      { Version 5 }
      while (Result < MaxNumRecords) and
            (TempRecordNumber >= 1) do
         begin
         while (Result < MaxNumRecords) and
               (TempRecordNumber >= 1) and
               FFilterBitmap.IsBitSet(TempRecordNumber) do
            begin
            Inc(Result);
            Dec(TempRecordNumber);
            end;
         { Check for record spread }
         Inc(TempRecordNumber);
         TempSpreadStart:=TempRecordNumber;
         while (Result < MaxNumRecords) and
               (TempRecordNumber >= 1) and
               (not FFilterBitmap.IsBitSet(TempRecordNumber)) and
               ((TempRecordNumber-TempSpreadStart) <= (MaxNumRecords div 4)) do
            Dec(TempRecordNumber);
         if (TempRecordNumber < 1) or
            (not FFilterBitmap.IsBitSet(TempRecordNumber)) then
            Break;
         end;
      { Version 5 }
      end;
end;

function TDataCursor.GetBlockCount(TotalBytes: Integer): Integer;
begin
   if ((TotalBytes mod BlobBlockBufferSize)=0) then
      Result:=(TotalBytes div BlobBlockBufferSize)
   else
      Result:=((TotalBytes div BlobBlockBufferSize)+1);
end;

function TDataCursor.GetNumReadAheadBlocks(MaxNumReadAheadBlocks: Integer;
                                           Direction: Byte): Integer;
begin
   Result:=MinimumInteger(FReadAheadBlocks,MaxNumReadAheadBlocks);
end;

procedure TDataCursor.ClearRecord(RecordBuffer: PChar);
begin
   FillChar(RecordBuffer^,FRecordSize,#0);
end;

procedure TDataCursor.InitRecord(RecordBuffer: PChar);
var
   I: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   TempInteger: Integer;
   TempSmallInt: SmallInt;
   TempWord: Word;
   TempDouble: double;
   TempBCD: TBCD;
   TempDateTime: TDateTime;
   TempTimeStamp: TTimeStamp;
   TempBoolean: WordBool;
   TempLargeInt: Int64;
begin
   FillChar(RecordBuffer^,FRecordSize,#0);
   if (not FHasDefaultValues) then Exit;
   for I:=1 to PhysicalFieldCount do
      begin
      with GetPhysicalFieldDefinitionByPos(I)^ do
         begin
         if (Default <> '') and (DataType <> TYPE_BLOB) then
            begin
            TempInteger:=0;
            TempSmallInt:=0;
            TempWord:=0;
            TempDouble:=0;
            TempBoolean:=False;
            FillChar(TempBCD,SizeOf(TBCD),#0);
            case DataType of
               TYPE_ZSTRING:
                  begin
                  if (AnsiCompareText(Default,PARSE_CURGUID)=0) then
                     StrPCopy(@TempFieldBuffer,OSCreateGUIDString)
                  else
                     StrPCopy(@TempFieldBuffer,Default);
                  end;
               TYPE_FLOAT:
                  begin
                  TempDouble:=StrToAnsiFloat(Default);
                  Move(TempDouble,TempFieldBuffer,DataSize);
                  end;
               TYPE_BCD:
                  begin
                  TempBCD:=CurrToTBCD(StrToAnsiCurr(Default),DataDecimals);
                  Move(TempBCD,TempFieldBuffer,DataSize);
                  end;
               TYPE_TIMESTAMP:
                  begin
                  if (AnsiCompareText(Default,PARSE_CURDATETIME)=0) then
                     TempDateTime:=Now
                  else if (AnsiCompareText(Default,PARSE_CURDATE)=0) then
                     TempDateTime:=Date
                  else if (AnsiCompareText(Default,PARSE_CURTIME)=0) then
                     TempDateTime:=Time
                  else
                     TempDateTime:=StrToAnsiDateTime(Default);
                  TempTimeStamp:=DateTimeToTimeStamp(TempDateTime);
                  TempDouble:=TimeStampToMSecs(TempTimeStamp);
                  Move(TempDouble,TempFieldBuffer,DataSize);
                  end;
               TYPE_DATE:
                  begin
                  if (DataType=TYPE_DATE) and
                     (AnsiCompareText(Default,PARSE_CURDATE)=0) then
                     TempInteger:=DateTimeToTimeStamp(Date).Date
                  else
                     TempInteger:=DateTimeToTimeStamp(StrToAnsiDate(Default)).Date;
                  Move(TempInteger,TempFieldBuffer,DataSize);
                  end;
               TYPE_TIME:
                  begin
                  if (DataType=TYPE_TIME) and
                     (AnsiCompareText(Default,PARSE_CURTIME)=0) then
                     TempInteger:=DateTimeToTimeStamp(Time).Time
                  else
                     TempInteger:=DateTimeToTimeStamp(StrToAnsiTime(Default)).Time;
                  Move(TempInteger,TempFieldBuffer,DataSize);
                  end;
               TYPE_INT32:
                  begin
                  TempInteger:=StrToInt(Default);

                  Move(TempInteger,TempFieldBuffer,DataSize);
                  end;
               TYPE_INT16:
                  begin
                  TempSmallInt:=StrToInt(Default);
                  Move(TempSmallInt,TempFieldBuffer,DataSize);
                  end;
               TYPE_UINT16:
                  begin
                  TempWord:=StrToInt(Default);
                  Move(TempWord,TempFieldBuffer,DataSize);
                  end;
               TYPE_BOOL:
                  begin
                  TempBoolean:=VerifyWordBool(WordBool(StrToAnsiBoolean(Default)));
                  Move(TempBoolean,TempFieldBuffer,DataSize);
                  end;
               TYPE_INT64:
                  begin
                  TempLargeInt:=StrToInt64(Default);
                  Move(TempLargeInt,TempFieldBuffer,DataSize);
                  end;
               end;
            PutPhysicalField(FieldNum,RecordBuffer,@TempFieldBuffer,False);
            end;
         end;
      end;
end;

procedure TDataCursor.CheckRecordValidity(RecordBuffer: PChar);
var
   I: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
begin
   for I:=1 to PhysicalFieldCount do
      begin
      with GetPhysicalFieldDefinitionByPos(I)^ do
         begin
         if Required or (Minimum <> '') or (Maximum <> '') then
            begin
            GetPhysicalField(FieldNum,RecordBuffer,@TempFieldBuffer,IsBlank);
            if (Required and IsBlank) then
               DataEngine.RaiseError(DBISAM_REQDERR,'','',ProperDataDirectoryName,ProperTableName,
                                       FieldName);
            if (not IsBlank) or (IsBlank and (DataType=TYPE_ZSTRING)) then
               begin
               if (Minimum <> '') then
                  begin
                  if not CheckField(Minimum,feMinimum,@TempFieldBuffer,DataType) then
                     DataEngine.RaiseError(DBISAM_MINVALERR,'','',ProperDataDirectoryName,ProperTableName,
                                             FieldName);
                  end;
               if (Maximum <> '') then
                  begin
                  if not CheckField(Maximum,feMaximum,@TempFieldBuffer,DataType) then
                     DataEngine.RaiseError(DBISAM_MAXVALERR,'','',ProperDataDirectoryName,ProperTableName,
                                             FieldName);
                  end;
               end;
            end;
         end;
      end;
end;

function TDataCursor.CheckField(FieldExpression: string;
                                FieldExpressionType: TFieldExpressionType;
                                FieldBuffer: PChar; FieldType: Byte): Boolean;

var
   TempInteger: Integer;
   TempSmallInt: SmallInt;
   TempWord: Word;
   TempDouble: double;
   TempCurrency: Currency;
   TempDateTime: TDateTime;
   TempTimeStamp: TTimeStamp;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   TempLargeInt: Integer;
   TempBoolean: Boolean;
begin
   Result:=True;
   case FieldType of
      TYPE_ZSTRING:
         begin
         StrPCopy(@TempFieldBuffer,FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (OSCompareStrings(LocaleID,FieldBuffer,@TempFieldBuffer,
                             0,False)=CMP_LESS)) or
            ((FieldExpressionType=feMaximum) and
             (OSCompareStrings(LocaleID,FieldBuffer,@TempFieldBuffer,
                             0,False)=CMP_GREATER)) then
            Result:=False;
         end;
      TYPE_FLOAT:
         begin
         TempDouble:=StrToAnsiFloat(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (pDouble(FieldBuffer)^ < TempDouble)) or
            ((FieldExpressionType=feMaximum) and
             (pDouble(FieldBuffer)^ > TempDouble)) then
            Result:=False;
         end;
      TYPE_BCD:
         begin
         TempCurrency:=StrToAnsiCurr(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
            (TBCDToCurr(pBCD(FieldBuffer)^) < TempCurrency)) or
            ((FieldExpressionType=feMaximum) and
            (TBCDToCurr(pBCD(FieldBuffer)^) > TempCurrency)) then
               Result:=False;
         end;
      TYPE_TIMESTAMP:
         begin
         TempTimeStamp:=MSecsToTimeStamp(pDouble(FieldBuffer)^);
         TempDateTime:=StrToAnsiDateTime(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (TimeStampToDateTime(TempTimeStamp) < TempDateTime)) or
            ((FieldExpressionType=feMaximum) and
             (TimeStampToDateTime(TempTimeStamp) > TempDateTime)) then
            Result:=False;
         end;
      TYPE_INT32:
         begin
         TempInteger:=StrToInt(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (pInteger(FieldBuffer)^ < TempInteger)) or
            ((FieldExpressionType=feMaximum) and
             (pInteger(FieldBuffer)^ > TempInteger)) then
            Result:=False;
         end;
      TYPE_DATE:
         begin
         TempTimeStamp.Date:=pInteger(FieldBuffer)^;
         TempTimeStamp.Time:=0;
         TempDateTime:=StrToAnsiDate(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (TimeStampToDateTime(TempTimeStamp) < TempDateTime)) or
            ((FieldExpressionType=feMaximum) and
             (TimeStampToDateTime(TempTimeStamp) > TempDateTime)) then
            Result:=False;
         end;
      TYPE_TIME:
         begin
         TempTimeStamp.Date:=1;
         TempTimeStamp.Time:=pInteger(FieldBuffer)^;
         TempDateTime:=StrToAnsiTime(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (TimeStampToDateTime(TempTimeStamp) < TempDateTime)) or
            ((FieldExpressionType=feMaximum) and
             (TimeStampToDateTime(TempTimeStamp) > TempDateTime)) then
            Result:=False;
         end;
      TYPE_INT16:
         begin
         TempSmallInt:=StrToInt(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (pSmallInt(FieldBuffer)^ < TempSmallInt)) or
            ((FieldExpressionType=feMaximum) and
             (pSmallInt(FieldBuffer)^ > TempSmallInt)) then
            Result:=False;
         end;
      TYPE_UINT16:
         begin
         TempWord:=StrToInt(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (pWord(FieldBuffer)^ < TempWord)) or
            ((FieldExpressionType=feMaximum) and
             (pWord(FieldBuffer)^ > TempWord)) then
            Result:=False;
         end;
      TYPE_INT64:
         begin
         TempLargeInt:=StrToInt64(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (pInt64(FieldBuffer)^ < TempLargeInt)) or
            ((FieldExpressionType=feMaximum) and
             (pInt64(FieldBuffer)^ > TempLargeInt)) then
            Result:=False;
         end;
      TYPE_BOOL:
         begin
         TempBoolean:=StrToAnsiBoolean(FieldExpression);
         if ((FieldExpressionType=feMinimum) and
             (VerifyWordBool(pWordBool(FieldBuffer)^) and (not TempBoolean))) or
            ((FieldExpressionType=feMaximum) and
             ((not VerifyWordBool(pWordBool(FieldBuffer)^)) and TempBoolean)) then
            Result:=False;
         end;
      end;
end;

procedure TDataCursor.SetAutoIncFields(RecordBuffer: PChar; Increment: Boolean);
var
   I: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
begin
   for I:=1 to PhysicalFieldCount do
      begin
      with GetPhysicalFieldDefinitionByPos(I)^ do
         begin
         if (DataType=TYPE_INT32) and (SubType=SUBTYPE_AUTOINC) then
            begin
            GetPhysicalField(FieldNum,RecordBuffer,@TempFieldBuffer,IsBlank);
            if Increment then
               begin
               LastAutoIncID:=MaximumInteger(LastAutoIncID,pInteger(@TempFieldBuffer)^);
               { Version 5}
               DataSession.SessionLastAutoInc:=LastAutoIncID;
               { Version 5}
               end
            else
               begin
               if IsBlank then
                  begin
                  pInteger(@TempFieldBuffer)^:=WrapIncInteger(LastAutoIncID);
                  PutPhysicalField(FieldNum,RecordBuffer,@TempFieldBuffer,False);
                  end;
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.SetRecordID(RecordBuffer: PChar; Increment: Boolean);
begin
   if Increment then
      LastRecordID:=MaximumInteger(LastRecordID,GetRecordID(RecordBuffer))
   else
      begin
      if (not FSuppressRecordIDs) then
         PutRecordID(WrapIncInteger(LastRecordID),RecordBuffer);
      end;
end;

function TDataCursor.CalcRecordHash(RecordBuffer: PChar): TMD5Digest;
var
   I: Word;
begin
   { Version 5 }
   if (BlobFieldCount > 0) or FResultSet then
   { Version 5 }
      begin
      FHashRecord.Initialize;
      for I:=1 to PhysicalFieldCount do
         begin
         with GetPhysicalFieldDefinitionByPos(I)^ do
            begin
            { Version 5 }
            if (DataType <> TYPE_BLOB) and (not Hidden) then
            { Version 5 }
               Move((RecordBuffer+Offset)^,(FHashRecord.Buffer+Offset)^,
                    (FLDCHG_DATA+DataSize));
            end;
         end;
      Result:=MD5Buffer((FHashRecord.Buffer+SizeOf(TRecordHeader))^,
                        (PhysicalRecordSize-SizeOf(TRecordHeader)));
      end
   else
      Result:=MD5Buffer((RecordBuffer+SizeOf(TRecordHeader))^,
                        (PhysicalRecordSize-SizeOf(TRecordHeader)));
end;

function TDataCursor.GetCurrentRecord(RecordBuffer: PChar; LockIt: Boolean): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_GETCURRECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(RecordBuffer^,FRecordSize);
         Pack(LockIt,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(RecordBuffer^);
         if (Result=DBISAM_NONE) then
            begin
            if LockIt and (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
               LockRecord(FCurRecordNumber);
            end;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if LockIt then
            begin
            FLastRecord.Copy(FCurrentRecord);
            if (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
               begin
               LockRecord(FLastRecord.Number);
               if (not FExclusive) then
                  begin
                  if (not MD5DigestCompare(FCurrentRecord.Hash,GetRecordHash(RecordBuffer))) or
                     (FCurrentRecord.Status=RECORD_DELETED) then
                     begin
                     UnlockRecord(FLastRecord.Number,False);
                     DataEngine.RaiseError(DBISAM_KEYORRECDELETED,'','',ProperDataDirectoryName,
                                             FTableName);
                     end;
                  end;
               end
            else
               begin
               if (not MD5DigestCompare(FLastRecord.Hash,GetRecordHash(RecordBuffer))) or
                  (FCurrentRecord.Status=RECORD_DELETED) then
                  DataEngine.RaiseError(DBISAM_KEYORRECDELETED,'','',ProperDataDirectoryName,
                                          FTableName);
               end;
            end;
         if (not LockIt) then
            begin
            RefreshCurrentRecord(READ_CURRENT);
            VerifyCurrentRecord(READ_CURRENT);
            end;
         if (FBOF and FEOF) then
            begin
            Result:=DBISAM_NOCURRREC;
            ClearRecord(RecordBuffer);
            end
         else if (FBOF) then
            begin
            Result:=DBISAM_BOF;
            ClearRecord(RecordBuffer);
            end
         else if (FEOF) then
            begin
            Result:=DBISAM_EOF;
            ClearRecord(RecordBuffer);
            end
         else
            FCurrentRecord.CopyToBuffer(RecordBuffer);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.CloneCurrentRecord(RecordBuffer: PChar): Word;
var
   I: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSize: Integer;
   IsBlank: Boolean;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_CLONECURRECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         if (RecordBuffer <> nil) then
            begin
            Unpack(RecordBuffer^);
            for I:=1 to FFieldCount do
               begin
               Self.GetField(FFieldDefinitions[I]^.FieldNum,
                             RecordBuffer,@TempFieldBuffer,IsBlank);
               if not IsBlank then
                  begin
                  if (FFieldDefinitions[I]^.DataType=TYPE_BLOB) then
                     OpenBlob(FFieldDefinitions[I]^.FieldNum,
                              RecordBuffer,BLOB_OPENREADWRITE,False,True,
                              BlobSize,True);
                  end;
               end;
            end;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         RefreshCurrentRecord(READ_CURRENT);
         VerifyCurrentRecord(READ_CURRENT);
         if (FBOF and FEOF) then
            Result:=DBISAM_NOCURRREC
         else
            begin
            if (RecordBuffer <> nil) then
               begin
               ClearRecord(RecordBuffer);
               for I:=1 to FFieldCount do
                  begin
                  Self.GetField(FFieldDefinitions[I]^.FieldNum,
                                FCurrentRecord.Buffer,
                                @TempFieldBuffer,IsBlank);
                  if not IsBlank then
                     begin
                     if (FFieldDefinitions[I]^.DataType=TYPE_BLOB) then
                        begin
                        OpenBlob(FFieldDefinitions[I]^.FieldNum,
                                 FCurrentRecord.Buffer,
                                 BLOB_OPENREADONLY,False,True,BlobSizeToLoad,False);
                        try
                           GetField(FFieldDefinitions[I]^.FieldNum,
                                         FCurrentRecord.Buffer,
                                         @BlobHandle,IsBlank);
                           OpenBlob(FFieldDefinitions[I]^.FieldNum,
                                    RecordBuffer,BLOB_OPENREADWRITE,
                                    False,True,BlobSize,False);
                           BlobHandle:=FlipIntegerSign(BlobHandle);
                           PutBlob(FFieldDefinitions[I]^.FieldNum,
                                   RecordBuffer,0,TBlobBuffer(BlobHandle).Buffer,
                                   BlobSizeToLoad,False);
                        finally
                           FreeBlob(FFieldDefinitions[I]^.FieldNum,
                                    FCurrentRecord.Buffer,False,True)
                        end;
                        end
                     else if (FFieldDefinitions[I]^.DataType=TYPE_INT32) and
                             (FFieldDefinitions[I]^.SubType=SUBTYPE_AUTOINC) then
                        { Do nothing }
                     else
                        PutField(FFieldDefinitions[I]^.FieldNum,
                                 RecordBuffer,@TempFieldBuffer,True,False);
                     end;
                  end;
               end;
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadMoreRecords(CurRequestCode: Word): Boolean;
begin
   if (RemainingLocalReplySize=0) then
      Result:=True
   else
      begin
      if (GetLastRequestCode <> CurRequestCode) then
         Result:=True
      else
         Result:=False;
      end;
end;

function TDataCursor.GetNextRecord(RecordBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      if ReadMoreRecords(REQUEST_GETNEXTRECORD) then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_GETNEXTRECORD);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(FRecordsToRead,SizeOf(Integer));
            EndPack;
            SendReceive;
            SaveReceiveBuffer;
            CheckForException;
         finally
            EndRemoteRequest;
         end;
         end;
      LocalUnpack(Result);
      LocalUnpackCursorInfo;
      if (Result=DBISAM_NONE) then
         begin
         if (RecordBuffer <> nil) then
            LocalUnpack(RecordBuffer^)
         else
            SkipLocalUnpack;
         end
      else
         begin
         SkipLocalUnpack;
         if (RecordBuffer <> nil) then
            ClearRecord(RecordBuffer);
         end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if not FBOF then
            begin
            SkipIndexKeys(1);
            RefreshCurrentRecord(READ_FORWARD);
            VerifyCurrentRecord(READ_FORWARD);
            if FEOF then
               begin
               Result:=DBISAM_EOF;
               if (RecordBuffer <> nil) then
                  ClearRecord(RecordBuffer);
               end
            else
               begin
               if (RecordBuffer <> nil) then
                  FCurrentRecord.CopyToBuffer(RecordBuffer);
               end;
            end
         else
            begin
            GotoFirstIndexPosition;
            RefreshCurrentRecord(READ_FORWARD);
            VerifyCurrentRecord(READ_FORWARD);
            if FEOF then
               begin
               Result:=DBISAM_EOF;
               if (RecordBuffer <> nil) then
                  ClearRecord(RecordBuffer);
               end
            else
               begin
               if (RecordBuffer <> nil) then
                  FCurrentRecord.CopyToBuffer(RecordBuffer);
               end;
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.GetPriorRecord(RecordBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      if ReadMoreRecords(REQUEST_GETPRIORRECORD) then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_GETPRIORRECORD);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(FRecordsToRead,SizeOf(Integer));
            EndPack;
            SendReceive;
            SaveReceiveBuffer;
            CheckForException;
         finally
            EndRemoteRequest;
         end;
         end;
      LocalUnpack(Result);
      LocalUnpackCursorInfo;
      if (Result=DBISAM_NONE) then
         begin
         if (RecordBuffer <> nil) then
            LocalUnpack(RecordBuffer^)
         else
            SkipLocalUnpack;
         end
      else
         begin
         SkipLocalUnpack;
         if (RecordBuffer <> nil) then
            ClearRecord(RecordBuffer);
         end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if not FEOF then
            begin
            SkipIndexKeys(-1);
            RefreshCurrentRecord(READ_BACKWARD);
            VerifyCurrentRecord(READ_BACKWARD);
            if FBOF then
               begin
               Result:=DBISAM_BOF;
               if (RecordBuffer <> nil) then
                  ClearRecord(RecordBuffer);
               end
            else
               begin
               if (RecordBuffer <> nil) then
                  FCurrentRecord.CopyToBuffer(RecordBuffer);
               end;
            end
         else
            begin
            GotoLastIndexPosition;
            RefreshCurrentRecord(READ_BACKWARD);
            VerifyCurrentRecord(READ_BACKWARD);
            if FBOF then
               begin
               Result:=DBISAM_BOF;
               if (RecordBuffer <> nil) then
                  ClearRecord(RecordBuffer);
               end
            else
               begin
               if (RecordBuffer <> nil) then
                  FCurrentRecord.CopyToBuffer(RecordBuffer);
               end;
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.PopulateRecordBlockForward(StartRow: Integer;
                                                var NumRecords: Integer;
                                                RecordsBuffer: PChar;
                                                BookmarksBuffer: PChar): Word;
var
   I: Integer;
   RecordsRead: Integer;
   RecordPtr: PChar;
   BookmarkPtr: PChar;
begin
   Result:=DBISAM_NONE;
   RecordPtr:=(RecordsBuffer+((StartRow-1)*RecordSize));
   BookmarkPtr:=(BookmarksBuffer+((StartRow-1)*BookmarkSize));
   RecordsRead:=(StartRow-1);
   for I:=StartRow to NumRecords do
      begin
      if not FBOF then
         begin
         if not FEOF then
            begin
            SkipIndexKeys(1);
            RefreshCurrentRecord(READ_FORWARD);
            VerifyCurrentRecord(READ_FORWARD);
            if FEOF then
               begin
               Result:=DBISAM_EOF;
               ClearRecord(RecordPtr);
               ClearBookmark(BookmarkPtr);
               end
            else
               begin
               FCurrentRecord.CopyToBuffer(RecordPtr);
               GetBookmark(BookmarkPtr);
               end;
            end
         else
            begin
            Result:=DBISAM_EOF;
            ClearRecord(RecordPtr);
            ClearBookmark(BookmarkPtr);
            end;
         end
      else
         begin
         GotoFirstIndexPosition;
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
         if FEOF then
            begin
            Result:=DBISAM_EOF;
            ClearRecord(RecordPtr);
            ClearBookmark(BookmarkPtr);
            end
         else
            begin
            FCurrentRecord.CopyToBuffer(RecordPtr);
            GetBookmark(BookmarkPtr);
            end;
         end;
      if (Result=DBISAM_NONE) then
         begin
         Inc(RecordsRead);
         Inc(RecordPtr,RecordSize);
         Inc(BookmarkPtr,BookmarkSize)
         end
      else
         Break;
      end;
   NumRecords:=RecordsRead;
end;

function TDataCursor.PopulateRecordBlockBackward(var NumRecords: Integer;
                                                 RecordsBuffer: PChar;
                                                  BookmarksBuffer: PChar;
                                                 ShiftBuffers: Boolean): Word;
var
   I: Integer;
   RecordsRead: Integer;
   RecordPtr: PChar;
   BookmarkPtr: PChar;
begin
   Result:=DBISAM_NONE;
   RecordPtr:=(RecordsBuffer+((NumRecords-1)*RecordSize));
   BookmarkPtr:=(BookmarksBuffer+((NumRecords-1)*BookmarkSize));
   RecordsRead:=0;
   for I:=1 to NumRecords do
      begin
      if not FEOF then
         begin
         if not FBOF then
            begin
            SkipIndexKeys(-1);
            RefreshCurrentRecord(READ_BACKWARD);
            VerifyCurrentRecord(READ_BACKWARD);
            if FBOF then
               begin
               Result:=DBISAM_BOF;
               ClearRecord(RecordPtr);
               ClearBookmark(BookmarkPtr);
               end
            else
               begin
               FCurrentRecord.CopyToBuffer(RecordPtr);
               GetBookmark(BookmarkPtr);
               end;
            end
         else
            begin
            Result:=DBISAM_BOF;
            ClearRecord(RecordPtr);
            ClearBookmark(BookmarkPtr);
            end;
         end
      else
         begin
         GotoLastIndexPosition;
         RefreshCurrentRecord(READ_BACKWARD);
         VerifyCurrentRecord(READ_BACKWARD);
         if FBOF then
            begin
            Result:=DBISAM_BOF;
            ClearRecord(RecordPtr);
            ClearBookmark(BookmarkPtr);
            end
         else
            begin
            FCurrentRecord.CopyToBuffer(RecordPtr);
            GetBookmark(BookmarkPtr);
            end;
         end;
      if (Result=DBISAM_NONE) then
         begin
         Inc(RecordsRead);
         Dec(RecordPtr,RecordSize);
         Dec(BookmarkPtr,BookmarkSize)
         end
      else
         Break;
      end;
   if (RecordsRead < NumRecords) and ShiftBuffers then
      begin
      Move((RecordPtr+RecordSize)^,RecordsBuffer^,(RecordsRead*RecordSize));
      Move((BookmarkPtr+BookmarkSize)^,BookmarksBuffer^,(RecordsRead*BookmarkSize))
      end;
   NumRecords:=RecordsRead;
end;

function TDataCursor.ReadFirstRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                          BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READFIRSTRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GotoFirstIndexPosition;
         SkipIndexKeys(-1);
         Result:=PopulateRecordBlockForward(1,NumRecords,RecordsBuffer,
                                            BookmarksBuffer);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadNextRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                         BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READNEXTRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         Result:=PopulateRecordBlockForward(1,NumRecords,RecordsBuffer,
                                            BookmarksBuffer);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadPriorRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                          BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READPRIORRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         Result:=PopulateRecordBlockBackward(NumRecords,RecordsBuffer,
                                             BookmarksBuffer,False);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadLastRecordBlock(var NumRecords: Integer; RecordsBuffer: PChar;
                                         BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READLASTRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GotoLastIndexPosition;
         SkipIndexKeys(1);
         Result:=PopulateRecordBlockBackward(NumRecords,RecordsBuffer,
                                             BookmarksBuffer,True);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadAbsoluteRecordBlock(ReadOffset: Integer;
                                             var NumRecords: Integer; RecordsBuffer: PChar;
                                             BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READABSOLUTERECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(ReadOffset,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         { Version 5 }
         if (FResultSet and FSourceTable) then
            begin
            if (ReadOffset > (RecordCount div 2)) then
               begin
               GotoLastIndexPosition;
               SkipIndexKeys(-(RecordCount-ReadOffset));
               end
            else
               begin
               GotoFirstIndexPosition;
               SkipIndexKeys((ReadOffset-1));
               end;
            end
         else
            SetToRecordNumber(ReadOffset);
         { Version 5 }
         Result:=PopulateRecordBlockForward(1,NumRecords,RecordsBuffer,
                                            BookmarksBuffer);
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ReadBookmarkRecordBlock(ReadOffset: Integer;
                                             BookmarkBuffer: PChar;
                                             ResetPosition: Boolean;
                                             var NumRecords: Integer;
                                             RecordsBuffer: PChar;
                                             BookmarksBuffer: PChar): Word;
begin
   Result:=DBISAM_NONE;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_READBOOKMARKRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(ReadOffset,SizeOf(Integer));
         Pack(BookmarkBuffer^,BookmarkSize);
         Pack(ResetPosition,SizeOf(Boolean));
         Pack(NumRecords,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
         Unpack(NumRecords);
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if SetToBookmark(BookmarkBuffer,False,True) then
            begin
            try
               SkipIndexKeys(ReadOffset-1);
               FEOF:=False;
               Result:=PopulateRecordBlockForward(1,NumRecords,RecordsBuffer,
                                                  BookmarksBuffer);
            finally
               if ResetPosition then
                  SetToBookmark(BookmarkBuffer,True,True);
            end;
            end
         else
            begin
            NumRecords:=0;
            Result:=DBISAM_EOF;
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.RefreshRecordBlock(NumRecords: Integer;
                                         RecordsBuffer: PChar; BookmarksBuffer: PChar);
var
   I: Integer;
   RecordPtr: PChar;
   BookmarkPtr: PChar;
   TempCode: Word;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_REFRESHRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         Pack(RecordsBuffer^,(NumRecords*RecordSize));
         Pack(BookmarksBuffer^,(NumRecords*BookmarkSize));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
         Unpack(RecordsBuffer^);
         Unpack(BookmarksBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         if (not DataSession.StrictChangeDetection) then
            Refresh;
         RecordPtr:=RecordsBuffer;
         BookmarkPtr:=BookmarksBuffer;
         for I:=1 to NumRecords do
            begin
            if SetToBookmark(BookmarkPtr,False,True) then
               begin
               try
                  GetCurrentRecord(RecordPtr,False);
                  PutRecordStatus(RECORD_VALID,RecordPtr);
                  GetBookmark(BookmarkPtr);
               except
                  on E: Exception do
                     begin
                     PutRecordStatus(RECORD_ERROR,RecordPtr);
                     TempCode:=DataEngine.ConvertExceptionToCode(E);
                     PutRecordNo(TempCode,RecordPtr);
                     end;
               end;
               end
            else
               begin
               ClearRecord(RecordPtr);
               PutRecordStatus(RECORD_DELETED,RecordPtr);
               PutRecordNo(DBISAM_KEYORRECDELETED,RecordPtr);
               end;
            Inc(RecordPtr,RecordSize);
            Inc(BookmarkPtr,BookmarkSize);
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.AddRecordBlock(var RecordsAdded: Integer; ParamRecordBuffer: PChar;
                                     RecordBuffer: PChar; BookmarkBuffer: PChar);
var
   I: Integer;
   TempOffset: Word;
   TotalBlobSize: Integer;
   TempRecordPtr: PChar;
   TempCode: Word;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ADDRECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(RecordBuffer^,RecordSize);
         Pack(BookmarkBuffer^,BookmarkSize);
         TempOffset:=0;
         for I:=1 to FFieldCount do
            begin
            with GetFieldDefinition(I)^ do
               begin
               if (DataType <> TYPE_BLOB) then
                  begin
                  Pack((ParamRecordBuffer+TempOffset)^,(FLDCHG_DATA+DataSize));
                  Inc(TempOffset,(FLDCHG_DATA+DataSize));
                  end
               else
                  begin
                  Pack((ParamRecordBuffer+TempOffset)^,(FLDCHG_DATA+SizeOf(TBlobParam)));
                  Pack(pBlobParam((ParamRecordBuffer+FLDCHG_DATA+TempOffset))^.BlobBuffer^,
                       pBlobParam((ParamRecordBuffer+FLDCHG_DATA+TempOffset))^.BlobLength);
                  Inc(TempOffset,(FLDCHG_DATA+SizeOf(TBlobParam)));
                  end;
               end;
            end;
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
         Unpack(RecordsAdded);
         Unpack(RecordBuffer^);
         Unpack(BookmarkBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         RecordsAdded:=0;
         try
            try
               TempRecordPtr:=ParamRecordBuffer;
               for I:=1 to FieldCount do
                  begin
                  with GetFieldDefinition(I)^ do
                     begin
                     if (DataType=TYPE_BLOB) then
                        begin
                        OpenBlob(I,RecordBuffer,BLOB_OPENREADWRITE,False,False,
                                 TotalBlobSize,False);
                        TruncateBlob(I,RecordBuffer,0,False);
                        PutBlob(I,RecordBuffer,0,
                                pBlobParam((TempRecordPtr+FLDCHG_DATA))^.BlobBuffer,
                                pBlobParam((TempRecordPtr+FLDCHG_DATA))^.BlobLength,False);
                        Inc(TempRecordPtr,(SizeOf(TBlobParam)+FLDCHG_DATA));
                        end
                     else
                        begin
                        if Boolean(TempRecordPtr^) then
                           PutField(I,RecordBuffer,(TempRecordPtr+FLDCHG_DATA),
                                    False,False)
                        else
                           PutField(I,RecordBuffer,nil,False,False);
                        Inc(TempRecordPtr,(DataSize+FLDCHG_DATA));
                        end;
                     end;
                  end;
               AppendRecord(RecordBuffer,True);
               PutRecordStatus(RECORD_VALID,RecordBuffer);
               GetBookmark(BookmarkBuffer);
               Inc(RecordsAdded);
            finally
               CancelAllBlobs(RecordBuffer);
            end;
         except
            on E: Exception do
               begin
               CancelRecord;
               PutRecordStatus(RECORD_ERROR,RecordBuffer);
               TempCode:=DataEngine.ConvertExceptionToCode(E);
               PutRecordNo(TempCode,RecordBuffer);
               end;
         end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.UpdateRecordBlock(var RecordsUpdated: Integer; ParamRecordBuffer: PChar;
                                        RecordBuffer: PChar; BookmarkBuffer: PChar);
var
   I: Integer;
   TempOffset: Word;
   TotalBlobSize: Integer;
   TempRecordPtr: PChar;
   TempCode: Word;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_UPDATERECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(RecordBuffer^,RecordSize);
         Pack(BookmarkBuffer^,BookmarkSize);
         TempOffset:=0;
         for I:=1 to FFieldCount do
            begin
            with GetFieldDefinition(I)^ do
               begin
               if (DataType <> TYPE_BLOB) then
                  begin
                  Pack((ParamRecordBuffer+TempOffset)^,(FLDCHG_DATA+DataSize));
                  Inc(TempOffset,(FLDCHG_DATA+DataSize));
                  end
               else
                  begin
                  Pack((ParamRecordBuffer+TempOffset)^,(FLDCHG_DATA+SizeOf(TBlobParam)));
                  Pack(pBlobParam((ParamRecordBuffer+FLDCHG_DATA+TempOffset))^.BlobBuffer^,
                       pBlobParam((ParamRecordBuffer+FLDCHG_DATA+TempOffset))^.BlobLength);
                  Inc(TempOffset,(FLDCHG_DATA+SizeOf(TBlobParam)));
                  end;
               end;
            end;
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
         Unpack(RecordsUpdated);
         Unpack(RecordBuffer^);
         Unpack(BookmarkBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         RecordsUpdated:=0;
         if SetToBookmark(BookmarkBuffer,False,True) then
            begin
            try
               GetCurrentRecord(RecordBuffer,True);
               try
                  try
                     TempRecordPtr:=ParamRecordBuffer;
                     for I:=1 to FieldCount do
                        begin
                        with GetFieldDefinition(I)^ do
                           begin
                           if (DataType=TYPE_BLOB) then
                              begin
                              OpenBlob(I,RecordBuffer,BLOB_OPENREADWRITE,False,False,
                                       TotalBlobSize,False);
                              TruncateBlob(I,RecordBuffer,0,False);
                              PutBlob(I,RecordBuffer,0,
                                      pBlobParam((TempRecordPtr+FLDCHG_DATA))^.BlobBuffer,
                                      pBlobParam((TempRecordPtr+FLDCHG_DATA))^.BlobLength,False);
                              Inc(TempRecordPtr,(SizeOf(TBlobParam)+FLDCHG_DATA));
                              end
                           else
                              begin
                              if Boolean(TempRecordPtr^) then
                                 PutField(I,RecordBuffer,(TempRecordPtr+FLDCHG_DATA),
                                          False,False)
                              else
                                 PutField(I,RecordBuffer,nil,False,False);
                              Inc(TempRecordPtr,(DataSize+FLDCHG_DATA));
                              end;
                           end;
                        end;
                     ModifyRecord(RecordBuffer,True,True);
                     PutRecordStatus(RECORD_VALID,RecordBuffer);
                     GetBookmark(BookmarkBuffer);
                     Inc(RecordsUpdated);
                  finally
                     CancelAllBlobs(RecordBuffer);
                  end;
               except
                  CancelRecord;
                  raise;
               end;
            except
               on E: Exception do
                  begin
                  PutRecordStatus(RECORD_ERROR,RecordBuffer);
                  TempCode:=DataEngine.ConvertExceptionToCode(E);
                  PutRecordNo(TempCode,RecordBuffer);
                  end;
            end;
            end
         else
            begin
            ClearRecord(RecordBuffer);
            PutRecordStatus(RECORD_DELETED,RecordBuffer);
            PutRecordNo(DBISAM_KEYORRECDELETED,RecordBuffer);
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.DeleteRecordBlock(NumRecords: Integer; var RecordsDeleted: Integer;
                                        RecordsBuffer: PChar; BookmarksBuffer: PChar);
var
   I: Integer;
   RecordPtr: PChar;
   BookmarkPtr: PChar;
   TempCode: Word;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETERECORDBLOCK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(NumRecords,SizeOf(Integer));
         Pack(RecordsBuffer^,(NumRecords*RecordSize));
         Pack(BookmarksBuffer^,(NumRecords*BookmarkSize));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
         Unpack(RecordsDeleted);
         Unpack(RecordsBuffer^);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         RecordPtr:=RecordsBuffer;
         BookmarkPtr:=BookmarksBuffer;
         RecordsDeleted:=0;
         for I:=1 to NumRecords do
            begin
            if SetToBookmark(BookmarkPtr,False,True) then
               begin
               try
                  DeleteRecord(RecordPtr,True);
                  SkipIndexKeys(-1);
                  PutRecordStatus(RECORD_DELETED,RecordPtr);
                  Inc(RecordsDeleted);
               except
                  on E: Exception do
                     begin
                     PutRecordStatus(RECORD_ERROR,RecordPtr);
                     TempCode:=DataEngine.ConvertExceptionToCode(E);
                     PutRecordNo(TempCode,RecordPtr);
                     end;
               end;
               end
            else
               begin
               ClearRecord(RecordPtr);
               PutRecordStatus(RECORD_DELETED,RecordPtr);
               PutRecordNo(DBISAM_KEYORRECDELETED,RecordPtr);
               end;
            Inc(RecordPtr,RecordSize);
            Inc(BookmarkPtr,BookmarkSize);
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.AppendRecord(RecordBuffer: PChar; RefreshFilter: Boolean;
                                   SetRecordHash: Boolean=True;
                                   SkipKeyChecks: Boolean=False;
                                   SkipAutoInc: Boolean=False;
                                   CopyRecordNo: Boolean=False);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   NewRecord: TRecord;
   I: Word;
   CurIndexPos: Byte;
   BlobModified: Boolean;
   TempResponse: Byte;
begin
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_APPENDRECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(RecordBuffer^,FRecordSize);
         Pack(RefreshFilter,SizeOf(Boolean));
         FlushBlobBuffers;
         EndPack;
         SendReceive;
         CheckForException;
         { Free any engine allocated BLOBs - CopyOnAppend }
         if (BlobFieldCount > 0) then
            FreeAllBlobs(False,True);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      TempResponse:=ERROR_RESPONSE_RETRY;
      while (TempResponse=ERROR_RESPONSE_RETRY) do
         begin
         TempResponse:=ERROR_RESPONSE_FAIL;
         FLastRecord.Initialize;
         if (not FSuppressTriggers) then
            DataEngine.Trigger(TRIGGER_BEFOREINSERT,DataSession,
                               FDataDirectory,Self,
                               -1,RecordBuffer,
                               FLastRecord.Buffer);
         try
            try
               WriteLockTable;
               try
                  BlobModified:=False;
                  FLastRecord.Number:=NextFreeRecordNumber;
                  LockRecord(FLastRecord.Number);
                  try
                     CurIndexPos:=FIndexPos;
                     try
                        { Use a scratch record so we don't touch the real
                          record buffer }
                        with FScratchRecord do
                           begin
                           Initialize;
                           Number:=FLastRecord.Number;
                           CopyBuffer(RecordBuffer);
                           if (not CopyRecordNo) then
                              OriginalNumber:=0;
                           end;
                        { Set the autoinc fields for the validity checks only }
                        if FHasAutoIncFields and (not SkipAutoInc) then
                           SetAutoIncFields(FScratchRecord.Buffer,False);
                        if FHasValidityChecks then
                           CheckRecordValidity(FScratchRecord.Buffer);
                        { Set the record ID for the key violation checks only }
                        SetRecordID(FScratchRecord.Buffer,False);
                        if SetRecordHash then
                           FScratchRecord.Hash:=CalcRecordHash(FScratchRecord.Buffer);
                        if (not SkipKeyChecks) then
                           begin
                           for I:=0 to IndexCount do
                              begin
                              if IsUniqueIndex(I) then
                                 begin
                                 InternalSetIndexPos(I);
                                 GetKeyValues(FScratchRecord.Buffer,@TempKeyBuffer);
                                 if CheckForKeyViolation(@TempKeyBuffer) then
                                    RaiseKeyViolationError;
                                 end;
                              end;
                           end;
                        GetNextFreeRecord(NewRecord);
                        try
                           NewRecord.Initialize;
                           NewRecord.CopyBuffer(FScratchRecord.Buffer);
                           { If performing cached updates, then be sure to set the
                             record modification flag }
                           if FCachedUpdates then
                              NewRecord.Status:=RECORD_MODIFIED;
                           IncTotalRecordCount;
                           { Now increment the values for autoinc fields }
                           if FHasAutoIncFields then
                              SetAutoIncFields(NewRecord.Buffer,True);
                           { Now increment the record ID }
                           SetRecordID(NewRecord.Buffer,True);
                           for I:=0 to IndexCount do
                              begin
                              InternalSetIndexPos(I);
                              GetKeyValues(NewRecord.Buffer,@TempKeyBuffer);
                              AddIndexKey(@TempKeyBuffer,NewRecord.Number);
                              end;
                           AddTextIndexes(NewRecord);
                           if (BlobFieldCount > 0) then
                              begin
                              UpdateBlobSignatures(NewRecord.Buffer,False);
                              BlobModified:=FlushBlobBuffers;
                              UpdateBlobBlocks(NewRecord.Buffer,False);
                              FreeAllBlobs(False,False);
                              end;
                           FCurrentRecord.Copy(NewRecord);
                           FCurRecordNumber:=FCurrentRecord.Number;
                           { Version 5 }
                           PutRecordNo(FCurrentRecord.Number,RecordBuffer);
                           { Version 5 }
                        finally
                           PutRecord(NewRecord);
                        end;
                        FlushBuffers(False,False,True,True,BlobModified);
                     finally
                        InternalSetIndexPos(CurIndexPos);
                        if RefreshFilter then
                           begin
                           RefreshRangeAndFilterUpdate(FCurrentRecord.Number,
                                                       FCurrentRecord.Buffer,
                                                       FCurrentRecord.Buffer);
                           RepositionCurrentRecord;
                           end;
                     end;
                  finally
                     UnlockRecord(FLastRecord.Number,False);
                  end;
               finally
                  WriteUnlockTable;
               end;
               if (not FSuppressTriggers) then
                  DataEngine.Trigger(TRIGGER_AFTERINSERT,DataSession,
                                     FDataDirectory,Self,
                                     FCurrentRecord.Number,
                                     FCurrentRecord.Buffer,
                                     FLastRecord.Buffer);
            finally
               FLastRecord.Initialize;
            end;
         except
            on E: Exception do
               begin
               if (not FSuppressTriggers) then
                  DataEngine.Error(ERROR_EVENT_INSERT,
                                   DataSession,
                                   FDataDirectory,Self,
                                   -1,RecordBuffer,E,TempResponse);
               case TempResponse of
                  ERROR_RESPONSE_FAIL:
                     raise;
                  ERROR_RESPONSE_ABORT:
                     Abort;
                  end;
               end;
         end;
         end;
      end;
end;

procedure TDataCursor.ModifyRecord(RecordBuffer: PChar; UnlockIt: Boolean;
                                   RefreshFilter: Boolean;
                                   SkipKeyChecks: Boolean=False);
var
   NewTempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   OldTempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   I: Word;
   CurIndexPos: Byte;
   IndexModified: Boolean;
   BlobModified: Boolean;
   TempRecord: TRecord;
   TempResponse: Byte;
begin
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_MODIFYRECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(RecordBuffer^,FRecordSize);
         Pack(UnlockIt,SizeOf(Boolean));
         Pack(RefreshFilter,SizeOf(Boolean));
         FlushBlobBuffers;
         EndPack;
         SendReceive;
         CheckForException;
         if UnlockIt and (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
            UnlockRecord(FCurRecordNumber,True);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      TempResponse:=ERROR_RESPONSE_RETRY;
      while (TempResponse=ERROR_RESPONSE_RETRY) do
         begin
         TempResponse:=ERROR_RESPONSE_FAIL;
         if (not FSuppressTriggers) then
            DataEngine.Trigger(TRIGGER_BEFOREUPDATE,DataSession,
                               FDataDirectory,Self,
                               FCurrentRecord.Number,
                               RecordBuffer,
                               FLastRecord.Buffer);
         try
            try
               WriteLockTable;
               try
                  BlobModified:=False;
                  if (DataSession.LockProtocol=LOCK_OPTIMISTIC) then
                     begin
                     if (not FExclusive) then
                        begin
                        if (not MD5DigestCompare(FCurrentRecord.Hash,FLastRecord.Hash)) or
                           (FCurrentRecord.Status=RECORD_DELETED) then
                           DataEngine.RaiseError(DBISAM_KEYORRECDELETED,'','',ProperDataDirectoryName,
                                                 FTableName);
                        LockRecord(FLastRecord.Number);
                        end;
                     end;
                  try
                     CurIndexPos:=FIndexPos;
                     try
                        { Use a scratch record so we don't touch the real
                          record buffer }
                        with FScratchRecord do
                           begin
                           Initialize;
                           Number:=FCurrentRecord.Number;
                           CopyBuffer(RecordBuffer);
                           end;
                        if FHasValidityChecks then
                           CheckRecordValidity(FScratchRecord.Buffer);
                        if (not SuppressRecordIDs) then
                           FScratchRecord.ID:=FCurrentRecord.ID;
                        { Don't modify the hash value if this is the cached
                          updates cursor }
                        if (not FCachedUpdates) then
                           FScratchRecord.Hash:=CalcRecordHash(FScratchRecord.Buffer);
                        IndexModified:=False;
                        if (not SkipKeyChecks) then
                           begin
                           for I:=0 to IndexCount do
                              begin
                              if IsUniqueIndex(I) then
                                 begin
                                 InternalSetIndexPos(I);
                                 GetKeyValues(FScratchRecord.Buffer,@NewTempKeyBuffer);
                                 GetKeyValues(FCurrentRecord.Buffer,@OldTempKeyBuffer);
                                 if (not (CompareKeys(@OldTempKeyBuffer,
                                                      @NewTempKeyBuffer,
                                                      FKeySize)=CMP_EQUAL)) then
                                    begin
                                    if CheckForKeyViolation(@NewTempKeyBuffer) then
                                       RaiseKeyViolationError;
                                    end;
                                 end;
                              end;
                           end;
                        { Now update the actual buffer }
                        GetRecord(FScratchRecord.Number,False,READ_CURRENT,TempRecord);
                        try
                           TempRecord.Copy(FScratchRecord);
                           { If performing cached updates, then be sure to set the
                             record modification flag }
                           if FCachedUpdates then
                              TempRecord.Status:=RECORD_MODIFIED;
                           { Be sure to increment the last record id, if necessary }
                           SetRecordID(TempRecord.Buffer,True);
                           for I:=0 to IndexCount do
                              begin
                              InternalSetIndexPos(I);
                              GetKeyValues(TempRecord.Buffer,@NewTempKeyBuffer);
                              GetKeyValues(FCurrentRecord.Buffer,@OldTempKeyBuffer);
                              if (not (CompareKeys(@OldTempKeyBuffer,
                                                   @NewTempKeyBuffer,
                                                   FKeySize)=CMP_EQUAL)) then
                                 begin
                                 UpdateIndexKey(@OldTempKeyBuffer,
                                                @NewTempKeyBuffer,TempRecord.Number);
                                 IndexModified:=True;
                                 end;
                              end;
                           if IndexModified then
                              ModifyTextIndexes(TempRecord,FCurrentRecord)
                           else
                              IndexModified:=ModifyTextIndexes(TempRecord,FCurrentRecord);
                           if (BlobFieldCount > 0) then
                              begin
                              UpdateBlobSignatures(TempRecord.Buffer,False);
                              BlobModified:=FlushBlobBuffers;
                              UpdateBlobBlocks(TempRecord.Buffer,False);
                              FreeAllBlobs(False,False);
                              end;
                           FCurrentRecord.Copy(TempRecord);
                           { Version 5 }
                           FScratchRecord.Copy(TempRecord);
                           { Version 5 }
                        finally
                           PutRecord(TempRecord);
                        end;
                        FlushBuffers(False,False,True,IndexModified,BlobModified);
                        if UnlockIt and (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
                           UnlockRecord(FCurrentRecord.Number,False);
                     finally
                        InternalSetIndexPos(CurIndexPos);
                        if RefreshFilter then
                           begin
                           RefreshRangeAndFilterUpdate(FCurrentRecord.Number,
                                                       FCurrentRecord.Buffer,
                                                       FLastRecord.Buffer);
                           RepositionCurrentRecord;
                           end;
                     end;
                  finally
                     if (DataSession.LockProtocol=LOCK_OPTIMISTIC) then
                        UnlockRecord(FLastRecord.Number,False);
                  end;
               finally
                  WriteUnlockTable;
               end;
               if (not FSuppressTriggers) then
                  { Version 5 }
                  DataEngine.Trigger(TRIGGER_AFTERUPDATE,DataSession,
                                     FDataDirectory,Self,
                                     FScratchRecord.Number,
                                     FScratchRecord.Buffer,
                                     FLastRecord.Buffer);
                  { Version 5 }
            finally
               if (not SuppressTriggers) then
                  begin
                  if (BlobFieldCount > 0) then
                     FreeBlobCopies(FLastRecord.Buffer,False);
                  end;
            end;
            FLastRecord.Initialize;
         except
            on E: Exception do
               begin
               if (not FSuppressTriggers) then
                  DataEngine.Error(ERROR_EVENT_UPDATE,
                                   DataSession,
                                   FDataDirectory,Self,
                                   FLastRecord.Number,
                                   RecordBuffer,E,TempResponse);
               case TempResponse of
                  ERROR_RESPONSE_FAIL:
                     raise;
                  ERROR_RESPONSE_ABORT:
                     Abort;
                  end;
               end;
         end;
         end;
      end;
end;

procedure TDataCursor.CancelRecord;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_CANCELRECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         if (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
            UnlockRecord(FCurRecordNumber,True);
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      if (DataSession.LockProtocol=LOCK_PESSIMISTIC) then
         UnlockRecord(FCurrentRecord.Number,False);
      FLastRecord.Initialize;
      end;
end;

procedure TDataCursor.DeleteRecord(RecordBuffer: PChar; RefreshFilter: Boolean);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   I: Word;
   CurIndexPos: Byte;
   TempRecord: TRecord;
   BlobModified: Boolean;
   TempResponse: Byte;
begin
   CheckNotReadOnly;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_DELETERECORD);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(RecordBuffer^,FRecordSize);
         Pack(RefreshFilter,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      TempResponse:=ERROR_RESPONSE_RETRY;
      while (TempResponse=ERROR_RESPONSE_RETRY) do
         begin
         TempResponse:=ERROR_RESPONSE_FAIL;
         FLastRecord.Copy(FCurrentRecord);
         { Version 5 }
         if (not FSuppressTriggers) then
            DataEngine.Trigger(TRIGGER_BEFOREDELETE,DataSession,
                               FDataDirectory,Self,
                               FCurrentRecord.Number,
                               FCurrentRecord.Buffer,
                               FLastRecord.Buffer);  // <<<<<
         { Version 5 }
         try
            try
               WriteLockTable;
               try
                  BlobModified:=False;
                  if (not FExclusive) then
                     begin
                     if (not MD5DigestCompare(FCurrentRecord.Hash,GetRecordHash(RecordBuffer))) or
                        (FCurrentRecord.Status=RECORD_DELETED) then
                        DataEngine.RaiseError(DBISAM_KEYORRECDELETED,'','',ProperDataDirectoryName,
                                                FTableName);
                     end;
                  LockRecord(FLastRecord.Number);
                  try
                     CurIndexPos:=FIndexPos;
                     try
                        GetRecord(FCurrentRecord.Number,False,READ_CURRENT,TempRecord);
                        try
                           TempRecord.Copy(FCurrentRecord);
                           for I:=0 to IndexCount do
                              begin
                              InternalSetIndexPos(I);
                              GetKeyValues(TempRecord.Buffer,@TempKeyBuffer);
                              RemoveIndexKey(@TempKeyBuffer);
                              end;
                           DecTotalRecordCount;
                           if (BlobFieldCount > 0) then
                              begin
                              DeleteAllBlobs(TempRecord.Buffer);
                              RemoveTextIndexes(TempRecord);
                              UpdateBlobSignatures(TempRecord.Buffer,True);
                              BlobModified:=FlushBlobBuffers;
                              UpdateBlobBlocks(TempRecord.Buffer,True);
                              FreeAllBlobs(False,False);
                              end
                           else
                              RemoveTextIndexes(TempRecord);
                           SetNextFreeRecord(TempRecord);
                           FCurrentRecord.Copy(TempRecord);
                        finally
                           PutRecord(TempRecord);
                        end;
                        FlushBuffers(False,False,True,True,BlobModified);
                     finally
                        InternalSetIndexPos(CurIndexPos);
                        if RefreshFilter then
                           begin
                           RefreshRangeAndFilterDelete(FCurrentRecord.Number,
                                                       RecordBuffer);
                           RepositionCurrentRecord;
                           end;
                     end;
                  finally
                     UnlockRecord(FLastRecord.Number,False);
                  end;
               finally
                  WriteUnlockTable;
               end;
               with FScratchRecord do
                  begin
                  Initialize;
                  Number:=FLastRecord.Number;
                  end;
               if (not FSuppressTriggers) then
                  DataEngine.Trigger(TRIGGER_AFTERDELETE,DataSession,
                                     FDataDirectory,Self,
                                     FScratchRecord.Number,
                                     FScratchRecord.Buffer,
                                     FLastRecord.Buffer);
            finally
               if (not FSuppressTriggers) then
                  begin
                  if (BlobFieldCount > 0) then
                     FreeBlobCopies(FLastRecord.Buffer,True);
                  end;
               FLastRecord.Initialize;
            end;
         except
            on E: Exception do
               begin
               if (not FSuppressTriggers) then
                  DataEngine.Error(ERROR_EVENT_DELETE,
                                   DataSession,
                                   FDataDirectory,Self,
                                   FLastRecord.Number,
                                   RecordBuffer,E,TempResponse);
               case TempResponse of
                  ERROR_RESPONSE_FAIL:
                     raise;
                  ERROR_RESPONSE_ABORT:
                     Abort;
                  end;
               end;
         end;
         end;
      end;
end;

function TDataCursor.GetPhysicalRecordSize: Word;
begin
   Result:=FDataTable.RecordSize;
end;

function TDataCursor.GetPhysicalFieldCount: Word;
begin
   Result:=FDataTable.FieldCount;
end;

function TDataCursor.GetBlobFieldCount: Word;
begin
   Result:=FDataTable.BlobFieldCount;
end;

procedure TDataCursor.GetField(FieldNum: Word; RecordBuffer: PChar;
                               FieldBuffer: PChar; var IsBlank: Boolean);
begin
   InternalGetField(GetFieldDefinition(FieldNum),RecordBuffer,FieldBuffer,IsBlank);
end;

procedure TDataCursor.PutField(FieldNum: Word; RecordBuffer: PChar;
                               FieldBuffer: PChar; WriteToExpressions: Boolean;
                               BlobEmpty: Boolean);
begin
   InternalPutField(GetFieldDefinition(FieldNum),RecordBuffer,FieldBuffer,
                    WriteToExpressions,BlobEmpty);
end;

procedure TDataCursor.GetPhysicalField(FieldNum: Word; RecordBuffer: PChar;
                                       FieldBuffer: PChar; var IsBlank: Boolean);
begin
   InternalGetField(GetPhysicalFieldDefinition(FieldNum),RecordBuffer,
                    FieldBuffer,IsBlank);
end;

procedure TDataCursor.PutPhysicalField(FieldNum: Word; RecordBuffer: PChar;
                                        FieldBuffer: PChar; BlobEmpty: Boolean);
begin
   InternalPutField(GetPhysicalFieldDefinition(FieldNum),RecordBuffer,
                    FieldBuffer,False,BlobEmpty);
end;

procedure TDataCursor.InternalGetField(FieldDefinition: pFieldDefinition;
                                       RecordBuffer: PChar; FieldBuffer: PChar;
                                       var IsBlank: Boolean);
begin
   with FieldDefinition^ do
      begin
      if (FieldNum=RECORDID_FIELD_NUM) then
         begin
         IsBlank:=False;
         { Version 5 }
         if (FieldBuffer <> nil) then
            Move((RecordBuffer+Offset)^,FieldBuffer^,DataSize);
         { Version 5 }
         end
      else if (FieldNum=RECORDHASH_FIELD_NUM) then
         begin
         IsBlank:=False;
         { Version 5 }
         if (FieldBuffer <> nil) then
            Move((RecordBuffer+Offset)^,FieldBuffer^,DataSize);
         { Version 5 }
         end
      else
         begin
         IsBlank:=(not Boolean((RecordBuffer+Offset)^));
         if (FieldBuffer <> nil) then
            begin
            if (DataType=TYPE_BLOB) then
               Move((RecordBuffer+Offset+FLDCHG_DATA)^,FieldBuffer^,
                     BLOBBLOCK_SIZE)
            else
               Move((RecordBuffer+Offset+FLDCHG_DATA)^,FieldBuffer^,DataSize);
            end;
         end;
      end;
end;

procedure TDataCursor.InternalPutField(FieldDefinition: pFieldDefinition;
                                       RecordBuffer: PChar; FieldBuffer: PChar;
                                       WriteToExpressions: Boolean; BlobEmpty: Boolean);
begin
   with FieldDefinition^ do
      begin
      if (ExpressionField and (not WriteToExpressions)) or
         (FieldNum=RECORDID_FIELD_NUM) or
         (FieldNum=RECORDHASH_FIELD_NUM) then
         Exit;
      if (FieldBuffer <> nil) then
         begin
         case DataType of
            TYPE_ZSTRING:
               begin
               FillChar((RecordBuffer+Offset+FLDCHG_DATA)^,DataSize,#0);
               StrLCopy((RecordBuffer+Offset+FLDCHG_DATA),FieldBuffer,(DataSize-1));
               if (SubType <> SUBTYPE_FIXED) then
                  RightTrimString((RecordBuffer+Offset+FLDCHG_DATA),#32);
               case CharCase of
                  LOWER_CASE:
                     OSLowerString(LocaleID,(RecordBuffer+Offset+FLDCHG_DATA));
                  UPPER_CASE:
                     OSUpperString(LocaleID,(RecordBuffer+Offset+FLDCHG_DATA));
                  end;
               if ((RecordBuffer+Offset+FLDCHG_DATA)^=#0) then
                  Boolean((RecordBuffer+Offset)^):=False
               else
                  Boolean((RecordBuffer+Offset)^):=True;
               end;
            TYPE_BLOB:
               begin
               Move(FieldBuffer^,(RecordBuffer+Offset+FLDCHG_DATA)^,BLOBBLOCK_SIZE);
               if (pInteger(RecordBuffer+Offset+FLDCHG_DATA)^ < 0) then
                  Boolean((RecordBuffer+Offset)^):=(not BlobEmpty)
               else if (pInteger(RecordBuffer+Offset+FLDCHG_DATA)^=0) then
                  Boolean((RecordBuffer+Offset)^):=False
               else
                  Boolean((RecordBuffer+Offset)^):=True;
               end;
            TYPE_BOOL:
               begin
               Move(FieldBuffer^,(RecordBuffer+Offset+FLDCHG_DATA)^,DataSize);
               { Workaround for Delphi 4 using High(Word) for True }
               pWordBool(RecordBuffer+Offset+FLDCHG_DATA)^:=
                     VerifyWordBool(pWordBool(RecordBuffer+Offset+FLDCHG_DATA)^);
               Boolean((RecordBuffer+Offset)^):=True;
               end;
            else
               begin
               Move(FieldBuffer^,(RecordBuffer+Offset+FLDCHG_DATA)^,DataSize);
               Boolean((RecordBuffer+Offset)^):=True;
               end;
            end;
         end
      else
         begin
         if (DataType=TYPE_BLOB) then
            begin
            FillChar((RecordBuffer+Offset+FLDCHG_DATA)^,BLOBBLOCK_SIZE,#0);
            Boolean((RecordBuffer+Offset)^):=False;
            end
         else
            begin
            FillChar((RecordBuffer+Offset+FLDCHG_DATA)^,DataSize,#0);
            Boolean((RecordBuffer+Offset)^):=False;
            end;
         end;
      if not ExpressionField then
         CalculateExpressionFields(RecordBuffer);
      end;
end;

procedure TDataCursor.VerifyBookmarkPosition(BookmarkBuffer: PChar;
                                             WasBOF: Boolean; WasEOF: Boolean);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   if FServerSynched then
      Exit;
   try
      FBOF:=WasBOF;
      FEOF:=WasEOF;
      GetBookmark(@TempKeyBuffer);
      if (CompareBookmarks(BookmarkBuffer,@TempKeyBuffer) <> CMP_EQUAL) then
         SetToBookmark(BookmarkBuffer,True,False);
   finally
      FServerSynched:=True;
   end;
end;

procedure TDataCursor.GetBookmark(BookmarkBuffer: PChar);
begin
   if IsRemote then
      begin
      if IsPhysicalNavigation then
         Move(FCurRecordNumber,BookmarkBuffer^,SizeOf(Integer))
      else
         Move(FBookmarkBuffer,BookmarkBuffer^,FKeySize);
      end
   else
      begin
      if IsPhysicalNavigation then
         Move(FCurRecordNumber,BookmarkBuffer^,SizeOf(Integer))
      else
         begin
         if (GetKey <> nil) then
            Move(GetKey^,BookmarkBuffer^,FKeySize)
         else
            FillChar(BookmarkBuffer^,FKeySize,#0);
         end;
      end;
end;

procedure TDataCursor.ClearBookmark(BookmarkBuffer: PChar);
begin
   if IsPhysicalNavigation then
      FillChar(BookmarkBuffer^,SizeOf(Integer),#0)
   else
      FillChar(BookmarkBuffer^,FKeySize,#0);
end;

function TDataCursor.SetToBookmark(BookmarkBuffer: PChar; NearSet: Boolean;
                                   SuppressChangeDetection: Boolean): Boolean;
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
begin
   Result:=False;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SETTOBOOKMARK);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(BookmarkBuffer^,BookmarkSize);
         Pack(NearSet,SizeOf(Boolean));
         Pack(SuppressChangeDetection,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      if (not SuppressChangeDetection) then
         CheckForChangeDetection;
      try
         if IsPhysicalNavigation then
            GotoPhysicalRecordNumber(pInteger(BookmarkBuffer)^)
         else
            FindIndexKey(BookmarkBuffer,True,NearSet);
         RefreshCurrentRecord(READ_FORWARD);
         VerifyCurrentRecord(READ_FORWARD);
         if NearSet then
            Result:=True
         else
            begin
            GetBookmark(@TempKeyBuffer);
            Result:=(CompareBookmarks(BookmarkBuffer,@TempKeyBuffer)=CMP_EQUAL);
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.CompareBookmarks(FirstBuffer: PChar; SecondBuffer: PChar): Integer;
begin
   if IsPhysicalNavigation then
      begin
      if (pInteger(FirstBuffer)^ > pInteger(SecondBuffer)^) then
         Result:=CMP_GREATER
      else if (pInteger(FirstBuffer)^ < pInteger(SecondBuffer)^) then
         Result:=CMP_LESS
      else
         Result:=CMP_EQUAL;
      end
   else
      Result:=CompareKeys(FirstBuffer,SecondBuffer,FKeySize);
end;

function TDataCursor.GetFieldDefinition(FieldNum: Word): pFieldDefinition;
begin
   if IsRemote then
      Result:=GetFieldDefinitionByPos(FieldNum)
   else
      begin
      if FAlteringStructure then
         Result:=GetFieldDefinitionByNumber(FieldNum)
      else
         Result:=GetFieldDefinitionByPos(FieldNum);
      end;
end;

function TDataCursor.GetPhysicalFieldDefinition(FieldNum: Word): pFieldDefinition;
begin
   if IsRemote then
      Result:=GetPhysicalFieldDefinitionByPos(FieldNum)
   else
      begin
      if FAlteringStructure then
         Result:=GetPhysicalFieldDefinitionByNumber(FieldNum)
      else
         Result:=GetPhysicalFieldDefinitionByPos(FieldNum);
      end;
end;

function TDataCursor.GetPhysicalFieldDefinitionForFieldName(const NameOfField: string): pFieldDefinition;
begin
   Result:=nil;
   if (GetFieldDefinitionByName(NameOfField)^.OriginFieldNum <> 0) then
      Result:=GetPhysicalFieldDefinition(GetFieldDefinitionByName(NameOfField)^.OriginFieldNum);
end;

function TDataCursor.GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
var
   I: Word;
begin
   Result:=nil;
   for I:=1 to FFieldCount do
      begin
      if (FFieldDefinitions[I]^.FieldNum=FieldNum) then
         begin
         Result:=FFieldDefinitions[I];
         Exit;
         end;
      end;
   DataEngine.RaiseError(DBISAM_OUTOFRANGE,'','',ProperDataDirectoryName,
                           FTableName,IntToStr(FieldNum));
end;

function TDataCursor.GetPhysicalFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
begin
   Result:=FDataTable.GetFieldDefinitionByNumber(FieldNum);
end;

function TDataCursor.GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
begin
   Result:=nil;
   if (FieldIndex > 0) and (FieldIndex <= FFieldCount) then
      Result:=FFieldDefinitions[FieldIndex]
   else
      DataEngine.RaiseError(DBISAM_OUTOFRANGE,'','',ProperDataDirectoryName,
                              FTableName,'',IntToStr(FieldIndex));
end;

function TDataCursor.GetPhysicalFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
begin
   Result:=FDataTable.GetFieldDefinitionByPos(FieldIndex);
end;

function TDataCursor.FieldExists(NameOfField: string): Boolean;
var
   I: Word;
begin
   Result:=False;
   for I:=1 to FFieldCount do
      begin
      if (AnsiCompareText(FFieldDefinitions[I]^.FieldName,NameOfField)=0) then
         begin
         Result:=True;
         Exit;
         end;
      end;
end;

function TDataCursor.GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
var
   I: Word;
begin
   Result:=nil;
   for I:=1 to FFieldCount do
      begin
      if (AnsiCompareText(FFieldDefinitions[I]^.FieldName,NameOfField)=0) then
         begin
         Result:=FFieldDefinitions[I];
         Exit;
         end;
      end;
   DataEngine.RaiseError(DBISAM_OUTOFRANGE,'','',ProperDataDirectoryName,
                           FTableName,NameOfField);
end;

function TDataCursor.GetPhysicalFieldDefinitionByName(NameOfField: string): pFieldDefinition;
begin
   Result:=FDataTable.GetFieldDefinitionByName(NameOfField);
end;

function TDataCursor.GetPhysicalFieldNumber(NameOfField: string): Word;
begin
   Result:=FDataTable.GetFieldNumber(NameOfField);
end;

procedure TDataCursor.UpdateFieldDefinitionByPos(FieldIndex: Word;
                                                 Buffer: pFieldDefinition);
begin
   if (FieldIndex > 0) and (FieldIndex <= FFieldCount) then
      FFieldDefinitions[FieldIndex]^:=Buffer^
   else
      DataEngine.RaiseError(DBISAM_OUTOFRANGE,'','',ProperDataDirectoryName,
                              FTableName,'',IntToStr(FieldIndex));
end;

procedure TDataCursor.UpdatePhysicalFieldDefinitionByPos(FieldIndex: Word;
                                                          Buffer: pFieldDefinition);
begin
   FDataTable.UpdateFieldDefinitionByPos(FieldIndex,Buffer);
end;

function TDataCursor.GetIndexDefinition(CurIndexPos: Byte): pIndexDefinition;
begin
   Result:=FDataTable.GetIndexDefinition(CurIndexPos);
end;

procedure TDataCursor.FreeBuffers(AdjustBuffers: Boolean; ReadHeaders: Boolean;
                                  ReadIndexes: Boolean);
begin
   FDataTable.FreeBuffers(AdjustBuffers,ReadHeaders,ReadIndexes);
end;

procedure TDataCursor.FlushBuffers(ForceFlush: Boolean;
                                   AdjustBuffers: Boolean;
                                   ForceDataHeader: Boolean;
                                   ForceIndexHeader: Boolean;
                                   ForceBlobHeader: Boolean);
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_FLUSHBUFFERS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(ForceFlush,SizeOf(Boolean));
         Pack(AdjustBuffers,SizeOf(Boolean));
         Pack(ForceDataHeader,SizeOf(Boolean));
         Pack(ForceIndexHeader,SizeOf(Boolean));
         Pack(ForceBlobHeader,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      if (not Exclusive) or ForceFlush then
         FDataTable.FlushBuffers(AdjustBuffers,ForceDataHeader,
                                 ForceIndexHeader,ForceBlobHeader,False)
      else
         FDataTable.UpdateHeaderStamps(ForceDataHeader,ForceIndexHeader,
                                       ForceBlobHeader);
      SynchLastUpdateStamps;
      end;
end;


procedure TDataCursor.FlushOSBuffers;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_FLUSHOSBUFFERS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      FDataTable.FlushOSBuffers;
end;

function TDataCursor.RecordIsLocked: Boolean;
begin
   if IsRemote then
      Result:=FDataTable.RecordIsLocked(FCurRecordNumber)
   else
      Result:=FDataTable.RecordIsLocked(FCurrentRecord.Number);
end;

function TDataCursor.TableIsLocked: Boolean;
begin
   Result:=FDataTable.TableIsLocked;
end;

procedure TDataCursor.LockRecord(RecordToLock: Integer);
var
   TempResult: Boolean;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if (not IsRemote) then
         begin
         if (RecordToLock=0) then
            RecordToLock:=FCurrentRecord.Number;
         end;
      TempResult:=FDataTable.LockRecord(RecordToLock);
      if (not IsRemote) then
         begin
         if TempResult or PerformChangeDetection then
            begin
            SynchLastUpdateStamps;
            RefreshRangeAndFilters;
            RepositionCurrentRecord;
            end;
         end;
      end;
end;

procedure TDataCursor.UnlockRecord(RecordToUnlock: Integer;
                                   NoRemoteCall: Boolean);
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if IsRemote then
         begin
         if (not NoRemoteCall) then
            begin
            StartRemoteRequest;
            try
               CheckForConnection;
               SetRequestCode(REQUEST_UNLOCKRECORD);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               Pack(FBookmarkBuffer,BookmarkSize);
               Pack(FBOF,SizeOf(Boolean));
               Pack(FEOF,SizeOf(Boolean));
               Pack(RecordToUnlock,SizeOf(Integer));
               EndPack;
               SendReceive;
               CheckForException;
            finally
               EndRemoteRequest;
            end;
            end;
         FDataTable.UnlockRecord(RecordToUnlock);
         end
      else
         FDataTable.UnlockRecord(RecordToUnlock);
      end;
end;

procedure TDataCursor.LockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_LOCKTABLE);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            UnpackCursorInfo;
            FDataTable.LockTable;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         if FDataTable.LockTable or PerformChangeDetection then
            begin
            SynchLastUpdateStamps;
            RefreshRangeAndFilters;
            RepositionCurrentRecord;
            end;
         end;
      end;
end;

procedure TDataCursor.UnlockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_UNLOCKTABLE);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
         finally
            EndRemoteRequest;
         end;
         end;
      FDataTable.UnlockTable;
      end;
end;

procedure TDataCursor.WriteLockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if FDataTable.WriteLockTable or PerformChangeDetection then
         begin
         SynchLastUpdateStamps;
         RefreshRangeAndFilters;
         RepositionCurrentRecord;
         end;
      end;
end;

procedure TDataCursor.WriteUnlockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      FDataTable.WriteUnlockTable;
end;

procedure TDataCursor.ReadLockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      begin
      if FDataTable.ReadLockTable or PerformChangeDetection or HasCallbackFilters then
         begin
         SynchLastUpdateStamps;
         RefreshRangeAndFilters;
         RepositionCurrentRecord;
         end;
      end;
end;

{ Version 5 }
function TDataCursor.InternalReadLockTable: Boolean;
begin
   Result:=False;
   if (not (FExclusive or FMarkedReadOnly)) then
      Result:=FDataTable.ReadLockTable;
end;
{ Version 5 }

procedure TDataCursor.ReadUnlockTable;
begin
   if (not (FExclusive or FMarkedReadOnly)) then
      FDataTable.ReadUnlockTable;
end;

function TDataCursor.LockSemaphore(SemaphoreToLock: Integer): Boolean;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_LOCKSEMAPHORE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(SemaphoreToLock,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end
   else
      Result:=FDataTable.LockSemaphore(SemaphoreToLock);
end;

function TDataCursor.UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_UNLOCKSEMAPHORE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(SemaphoreToUnlock,SizeOf(Integer));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(Result);
      finally
         EndRemoteRequest;
      end;
      end
   else
      Result:=FDataTable.UnlockSemaphore(SemaphoreToUnlock);
end;

function TDataCursor.GetTableSize: Int64;
begin
   Result:=0;
   if FIsOpen then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_TABLESIZE);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(Result);
         finally
            EndRemoteRequest;
         end;
         end
      else
         Result:=(DataFileSize+IndexFileSize+BlobFileSize);
      end;
end;

function TDataCursor.GetDataFileSize: Int64;
begin
   Result:=FDataTable.DataFileSize;
end;

function TDataCursor.GetIndexFileSize: Int64;
begin
   Result:=FDataTable.IndexFileSize;
end;

function TDataCursor.GetBlobFileSize: Int64;
begin
   Result:=FDataTable.BlobFileSize;
end;

function TDataCursor.GetCurrentRecordBuffer: PChar;
begin
   Result:=FCurrentRecord.Buffer;
end;

procedure TDataCursor.SetToDataCursor(SourceDataCursor: TDataCursor);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempResult: Boolean;
begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SETTOCURSOR);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(SourceDataCursor.RemoteID,SizeOf(Integer));
         Pack(SourceDataCursor.FBookmarkBuffer,SourceDataCursor.BookmarkSize);
         Pack(SourceDataCursor.FBOF,SizeOf(Boolean));
         Pack(SourceDataCursor.FEOF,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      CheckForChangeDetection;
      try
         GetKeyValues(SourceDataCursor.CurrentRecordBuffer,
                      @TempKeyBuffer);
         { Version 5 }
         TempResult:=FindIndexKey(@TempKeyBuffer,False,False);
         RefreshCurrentRecord(READ_CURRENT);
         VerifyCurrentRecord(READ_CURRENT);
         TempResult:=(TempResult and CompareCurrentRecordToKey(@TempKeyBuffer,FKeySize));
         if (not TempResult) then
            DataEngine.RaiseError(DBISAM_RECNOTFOUND,'','',ProperDataDirectoryName,
                                  FTableName);
         { Version 5 }
      finally
         ReadUnlockTable;
      end;
      end;
end;

function TDataCursor.ImportTable(const FileToImport: string;
                                 Delimiter: Char;
                                 NumberOfFields: Word;
                                 var FieldDefinitions: array of pFieldDefinition;
                                 const DateFormat: string;
                                 const TimeFormat: string;
                                 DecSeparator: Char;
                                 ReadHeaders: Boolean;
                                 SendProgress: Boolean): Integer;
var
   ImportParser: TImportParser;
   TempRecordBuffer: PChar;
   ImportFile: TEngineFile;
   ImportBuffer: PChar;
   ImportPtr: PChar;
   ImportBytesToRead: Integer;
   ImportBytesLeft: Integer;
   CurImportBytes: Integer;
   TotalImportBytes: Integer;
   FileImportBytes: Integer;
   ImportDone: Boolean;
   CurFldNum: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   DataFound: Boolean;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   I: Integer;
   FirstRecord: Boolean;
begin
   Result:=0;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_IMPORTTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(FileToImport[1],Length(FileToImport));
         Pack(Delimiter,SizeOf(Char));
         Pack(NumberOfFields,SizeOf(Word));
         for I:=0 to NumberOfFields-1 do
            Pack(FieldDefinitions[I]^,SizeOf(TFieldDefinition));
         Pack(DateFormat[1],Length(DateFormat));
         Pack(TimeFormat[1],Length(TimeFormat));
         Pack(DecSeparator,SizeOf(Char));
         Pack(ReadHeaders,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      try
         ImportFile:=TEngineFile.Create(Self);
         try
            with ImportFile do
               begin
               FileName:=FileToImport;
               Exclusive:=True;
               ReadOnly:=True;
               OpenFile;
               FileImportBytes:=GetSize;
               end;
            ImportParser:=TImportParser.Create(Self);
            try
               ImportBuffer:=AllocMem(IMPORT_READ_SIZE+1);
               try
                  TempRecordBuffer:=AllocMem(FRecordSize);
                  try
                     InitRecord(TempRecordBuffer);
                     TotalImportBytes:=0;
                     ImportDone:=False;
                     CurFldNum:=0;
                     DataFound:=False;
                     TempLastPercentDone:=0;
                     ImportPtr:=ImportBuffer;
                     FirstRecord:=True;
                     while (not ImportDone) do
                        begin
                        if (ImportPtr <> ImportBuffer) then
                           begin
                           ImportBytesToRead:=(ImportPtr-ImportBuffer);
                           ImportBytesLeft:=(IMPORT_READ_SIZE-ImportBytesToRead);
                           Move(ImportPtr^,ImportBuffer^,ImportBytesLeft);
                           end
                        else
                           begin
                           ImportBytesToRead:=IMPORT_READ_SIZE;
                           ImportBytesLeft:=0;
                           end;
                        FillChar((ImportBuffer+ImportBytesLeft)^,ImportBytesToRead,#0);
                        CurImportBytes:=ImportFile.Read((ImportBuffer+ImportBytesLeft)^,ImportBytesToRead,True);
                        if (CurImportBytes < ImportBytesToRead) then
                           ImportDone:=True;
                        Inc(TotalImportBytes,CurImportBytes);
                        with ImportParser do
                           begin
                           FieldDelimiter:=Delimiter;
                           ErrorCode:=DBISAM_IMPORTERROR;
                           ErrorTableName:=FTableName;
                           ErrorContext:='import data';
                           SetExpression(ImportBuffer);
                           NextToken;
                           if (NumberOfFields=0) and (not ReadHeaders) then
                              InvalidError('No fields specified');
                           while True do
                              begin
                              if CheckToken(PARSE_CR) then
                                 begin
                                 NextToken;
                                 if CheckToken(PARSE_LF) then
                                    begin
                                    IncLine;
                                    if DataFound then
                                       begin
                                       if (not (FirstRecord and ReadHeaders)) then
                                          begin
                                          AppendRecord(TempRecordBuffer,False);
                                          Inc(Result);
                                          end;
                                       end
                                    else
                                       begin
                                       if (FirstRecord and ReadHeaders) then
                                          InvalidError('No fields specified');
                                       end;
                                    FirstRecord:=False;
                                    InitRecord(TempRecordBuffer);
                                    CurFldNum:=0;
                                    DataFound:=False;
                                    { Skip over LF from above by adding 1 to TokenPtr }
                                    if (StrPos((TokenPtr+1),PARSE_CRLF)=nil) and
                                       (not ImportDone) then
                                       begin
                                       ImportPtr:=(TokenPtr+1);
                                       Break;
                                       end
                                    else
                                       NextToken;
                                    end
                                 else
                                    ExpectedTokenError(PARSE_LF);
                                 end
                              else if CheckToken(PARSE_TERM) then
                                 begin
                                 if ImportDone then
                                    begin
                                    if DataFound and (not (FirstRecord and ReadHeaders)) then
                                       begin
                                       AppendRecord(TempRecordBuffer,False);
                                       Inc(Result);
                                       end;
                                    end
                                 else
                                    InvalidExpressionError;
                                 Break;
                                 end
                              else if CheckToken(Delimiter) then
                                 begin
                                 DataFound:=True;
                                 Inc(CurFldNum);
                                 NextToken;
                                 end
                              else
                                 begin
                                 if (FirstRecord and ReadHeaders) then
                                    begin
                                    DataFound:=True;
                                    FieldDefinitions[CurFldNum]:=AllocMem(SizeOf(TFieldDefinition));
                                    Inc(NumberOfFields);
                                    FieldDefinitions[CurFldNum]^:=GetFieldDefinitionByName(TokenAsString)^;
                                    end
                                 else
                                    begin
                                    if (CurFldNum >= NumberOfFields) then
                                       InvalidError('Invalid number of fields');
                                    if (FieldDefinitions[CurFldNum] <> nil) then
                                       begin
                                       DataFound:=True;
                                       StrPCopy(@TempFieldBuffer,Substr(TokenAsString,1,MAX_FIELD_SIZE));
                                       with FieldDefinitions[CurFldNum]^ do
                                          begin
                                          if (DataType <> TYPE_BLOB) then
                                             begin
                                             case DataType of
                                                TYPE_DATE,TYPE_TIME,TYPE_TIMESTAMP:
                                                   begin
                                                   if ConvertFormatToDateTime(@TempFieldBuffer,DataType,
                                                                              DateFormat,TimeFormat) then
                                                      PutField(FieldNum,TempRecordBuffer,
                                                               @TempFieldBuffer,False,False)
                                                   else
                                                      InvalidExpressionError;
                                                   end;
                                                TYPE_FLOAT,TYPE_BCD:
                                                   begin
                                                   if ConvertFormatToNumber(@TempFieldBuffer,DataType,
                                                                            DataDecimals,DecSeparator) then
                                                      PutField(FieldNum,TempRecordBuffer,
                                                               @TempFieldBuffer,False,False)
                                                   else
                                                      InvalidExpressionError;
                                                   end;
                                                else
                                                   begin
                                                   if ConvertExpression(TYPE_ZSTRING,System.Length(TokenAsString),0,
                                                                        DataType,DataSize,DataDecimals,
                                                                        @TempFieldBuffer) then
                                                      PutField(FieldNum,TempRecordBuffer,
                                                               @TempFieldBuffer,False,False)
                                                   else
                                                      InvalidExpressionError;
                                                   end;
                                                end;
                                             end
                                          else
                                             PutField(FieldNum,TempRecordBuffer,
                                                      nil,False,False);
                                          end;
                                       end;
                                    end;
                                 NextToken;
                                 end;
                              end;
                           end;
                        TempPercentDone:=Trunc(((TotalImportBytes/FileImportBytes)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           Self.DoProgress(TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     if (TempLastPercentDone <> 100) then
                        Self.DoProgress(100);
                  finally
                     DeAllocMem(TempRecordBuffer);
                     if ReadHeaders then
                        begin
                        for I:=0 to NumberOfFields-1 do
                           DeAllocMem(FieldDefinitions[I]);
                        end;
                  end;
               finally
                  DeAllocMem(ImportBuffer);
               end;
            finally
               ImportParser.Free;
            end;
         finally
            ImportFile.Free;
         end;
      finally
         ForceRefresh;
      end;
      end;
end;

function TDataCursor.ExportTable(const ExportToFile: string;
                                 Delimiter: Char;
                                 NumberOfFields: Word;
                                 const FieldDefinitions: array of pFieldDefinition;
                                 const DateFormat: string;
                                 const TimeFormat: string;
                                 DecSeparator: Char;
                                 WriteHeaders: Boolean;
                                 SendProgress: Boolean): Integer;
var
   ExportFile: TEngineFile;
   ExportBuffer: PChar;
   CurExportBytes: Integer;
   CurFldNum: Word;
   TempFieldBuffer: array [0..MAX_EXPORT_SIZE] of Char;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempRecordNumber: Integer;
   TempRecordBuffer: PChar;
   IsBlank: Boolean;
   FieldLen: Word;
   I: Integer;
   WriteData: Boolean;
begin
   Result:=0;
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_EXPORTTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         Pack(ExportToFile[1],Length(ExportToFile));
         Pack(Delimiter,SizeOf(Char));
         Pack(NumberOfFields,SizeOf(Word));
         for I:=0 to NumberOfFields-1 do
            Pack(FieldDefinitions[I]^,SizeOf(TFieldDefinition));
         Pack(DateFormat[1],Length(DateFormat));
         Pack(TimeFormat[1],Length(TimeFormat));
         Pack(DecSeparator,SizeOf(Char));
         Pack(WriteHeaders,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      if (NumberOfFields=0) then
         DataEngine.RaiseError(DBISAM_EXPORTERROR,'','',
                               ProperDataDirectoryName,ProperTableName,'','',
                               'No fields specified for export data');
      ExportFile:=TEngineFile.Create(Self);
      try
         with ExportFile do
            begin
            FileName:=ExportToFile;
            Exclusive:=True;
            ReadOnly:=False;
            CreateFile;
            end;
         ExportBuffer:=AllocMem(EXPORT_WRITE_SIZE+1);
         try
            IsBlank:=False;
            TempLastPercentDone:=0;
            TempRecordNumber:=0;
            SetToBegin;
            CurExportBytes:=0;
            TempRecordBuffer:=AllocMem(FRecordSize);
            try
               while True do
                  begin
                  if (WriteHeaders and (TempRecordNumber=0)) or
                     (TempRecordNumber > 0) then
                     begin
                     for CurFldNum:=0 to NumberOfFields-1 do
                        begin
                        FillChar(TempFieldBuffer,SizeOf(TempFieldBuffer),#0);
                        FieldLen:=0;
                        WriteData:=True;
                        if WriteHeaders and (TempRecordNumber=0) then
                           begin
                           with FieldDefinitions[CurFldNum]^ do
                              StrPCopy(@TempFieldBuffer,FieldName);
                           FieldLen:=StrLen(@TempFieldBuffer);
                           end
                        else if (TempRecordNumber > 0) then
                           begin
                           with FieldDefinitions[CurFldNum]^ do
                              begin
                              if (DataType <> TYPE_BLOB) then
                                 begin
                                 GetField(FieldNum,TempRecordBuffer,
                                          @TempFieldBuffer,IsBlank);
                                 if (not IsBlank) then
                                    begin
                                    case DataType of
                                       TYPE_DATE,TYPE_TIME,TYPE_TIMESTAMP:
                                          begin
                                          if (not ConvertDateTimeToFormat(@TempFieldBuffer,DataType,
                                                                          DateFormat,TimeFormat)) then
                                             DataEngine.RaiseError(DBISAM_EXPORTERROR,'','',
                                                                   ProperDataDirectoryName,ProperTableName,FieldName,'',
                                                                   'Error exporting data value');
                                          end;
                                       TYPE_FLOAT,TYPE_BCD:
                                          begin
                                          if (not ConvertNumberToFormat(@TempFieldBuffer,DataType,
                                                                        DecSeparator)) then
                                             DataEngine.RaiseError(DBISAM_EXPORTERROR,'','',
                                                                   ProperDataDirectoryName,ProperTableName,FieldName,'',
                                                                   'Error exporting data value');
                                          end;
                                       else
                                          begin
                                          if (not ConvertExpression(DataType,DataSize,DataDecimals,
                                                                    TYPE_ZSTRING,(MAX_FIELD_SIZE+1),0,
                                                                    @TempFieldBuffer)) then
                                             DataEngine.RaiseError(DBISAM_EXPORTERROR,'','',
                                                                   ProperDataDirectoryName,ProperTableName,FieldName,'',
                                                                   'Error exporting data value');
                                          end;
                                       end;
                                    FieldLen:=StrLen(@TempFieldBuffer);
                                    { Be sure to make certain field types quoted }
                                    if (DataType=TYPE_ZSTRING) then
                                       begin
                                       { Handle embedded quotes first }
                                       I:=0;
                                       while (I <= FieldLen) do
                                          begin
                                          if (TempFieldBuffer[I]=PARSE_DOUBLEQUOTE) then
                                             begin
                                             Move(TempFieldBuffer[I],TempFieldBuffer[I+1],(FieldLen+1));
                                             TempFieldBuffer[I]:=PARSE_DOUBLEQUOTE;
                                             Inc(FieldLen);
                                             Inc(I);
                                             end;
                                          Inc(I);
                                          end;
                                       Move(TempFieldBuffer[0],TempFieldBuffer[1],(FieldLen+1));
                                       Inc(FieldLen);
                                       TempFieldBuffer[0]:=PARSE_DOUBLEQUOTE;
                                       TempFieldBuffer[FieldLen]:=PARSE_DOUBLEQUOTE;
                                       Inc(FieldLen);
                                       end;
                                    end;
                                 end;
                              end;
                           end
                        else
                           WriteData:=False;
                        if WriteData then
                           begin
                           if (CurFldNum=(NumberOfFields-1)) then
                              begin
                              TempFieldBuffer[FieldLen]:=PARSE_CR;
                              Inc(FieldLen);
                              TempFieldBuffer[FieldLen]:=PARSE_LF;
                              Inc(FieldLen);
                              end
                           else
                              begin
                              TempFieldBuffer[FieldLen]:=Delimiter;
                              Inc(FieldLen);
                              end;
                           if ((CurExportBytes+FieldLen) >= EXPORT_WRITE_SIZE) then
                              begin
                              ExportFile.Write(ExportBuffer^,CurExportBytes);
                              FillChar(ExportBuffer^,(EXPORT_WRITE_SIZE+1),#0);
                              CurExportBytes:=0;
                              end;
                           StrCopy((ExportBuffer+CurExportBytes),@TempFieldBuffer);
                           Inc(CurExportBytes,FieldLen);
                           end;
                        end;
                     if (RecordCount > 0) then
                        begin
                        TempPercentDone:=Trunc(((TempRecordNumber/RecordCount)*100));
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           DoProgress(TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     end;
                  Inc(TempRecordNumber);
                  if (GetNextRecord(TempRecordBuffer) <> DBISAM_NONE) then
                     Break;
                  end;
               if (CurExportBytes > 0) then
                  ExportFile.Write(ExportBuffer^,CurExportBytes);
               Result:=TempRecordNumber-1;
               if (TempLastPercentDone <> 100) then
                  DoProgress(100);
            finally
               DeAllocMem(TempRecordBuffer);
            end;
         finally
            DeAllocMem(ExportBuffer);
         end;
      finally
         ExportFile.Free;
      end;
      end;
end;

procedure TDataCursor.LoadFromStream(SourceBuffer: PChar;
                                     SourceBufferSize: Integer;
                                     Mode: Byte;
                                     SendProgress: Boolean;
                                     SendErrors: Boolean);
var
   TempRecordBuffer: PChar;
   TempSaveRecordBuffer: PChar;
   TempOldRecordBuffer: PChar;
   TempResponse: Byte;
   LoadPos: Integer;
   LoadBytesLeft: Integer;
   TempEngineVersion: Currency;
   TempFieldCount: Word;
   TempFieldDefinitions: array [1..MAX_NUM_FIELDS] of pFieldDefinition;
   TempFieldDataTypes: array [1..MAX_NUM_FIELDS] of Byte;
   TempFieldDataSizes: array [1..MAX_NUM_FIELDS] of Word;
   TempFieldDataDecimals: array [1..MAX_NUM_FIELDS] of Byte;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   TempFieldName: string;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   I: Integer;
   TempBlobSize: Integer;
   TempInteger: Integer;
   IsBlank: Boolean;
   SaveIndexPos: Byte;
   SaveRangeInEffect: Boolean;
   TempRecordNumber: Integer;
   TempRecordID: Integer;
   TempStatus: Byte;
   TempRecordHash: TMD5Digest;
   TempLocked: Boolean;
   TempRetry: Boolean;
   TempOperation: Byte;

      procedure PopulateRecordStats;
      begin
         TempRecordNumber:=0;
         TempRecordID:=0;
         TempStatus:=RECORD_VALID;
         if (Mode <> STREAM_NORMAL) then
            begin
            TempRecordNumber:=pInteger(SourceBuffer+LoadPos)^;
            Inc(LoadPos,SizeOf(Integer));
            Dec(LoadBytesLeft,SizeOf(Integer));
            TempRecordID:=pInteger(SourceBuffer+LoadPos)^;
            Inc(LoadPos,SizeOf(Integer));
            Dec(LoadBytesLeft,SizeOf(Integer));
            if (TempEngineVersion >= 4.18) then
               begin
               TempRecordHash:=pMD5Digest(SourceBuffer+LoadPos)^;
               Inc(LoadPos,SizeOf(TMD5Digest));
               Dec(LoadBytesLeft,SizeOf(TMD5Digest));
               end
            else
               FillChar(TempRecordHash,SizeOf(TMD5Digest),#0);
            TempStatus:=Byte((SourceBuffer+LoadPos)^);
            Inc(LoadPos,SizeOf(Byte));
            Dec(LoadBytesLeft,SizeOf(Byte));
            end;
      end;

      procedure PopulateRecordBuffer;
      var
         I: Integer;
      begin
         for I:=1 to TempFieldCount do
            begin
            with TempFieldDefinitions[I]^ do
               begin
               if (LoadBytesLeft < FLDCHG_DATA) then
                  DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                        ProperDataDirectoryName,ProperTableName,FieldName,'',
                                        'Invalid NULL byte in stream data');
               IsBlank:=(not Boolean((SourceBuffer+LoadPos)^));
               Inc(LoadPos,FLDCHG_DATA);
               Dec(LoadBytesLeft,FLDCHG_DATA);
               if (not IsBlank) then
                  begin
                  if (DataType <> TYPE_BLOB) then
                     begin
                     if (LoadBytesLeft < DataSize) then
                        DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                              ProperDataDirectoryName,ProperTableName,FieldName,'',
                                              'Invalid data value in stream data');
                     if (TempStatus <> RECORD_DELETED) then
                        begin
                        Move((SourceBuffer+LoadPos)^,TempFieldBuffer,DataSize);
                        if (TempFieldDataTypes[I] <> DataType) or
                           (TempFieldDataSizes[I] <> DataSize) then
                           begin
                           if (not ConvertExpression(TempFieldDataTypes[I],
                                                     TempFieldDataSizes[I],
                                                     TempFieldDataDecimals[I],
                                                     DataType,DataSize,DataDecimals,
                                                     @TempFieldBuffer)) then
                              DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                                    ProperDataDirectoryName,ProperTableName,FieldName,'',
                                                    'Invalid data value in stream data');
                           end;
                        PutField(FieldNum,TempRecordBuffer,@TempFieldBuffer,True,False);
                        end;
                     Inc(LoadPos,TempFieldDataSizes[I]);
                     Dec(LoadBytesLeft,TempFieldDataSizes[I]);
                     end
                  else
                     begin
                     if (TempFieldDataTypes[I] <> DataType) then
                        DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                              ProperDataDirectoryName,ProperTableName,FieldName,'',
                                              'Invalid data value in stream data');
                     if (LoadBytesLeft < SizeOf(Integer)) then
                        DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                              ProperDataDirectoryName,ProperTableName,FieldName,'',
                                              'Invalid BLOB field size in stream data');
                     TempBlobSize:=pInteger(SourceBuffer+LoadPos)^;
                     Inc(LoadPos,SizeOf(Integer));
                     Dec(LoadBytesLeft,SizeOf(Integer));
                     if (TempStatus <> RECORD_DELETED) then
                        begin
                        if (LoadBytesLeft < TempBlobSize) then
                           DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                                 ProperDataDirectoryName,ProperTableName,FieldName,'',
                                                 'Invalid BLOB data value in stream data');
                        OpenBlob(FieldNum,TempRecordBuffer,BLOB_OPENREADWRITE,
                                 False,True,TempInteger,False);
                        PutBlob(FieldNum,TempRecordBuffer,0,(SourceBuffer+LoadPos),
                                TempBlobSize,False);
                        end;
                     Inc(LoadPos,TempBlobSize);
                     Dec(LoadBytesLeft,TempBlobSize);
                     end;
                  end
               else
                  begin
                  if (TempStatus <> RECORD_DELETED) then
                     PutField(FieldNum,TempRecordBuffer,nil,True,False);
                  end;
               end;
            end;
      end;

begin
   if (SourceBufferSize > 0) then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_LOADFROMSTREAM);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(SourceBufferSize,SizeOf(Integer));
            Pack(SourceBuffer^,SourceBufferSize);
            if (RemoteEngineVersion >= 4.17) then
               Pack(Mode,SizeOf(Byte));
            Pack(SendProgress,SizeOf(Boolean));
            if (RemoteEngineVersion >= 4.17) then
               Pack(SendErrors,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            UnpackCursorInfo;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         LoadPos:=0;
         LoadBytesLeft:=SourceBufferSize;
         TempLastPercentDone:=0;
         if (LoadBytesLeft < SizeOf(TMD5Digest)) or
            ((not MD5DigestCompare(pMD5Digest(SourceBuffer+LoadPos)^,DataEngine.SignatureDigest)) and
             (not MD5DigestCompare(pMD5Digest(SourceBuffer+LoadPos)^,MD5String(DBISAM_SIGNATURE)))) then
            DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                  ProperDataDirectoryName,ProperTableName,'','',
                                  'Invalid signature in stream data');
         Inc(LoadPos,SizeOf(TMD5Digest));
         Dec(LoadBytesLeft,SizeOf(TMD5Digest));
         if (LoadBytesLeft < SizeOf(Currency)) then
            DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                  ProperDataDirectoryName,ProperTableName,'','',
                                  'Invalid engine version number in stream data');
         TempEngineVersion:=pCurrency(SourceBuffer+LoadPos)^;
         Inc(LoadPos,SizeOf(Currency));
         Dec(LoadBytesLeft,SizeOf(Currency));
         FillChar(TempFieldDefinitions,SizeOf(TempFieldDefinitions),#0);
         FillChar(TempFieldDataTypes,SizeOf(TempFieldDataTypes),#0);
         FillChar(TempFieldDataSizes,SizeOf(TempFieldDataSizes),#0);
         FillChar(TempFieldDataDecimals,SizeOf(TempFieldDataDecimals),#0);
         if (LoadBytesLeft < SizeOf(Word)) or
            (pWord(SourceBuffer+LoadPos)^ > MAX_NUM_FIELDS) then
            DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                  ProperDataDirectoryName,ProperTableName,'','',
                                  'Invalid field count in stream data');
         TempFieldCount:=pWord(SourceBuffer+LoadPos)^;
         Inc(LoadPos,SizeOf(Word));
         Dec(LoadBytesLeft,SizeOf(Word));
         for I:=1 to TempFieldCount do
            begin
            if (LoadBytesLeft < SizeOf(Byte)) then
               DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                     ProperDataDirectoryName,ProperTableName,'','',
                                     'Invalid field definitions in stream data');
            TempFieldDataTypes[I]:=Byte((SourceBuffer+LoadPos)^);
            Inc(LoadPos,SizeOf(Byte));
            Dec(LoadBytesLeft,SizeOf(Byte));
            if (TempEngineVersion < 4.02) then
               begin
               if (LoadBytesLeft < SizeOf(Byte)) then
                  DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                        ProperDataDirectoryName,ProperTableName,'','',
                                        'Invalid field definitions in stream data');
               TempFieldDataSizes[I]:=Byte((SourceBuffer+LoadPos)^);
               Inc(LoadPos,SizeOf(Byte));
               Dec(LoadBytesLeft,SizeOf(Byte));
               end
            else
               begin
               if (LoadBytesLeft < SizeOf(Word)) then
                  DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                        ProperDataDirectoryName,ProperTableName,'','',
                                        'Invalid field definitions in stream data');
               TempFieldDataSizes[I]:=pWord(SourceBuffer+LoadPos)^;
               Inc(LoadPos,SizeOf(Word));
               Dec(LoadBytesLeft,SizeOf(Word));
               end;
            if (LoadBytesLeft < SizeOf(Byte)) then
               DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                     ProperDataDirectoryName,ProperTableName,'','',
                                     'Invalid field definitions in stream data');
            TempFieldDataDecimals[I]:=Byte((SourceBuffer+LoadPos)^);
            Inc(LoadPos,SizeOf(Byte));
            Dec(LoadBytesLeft,SizeOf(Byte));
            if (LoadBytesLeft < SizeOf(Byte)) then
               DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                     ProperDataDirectoryName,ProperTableName,'','',
                                     'Invalid field definitions in stream data');
            TempFieldName[0]:=(SourceBuffer+LoadPos)^;
            Inc(LoadPos,SizeOf(Byte));
            Dec(LoadBytesLeft,SizeOf(Byte));
            if (LoadBytesLeft < Byte(TempFieldName[0])) then
               DataEngine.RaiseError(DBISAM_LOADSTREAMERROR,'','',
                                     ProperDataDirectoryName,ProperTableName,'','',
                                     'Invalid field definitions in stream data');
            Move((SourceBuffer+LoadPos)^,TempFieldName[1],Byte(TempFieldName[0]));
            TempFieldDefinitions[I]:=GetFieldDefinitionByName(TempFieldName);
            Inc(LoadPos,Byte(TempFieldName[0]));
            Dec(LoadBytesLeft,Byte(TempFieldName[0]));
            { Version 5 }
            TempPercentDone:=Trunc(((LoadPos/SourceBufferSize)*100));
            { Version 5 }
            if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
               begin
               DoProgress(TempPercentDone);
               TempLastPercentDone:=TempPercentDone;
               end;
            end;
         if (LoadBytesLeft > 0) then
            begin
            SaveIndexPos:=FIndexPos;
            SaveRangeInEffect:=FRangeInEffect;
            if (Mode=STREAM_FROM_CACHE) then
               begin
               InternalSetIndexPos(PHYSICAL_INDEX_POS);
               FRangeInEffect:=False;
               end;
            { Version 5 }
            FSuppressRecordIDs:=(Mode=STREAM_TO_CACHE);
            { Version 5 }
            try
               TempRecordBuffer:=AllocMem(FRecordSize);
               TempSaveRecordBuffer:=AllocMem(FRecordSize);
               TempOldRecordBuffer:=AllocMem(FRecordSize);
               try
                  while True do
                     begin
                     if (LoadBytesLeft=0) then
                        Break
                     else
                        begin
                        try
                           TempResponse:=ERROR_RESPONSE_RETRY;
                           TempLocked:=False;
                           TempRetry:=False;
                           while (TempResponse=ERROR_RESPONSE_RETRY) do
                              begin
                              TempResponse:=ERROR_RESPONSE_FAIL;
                              try
                                 if (not TempRetry) then
                                    PopulateRecordStats;
                                 case Mode of
                                    STREAM_NORMAL:
                                       begin
                                       if (not TempRetry) then
                                          begin
                                          InitRecord(TempRecordBuffer);
                                          PopulateRecordBuffer;
                                          end;
                                       AppendRecord(TempRecordBuffer,False,True,False,False);
                                       end;
                                    STREAM_TO_CACHE:
                                       begin
                                       if (not TempRetry) then
                                          begin
                                          InitRecord(TempRecordBuffer);
                                          PopulateRecordBuffer;
                                          PutRecordNo(TempRecordNumber,TempRecordBuffer);
                                          PutRecordID(TempRecordID,TempRecordBuffer);
                                          if (TempEngineVersion >= 4.18) then
                                             PutRecordHash(TempRecordHash,TempRecordBuffer)
                                          else
                                             PutRecordHash(CalcRecordHash(TempRecordBuffer),TempRecordBuffer);
                                          end;
                                       AppendRecord(TempRecordBuffer,False,False,False,False,True);
                                       end;
                                    STREAM_FROM_CACHE:
                                       begin
                                       if (TempRecordNumber <> 0) then
                                          begin
                                          if (TempStatus <> RECORD_DELETED) then
                                             begin
                                             if (not TempRetry) then
                                                begin
                                                PopulateRecordBuffer;
                                                PutRecordID(TempRecordID,TempRecordBuffer);
                                                if (TempEngineVersion >= 4.18) then
                                                   PutRecordHash(TempRecordHash,TempRecordBuffer)
                                                else
                                                   PutRecordHash(CalcRecordHash(TempRecordBuffer),TempRecordBuffer);
                                                Move(TempRecordBuffer^,TempSaveRecordBuffer^,FRecordSize);
                                                SetCurrentRecord(TempRecordNumber);
                                                end;
                                             if (not TempLocked) then
                                                begin
                                                try
                                                   GetCurrentRecord(TempRecordBuffer,True);
                                                finally
                                                   Move(CurrentRecordBuffer^,TempOldRecordBuffer^,FRecordSize);
                                                   Move(TempSaveRecordBuffer^,TempRecordBuffer^,FRecordSize);
                                                end;
                                                TempLocked:=True;
                                                end;
                                             ModifyRecord(TempRecordBuffer,True,False);
                                             TempLocked:=False;
                                             end
                                          else
                                             begin
                                             if (not TempRetry) then
                                                begin
                                                { This is a dummy populate with skips over the data }
                                                PopulateRecordBuffer;
                                                PutRecordID(TempRecordID,TempRecordBuffer);
                                                if (TempEngineVersion >= 4.18) then
                                                   PutRecordHash(TempRecordHash,TempRecordBuffer)
                                                else
                                                   PutRecordHash(CalcRecordHash(TempRecordBuffer),TempRecordBuffer);
                                                SetCurrentRecord(TempRecordNumber);
                                                end;
                                             try
                                                DeleteRecord(TempRecordBuffer,False);
                                             except
                                                Move(CurrentRecordBuffer^,TempOldRecordBuffer^,FRecordSize);
                                                raise;
                                             end;
                                             end;
                                          end
                                       else
                                          begin
                                          if (not TempRetry) then
                                             begin
                                             InitRecord(TempRecordBuffer);
                                             PopulateRecordBuffer;
                                             PutRecordID(TempRecordID,TempRecordBuffer);
                                             end;
                                          if (TempEngineVersion >= 4.18) then
                                             PutRecordHash(TempRecordHash,TempRecordBuffer)
                                          else
                                             PutRecordHash(CalcRecordHash(TempRecordBuffer),TempRecordBuffer);
                                          Move(TempRecordBuffer^,TempOldRecordBuffer^,FRecordSize);
                                          AppendRecord(TempRecordBuffer,False,False,False,False,False);
                                          end;
                                       end;
                                    end;
                              except
                                 on E: Exception do
                                    begin
                                    if (Mode=STREAM_FROM_CACHE) then
                                       begin
                                       if (TempRecordNumber <> 0) then
                                          begin
                                          if (TempStatus <> RECORD_DELETED) then
                                             TempOperation:=CACHE_UPDATE
                                          else
                                             TempOperation:=CACHE_DELETE;
                                          end
                                       else
                                          TempOperation:=CACHE_INSERT;
                                       CacheError(TempRecordNumber,TempRecordBuffer,
                                                  TempOldRecordBuffer,E,TempOperation,
                                                  TempRetry,TempResponse);
                                       case TempResponse of
                                          ERROR_RESPONSE_FAIL:
                                             raise;
                                          ERROR_RESPONSE_ABORT:
                                             Abort;
                                          ERROR_RESPONSE_RETRY:
                                             TempRetry:=True;
                                          end;
                                       end
                                    else
                                       raise;
                                    end;
                              end;
                              end;
                        finally
                           FreeAllBlobs(False,False);
                        end;
                        { Version 5 }
                        TempPercentDone:=Trunc(((LoadPos/SourceBufferSize)*100));
                        { Version 5 }
                        if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                           begin
                           DoProgress(TempPercentDone);
                           TempLastPercentDone:=TempPercentDone;
                           end;
                        end;
                     end;
               finally
                  DeAllocMem(TempOldRecordBuffer);
                  DeAllocMem(TempSaveRecordBuffer);
                  DeAllocMem(TempRecordBuffer);
               end;
            finally
               FSuppressRecordIDs:=False;
               if (Mode=STREAM_FROM_CACHE) then
                  begin
                  InternalSetIndexPos(SaveIndexPos);
                  FRangeInEffect:=SaveRangeInEffect;
                  CheckForActiveFilters;
                  end;
               { Version 5 }
               if (Mode <> STREAM_TO_CACHE) then
                  ForceRefresh;
               { Version 5 }
            end;
            end;
         if (TempLastPercentDone <> 100) then
            DoProgress(100);
         end;
      end
   else
      DoProgress(100);
end;

procedure TDataCursor.SaveToStream(var DestBuffer: PChar;
                                   var DestBufferSize: Integer;
                                   Mode: Byte;
                                   SendProgress: Boolean);
var
   CurDestBytes: Integer;
   TempSaveBuffer: PChar;
   CurSaveBytes: Integer;
   TempFieldBuffer: array [0..MAX_EXPORT_SIZE] of Char;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempRecordNumber: Integer;
   TempContinue: Boolean;
   TempRecordCount: Integer;
   TempRecordBuffer: PChar;
   IsBlank: Boolean;
   I: Integer;
   TempBlobSize: Integer;
   SaveIndexPos: Byte;
   SaveRangeInEffect: Boolean;

   procedure CheckSaveBufferSize(NewBytes: Integer);
   begin
      if ((CurSaveBytes+NewBytes) > SAVE_WRITE_SIZE) then
         begin
         ResizeBuffer((CurDestBytes+CurSaveBytes),DestBuffer,DestBufferSize);
         Move(TempSaveBuffer^,(DestBuffer+CurDestBytes)^,CurSaveBytes);
         Inc(CurDestBytes,CurSaveBytes);
         CurSaveBytes:=0;
         end;
   end;

   procedure MoveSaveBuffer;
   begin
      if (CurSaveBytes > 0) then
         begin
         ResizeBuffer((CurDestBytes+CurSaveBytes),DestBuffer,DestBufferSize);
         Move(TempSaveBuffer^,(DestBuffer+CurDestBytes)^,CurSaveBytes);
         Inc(CurDestBytes,CurSaveBytes);
         CurSaveBytes:=0;
         end;
   end;

   function GetNextStreamRecord: Boolean;
   begin
      Result:=False;
      if (Mode=STREAM_FROM_CACHE) then
         begin
         if (TempRecordNumber <= TempRecordCount) then
            begin
            SetCurrentRecord(TempRecordNumber);
            Move(CurrentRecordBuffer^,TempRecordBuffer^,FRecordSize);
            Result:=True;
            end;
         end
      else
         begin
         if (GetNextRecord(TempRecordBuffer)=DBISAM_NONE) then
            begin
            PutRecordNo(PhysicalRecordNumber,TempRecordBuffer);
            Result:=True;
            end;
         end;
   end;

begin
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_SAVETOSTREAM);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FBookmarkBuffer,BookmarkSize);
         Pack(FBOF,SizeOf(Boolean));
         Pack(FEOF,SizeOf(Boolean));
         if (RemoteEngineVersion >= 4.17) then
            Pack(Mode,SizeOf(Byte));
         Pack(SendProgress,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
         Unpack(CurDestBytes);
         ResizeBuffer(CurDestBytes,DestBuffer,DestBufferSize);
         Unpack(DestBuffer^);
         UnpackCursorInfo;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      DestBuffer:=nil;
      DestBufferSize:=0;
      CurDestBytes:=0;
      SaveIndexPos:=FIndexPos;
      SaveRangeInEffect:=FRangeInEffect;
      if (Mode=STREAM_FROM_CACHE) then
         begin
         InternalSetIndexPos(PHYSICAL_INDEX_POS);
         FRangeInEffect:=False;
         end;
      try
         TempRecordBuffer:=AllocMem(FRecordSize);
         try
            TempSaveBuffer:=AllocMem(SAVE_WRITE_SIZE);
            try
               CurSaveBytes:=0;
               { Write out the signature }
               CheckSaveBufferSize(SizeOf(TMD5Digest));
               pMD5Digest(TempSaveBuffer+CurSaveBytes)^:=DataEngine.SignatureDigest;
               Inc(CurSaveBytes,SizeOf(TMD5Digest));
               { Write out the engine version number }
               CheckSaveBufferSize(SizeOf(Currency));
               pCurrency(TempSaveBuffer+CurSaveBytes)^:=ENGINE_VERSION_NUM;
               Inc(CurSaveBytes,SizeOf(Currency));
               { Write out the field definitions }
               CheckSaveBufferSize(SizeOf(Word));
               pWord(TempSaveBuffer+CurSaveBytes)^:=FFieldCount;
               Inc(CurSaveBytes,SizeOf(Word));
               for I:=1 to FFieldCount do
                  begin
                  with FFieldDefinitions[I]^ do
                     begin
                     CheckSaveBufferSize(SizeOf(Byte));
                     Byte((TempSaveBuffer+CurSaveBytes)^):=DataType;
                     Inc(CurSaveBytes,SizeOf(Byte));
                     CheckSaveBufferSize(SizeOf(Word));
                     pWord(TempSaveBuffer+CurSaveBytes)^:=DataSize;
                     Inc(CurSaveBytes,SizeOf(Word));
                     CheckSaveBufferSize(SizeOf(Byte));
                     Byte((TempSaveBuffer+CurSaveBytes)^):=DataDecimals;
                     Inc(CurSaveBytes,SizeOf(Byte));
                     CheckSaveBufferSize(SizeOf(Byte));
                     (TempSaveBuffer+CurSaveBytes)^:=FieldName[0];
                     Inc(CurSaveBytes,SizeOf(Byte));
                     CheckSaveBufferSize(Byte(FieldName[0]));
                     Move(FieldName[1],(TempSaveBuffer+CurSaveBytes)^,Byte(FieldName[0]));
                     Inc(CurSaveBytes,Byte(FieldName[0]));
                     end;
                  end;
               TempLastPercentDone:=0;
               TempRecordNumber:=1;
               if (Mode=STREAM_FROM_CACHE) then
                  TempRecordCount:=PhysicalRecordsUsed
               else
                  begin
                  TempRecordCount:=RecordCount;
                  SetToBegin;
                  end;
               while GetNextStreamRecord do
                  begin
                  if (Mode <> STREAM_NORMAL) then
                     begin
                     if (Mode=STREAM_TO_CACHE) or
                        ((Mode=STREAM_FROM_CACHE) and
                         (GetRecordStatus(TempRecordBuffer) <> RECORD_VALID)) then
                        begin
                        CheckSaveBufferSize(SizeOf(Integer));
                        pInteger(TempSaveBuffer+CurSaveBytes)^:=GetRecordNo(TempRecordBuffer);
                        Inc(CurSaveBytes,SizeOf(Integer));
                        CheckSaveBufferSize(SizeOf(Integer));
                        pInteger(TempSaveBuffer+CurSaveBytes)^:=GetRecordID(TempRecordBuffer);
                        Inc(CurSaveBytes,SizeOf(Integer));
                        if (ENGINE_VERSION_NUM >= 4.18) then
                           begin
                           CheckSaveBufferSize(SizeOf(TMD5Digest));
                           pMD5Digest(TempSaveBuffer+CurSaveBytes)^:=GetRecordHash(TempRecordBuffer);
                           Inc(CurSaveBytes,SizeOf(TMD5Digest));
                           end;
                        CheckSaveBufferSize(SizeOf(Byte));
                        Byte((TempSaveBuffer+CurSaveBytes)^):=GetRecordStatus(TempRecordBuffer);
                        Inc(CurSaveBytes,SizeOf(Byte));
                        TempContinue:=True;
                        end
                     else
                        TempContinue:=False;
                     end
                  else
                     TempContinue:=True;
                  if TempContinue then
                     begin
                     for I:=1 to FFieldCount do
                        begin
                        IsBlank:=False;
                        with FFieldDefinitions[I]^ do
                           begin
                           GetField(FieldNum,TempRecordBuffer,
                                    @TempFieldBuffer,IsBlank);
                           CheckSaveBufferSize(SizeOf(Boolean));
                           Boolean((TempSaveBuffer+CurSaveBytes)^):=(not IsBlank);
                           Inc(CurSaveBytes,SizeOf(Boolean));
                           if (not IsBlank) then
                              begin
                              if (DataType <> TYPE_BLOB) then
                                 begin
                                 CheckSaveBufferSize(DataSize);
                                 Move(TempFieldBuffer,(TempSaveBuffer+CurSaveBytes)^,DataSize);
                                 Inc(CurSaveBytes,DataSize);
                                 end
                              else
                                 begin
                                 OpenBlob(FieldNum,TempRecordBuffer,BLOB_OPENREADONLY,False,True,
                                          TempBlobSize,False);
                                 try
                                    CheckSaveBufferSize(SizeOf(Integer));
                                    pInteger(TempSaveBuffer+CurSaveBytes)^:=TempBlobSize;
                                    Inc(CurSaveBytes,SizeOf(Integer));
                                    MoveSaveBuffer;
                                    { Just put the BLOB data directly into the destination buffer }
                                    ResizeBuffer((CurDestBytes+TempBlobSize),DestBuffer,DestBufferSize);
                                    GetBlob(FieldNum,TempRecordBuffer,0,(DestBuffer+CurDestBytes),
                                            TempBlobSize,TempBlobSize,False);
                                    Inc(CurDestBytes,TempBlobSize);
                                 finally
                                    FreeBlob(FieldNum,TempRecordBuffer,False,True);
                                 end;
                                 end;
                              end;
                           end;
                        end;
                     end;
                  TempPercentDone:=Trunc(((TempRecordNumber/TempRecordCount)*100));
                  if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                     begin
                     DoProgress(TempPercentDone);
                     TempLastPercentDone:=TempPercentDone;
                     end;
                  Inc(TempRecordNumber);
                  end;
               MoveSaveBuffer;
               if (TempLastPercentDone <> 100) then
                  DoProgress(100);
            finally
               DeAllocMem(TempSaveBuffer);
            end;
         finally
            DeAllocMem(TempRecordBuffer);
         end;
      finally
         if (Mode=STREAM_FROM_CACHE) then
            begin
            InternalSetIndexPos(SaveIndexPos);
            FRangeInEffect:=SaveRangeInEffect;
            CheckForActiveFilters;
            end;
      end;
      end;
end;

procedure TDataCursor.AlterTable(NewLocaleID: Integer;
                                 NewUserMajorVersion: Word;
                                 NewUserMinorVersion: Word;
                                 NewEncrypted: Boolean;
                                 NewPassword: string;
                                 NewDescription: string;
                                 NewIndexPageSize: Integer;
                                 NewBlobBlockSize: Integer;
                                 NewLastAutoIncID: Integer;
                                 NewTextIndexStopWords: TStrings;
                                 const NewTextIndexSpaceChars: TCharSet;
                                 const NewTextIndexIncludeChars: TCharSet;
                                 SuppressBackups: Boolean;
                                 SendProgress: Boolean; SendDataLost: Boolean;
                                 NumberOfFields: Word;
                                 const FieldDefinitions: array of pFieldDefinition;
                                 NumberOfIndexes: Byte;
                                 const IndexDefinitions: array of pIndexDefinition);
var
   NewDataDirectory: TDataDirectory;
   NewDataCursor: TDataCursor;
   StructureChanged: Boolean;
   IndexesChanged: Boolean;
   FieldFound: Boolean;
   OldFieldDefinition: pFieldDefinition;
   NewFieldDefinition: pFieldDefinition;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   I: Word;
   J: Word;
   TempRecordBuffer: PChar;
   TempRecord: TRecord;
   TempRecordNumber: Integer;
   TempPercentDone: Word;
   TempLastPercentDone: Word;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSize: Integer;
   ContinueAlter: Boolean;
   StopAsking: Boolean;
   RemovePassword: Boolean;
   TempStopWords: TLocaleStringList;
   TempSpaceChars: TCharSet;
   TempIncludeChars: TCharSet;
begin
   StopAsking:=False;
   ContinueAlter:=True;
   CheckTransaction;
   CheckNotOpen;
   CheckExclusive;
   CheckNotReadOnly;
   NewIndexPageSize:=BlockOffset(NewIndexPageSize,CRYPTO_BLOCK_SIZE);
   NewBlobBlockSize:=BlockOffset(NewBlobBlockSize,CRYPTO_BLOCK_SIZE);
   VerifyStructureInformation(NewLocaleID,
                              NewEncrypted,NewPassword,
                              NewIndexPageSize,NewBlobBlockSize,
                              NewLastAutoIncID,
                              NumberOfFields,FieldDefinitions,
                              NumberOfIndexes,IndexDefinitions,False);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_ALTERTABLE);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(FTableName[1],Length(FTableName));
         Pack(NewLocaleID,SizeOf(Integer));
         Pack(NewUserMajorVersion,SizeOf(Word));
         Pack(NewUserMinorVersion,SizeOf(Word));
         Pack(NewEncrypted,SizeOf(Boolean));
         Pack(NewPassword[1],Length(NewPassword));
         Pack(NewDescription[1],Length(NewDescription));
         Pack(NewIndexPageSize,SizeOf(Integer));
         Pack(NewBlobBlockSize,SizeOf(Integer));
         Pack(NewLastAutoIncID,SizeOf(Integer));
         PackTextIndexParams(NewTextIndexStopWords,NewTextIndexSpaceChars,
                             NewTextIndexIncludeChars);
         Pack(SuppressBackups,SizeOf(Boolean));
         Pack(SendProgress,SizeOf(Boolean));
         Pack(SendDataLost,SizeOf(Boolean));
         Pack(NumberOfFields,SizeOf(Word));
         for I:=0 to NumberOfFields-1 do
            Pack(FieldDefinitions[I]^,SizeOf(TFieldDefinition));
         Pack(NumberOfIndexes,SizeOf(Byte));
         for I:=0 to NumberOfIndexes do
            Pack(IndexDefinitions[I]^,SizeOf(TIndexDefinition));
         Pack(IndexDefinitions[TEXT_INDEX_POS]^,SizeOf(TIndexDefinition));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end
   else
      begin
      OpenCursor(False);
      InternalSetIndexPos(PHYSICAL_INDEX_POS);
      try
         if FDataDirectory.InMemory then
            NewDataDirectory:=DataSession.OpenDataDirectory(INMEMORY_DATABASE_NAME,
                              INMEMORY_TEMP_NAME,False,False)
         else
            begin
            if DataEngine.TempTablesInDataDirectory then
               NewDataDirectory:=DataSession.OpenDataDirectory('',
                                    FDataDirectory.Directory,False,False)
            else
               NewDataDirectory:=DataSession.OpenDataDirectory('',
                                    DataSession.PrivateDirectory,False,False);
            end;
         try
            NewDataCursor:=TDataCursor.Create(NewDataDirectory,False);
            NewDataCursor.AlteringStructure:=True;
            try
               TempStopWords:=TLocaleStringList.Create;
               try
                  { Handle default values }
                  if (NewLastAutoIncID = -1) then
                     NewLastAutoIncID:=LastAutoIncID;
                  GetTextIndexParams;
                  with TempStopWords do
                     begin
                     SetLocaleID(NewLocaleID);
                     Duplicates:=dupIgnore;
                     Sorted:=True;
                     end;
                  if (NewTextIndexStopWords=nil) then
                     TempStopWords.Assign(TextStopWords)
                  else
                     TempStopWords.Assign(NewTextIndexStopWords);
                  if (NewTextIndexSpaceChars=[]) then
                     TempSpaceChars:=TextSpaceChars
                  else
                     TempSpaceChars:=NewTextIndexSpaceChars;
                  if (NewTextIndexIncludeChars=[]) then
                     TempIncludeChars:=TextIncludeChars
                  else
                     TempIncludeChars:=NewTextIndexIncludeChars;
                  { First we need to check to see what (if anything) has changed
                    between the current table structure and the new structure }
                  StructureChanged:=False;
                  IndexesChanged:=False;
                  if (NewEncrypted <> Encrypted) or (NewPassword <> Password) then
                     StructureChanged:=True
                  else if (NewIndexPageSize <> IndexPageSize) then
                     StructureChanged:=True
                  else if (NewBlobBlockSize <> BlobBlockSize) then
                     StructureChanged:=True
                  else if (NewLocaleID <> LocaleID) then
                     StructureChanged:=True
                  else
                     begin
                     if (NumberOfFields <> PhysicalFieldCount) then
                        StructureChanged:=True
                     else
                        begin
                        for I:=1 to FieldCount do
                           begin
                           OldFieldDefinition:=GetFieldDefinitionByPos(I);
                           if FieldDefinitionHasChanged(OldFieldDefinition,
                                                        FieldDefinitions[I-1]) then
                              begin
                              StructureChanged:=True;
                              Break;
                              end
                           end;
                        end;
                     if not StructureChanged then
                        begin
                        if (NumberOfIndexes <> IndexCount) then
                           IndexesChanged:=True
                        else if ((not CompareTStrings(NewLocaleID,TempStopWords,TextStopWords)) or
                                 (TempSpaceChars <> TextSpaceChars) or
                                 (TempIncludeChars <> TextIncludeChars)) then
                           IndexesChanged:=True
                        else
                           begin
                           for I:=0 to IndexCount do
                              begin
                              if IndexDefinitionHasChanged(GetIndexDefinition(I),
                                                           IndexDefinitions[I],
                                                           NumberOfFields,FieldDefinitions) then
                                 begin
                                 IndexesChanged:=True;
                                 Break;
                                 end;
                              end;
                           if IndexDefinitionHasChanged(GetIndexDefinition(TEXT_INDEX_POS),
                                                        IndexDefinitions[TEXT_INDEX_POS],
                                                        NumberOfFields,FieldDefinitions) then
                              IndexesChanged:=True;
                           end;
                        end;
                     end;
                  if StructureChanged then
                     begin
                     with NewDataCursor do
                        begin
                        TableName:=NewDataDirectory.GetTempDataTableName;
                        ErrorTableName:=Self.TableName;
                        Temporary:=False;
                        Exclusive:=True;
                        RemovePassword:=False;
                        if NewEncrypted then
                           begin
                           if not DataDirectory.DataSession.CheckForPassword(NewPassword) then
                              begin
                              DataDirectory.DataSession.AddPassword(NewPassword);
                              RemovePassword:=True;
                              end;
                           end;
                        try
                           CreateTable(NewLocaleID,
                                       NewUserMajorVersion,NewUserMinorVersion,
                                       NewEncrypted,NewPassword,
                                       NewDescription,
                                       NewIndexPageSize,NewBlobBlockSize,
                                       NewLastAutoIncID,
                                       TempStopWords,TempSpaceChars,
                                       TempIncludeChars,True,
                                       NumberOfFields,FieldDefinitions,
                                       NumberOfIndexes,IndexDefinitions);
                           OpenCursor(False);
                           SuppressRecordIDs:=True;
                           SuppressTriggers:=True;
                           InternalSetIndexPos(PHYSICAL_INDEX_POS);
                           TempRecordBuffer:=AllocMem(RecordSize);
                           try
                              TempRecordNumber:=1;
                              TempLastPercentDone:=0;
                              while (TempRecordNumber <= Self.PhysicalRecordsUsed) do
                                 begin
                                 Self.GetRecord(TempRecordNumber,True,READ_FORWARD,
                                                TempRecord);
                                 try
                                    if (TempRecord.Status <> RECORD_DELETED) then
                                       begin
                                       InitRecord(TempRecordBuffer);
                                       for I:=1 to Self.FieldCount do
                                          begin
                                          FieldFound:=False;
                                          OldFieldDefinition:=Self.GetFieldDefinitionByPos(I);
                                          NewFieldDefinition:=nil;
                                          for J:=0 to FieldCount-1 do
                                             begin
                                             if (OldFieldDefinition^.FieldNum=
                                                FieldDefinitions[J]^.FieldNum) then
                                                begin
                                                NewFieldDefinition:=FieldDefinitions[J];
                                                FieldFound:=True;
                                                Break;
                                                end;
                                             end;
                                          if FieldFound then
                                             begin
                                             Self.GetField(OldFieldDefinition^.FieldNum,
                                                           TempRecord.Buffer,
                                                           @TempFieldBuffer,IsBlank);
                                             if not IsBlank then
                                                begin
                                                if (OldFieldDefinition^.DataType=TYPE_BLOB) then
                                                   begin
                                                   Self.OpenBlob(OldFieldDefinition^.FieldNum,
                                                                 TempRecord.Buffer,
                                                                 BLOB_OPENREADONLY,False,True,
                                                                 BlobSizeToLoad,False);
                                                   Self.GetField(OldFieldDefinition^.FieldNum,
                                                                 TempRecord.Buffer,
                                                                 @BlobHandle,IsBlank);
                                                   if (NewFieldDefinition^.DataType=TYPE_BLOB) and
                                                      (BlobHandle < 0) then
                                                      begin
                                                      OpenBlob(NewFieldDefinition^.FieldNum,
                                                               TempRecordBuffer,BLOB_OPENREADWRITE,
                                                               False,True,BlobSize,False);
                                                      BlobHandle:=FlipIntegerSign(BlobHandle);
                                                      PutBlob(NewFieldDefinition^.FieldNum,
                                                              TempRecordBuffer,
                                                              0,TBlobBuffer(BlobHandle).Buffer,
                                                              BlobSizeToLoad,False);
                                                      end
                                                   else
                                                      begin
                                                      if not StopAsking then
                                                         Self.DoDataLost(DATALOSS_FIELDCONVERT,OldFieldDefinition^.FieldName,
                                                                         ContinueAlter,StopAsking);
                                                      if not ContinueAlter then
                                                         Break;
                                                      end;
                                                   end
                                                else
                                                   begin
                                                   if not ConvertExpression(OldFieldDefinition^.DataType,
                                                                            OldFieldDefinition^.DataSize,
                                                                            OldFieldDefinition^.DataDecimals,
                                                                            NewFieldDefinition^.DataType,
                                                                            NewFieldDefinition^.DataSize,
                                                                            NewFieldDefinition^.DataDecimals,
                                                                            @TempFieldBuffer) then
                                                      begin
                                                      if not StopAsking then
                                                         Self.DoDataLost(DATALOSS_FIELDCONVERT,OldFieldDefinition^.FieldName,
                                                                         ContinueAlter,StopAsking);
                                                      if not ContinueAlter then
                                                         Break;
                                                      end
                                                   else
                                                      PutField(NewFieldDefinition^.FieldNum,
                                                               TempRecordBuffer,@TempFieldBuffer,
                                                               False,False);
                                                   end;
                                                end
                                             else
                                               PutField(NewFieldDefinition^.FieldNum,
                                                        TempRecordBuffer,nil,False,False);
                                             end
                                          else
                                             begin
                                             if not StopAsking then
                                                Self.DoDataLost(DATALOSS_FIELDDELETE,OldFieldDefinition^.FieldName,
                                                                ContinueAlter,StopAsking);
                                             if not ContinueAlter then
                                                Break;
                                             end;
                                          end;
                                       if ContinueAlter then
                                          begin
                                          try
                                             try
                                                PutRecordID(TempRecord.ID,TempRecordBuffer);
                                                AppendRecord(TempRecordBuffer,False,True,False,False);
                                             except
                                                on E: Exception do
                                                   begin
                                                   if not StopAsking then
                                                      begin
                                                      if (E is EDBISAMEngineError) then
                                                         begin
                                                         with EDBISAMEngineError(E) do
                                                            begin
                                                            if (ErrorCode=DBISAM_KEYVIOL) then
                                                               Self.DoDataLost(DATALOSS_KEYVIOLATION,
                                                                  ErrorIndexName,
                                                                  ContinueAlter,StopAsking)
                                                            else if (ErrorCode=DBISAM_MINVALERR) or
                                                                    (ErrorCode=DBISAM_MAXVALERR) or
                                                                    (ErrorCode=DBISAM_REQDERR) then
                                                               Self.DoDataLost(DATALOSS_VALCHECKFAIL,
                                                                  ErrorFieldName,
                                                                  ContinueAlter,StopAsking)
                                                            else
                                                               Self.DoDataLost(DATALOSS_UNKNOWN,'',
                                                                  ContinueAlter,StopAsking);
                                                            end;
                                                         end
                                                      else
                                                         Self.DoDataLost(DATALOSS_UNKNOWN,'',
                                                                  ContinueAlter,StopAsking);
                                                      end;
                                                   if not ContinueAlter then
                                                      Break;
                                                   end;
                                             end;
                                          finally
                                             Self.FreeAllBlobs(False,False);
                                          end;
                                          end
                                       else
                                          Break;
                                       end;
                                    TempPercentDone:=Trunc(((TempRecordNumber/Self.PhysicalRecordsUsed)*100));
                                    if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                       begin
                                       Self.DoProgress(TempPercentDone);
                                       TempLastPercentDone:=TempPercentDone;
                                       end;
                                    Inc(TempRecordNumber);
                                 finally
                                    PutRecord(TempRecord);
                                 end;
                                 end;
                           finally
                              DeAllocMem(TempRecordBuffer);
                           end;
                           ResetFieldNumbers;
                           if (LastAutoIncID < NewLastAutoIncID) then
                              LastAutoIncID:=NewLastAutoIncID;
                           LastRecordID:=Self.LastRecordID;
                           CloseCursor(True);
                           Self.CloseCursor(True);
                           if ContinueAlter then
                              begin
                              if not Self.DataDirectory.InMemory then
                                 begin
                                 if SuppressBackups then
                                    Self.DeleteTable
                                 else
                                    Self.InternalBackupTable;
                                 end
                              else
                                 Self.DeleteTable;
                              InternalRestoreTable(Self.DataDirectory,Self.TableName);
                              end
                           else
                              DeleteTable;
                           if (TempLastPercentDone <> 100) then
                              Self.DoProgress(100);
                        finally
                           if NewEncrypted then
                              begin
                              if RemovePassword then
                                 DataDirectory.DataSession.DeletePassword(NewPassword);
                              end;
                        end;
                        end;
                     end
                  else if IndexesChanged then
                     begin
                     InternalBackupIndex(NewDataDirectory);
                     if (NumberOfIndexes < IndexCount) then
                        begin
                        for I:=IndexCount downto (NumberOfIndexes+1) do
                           DeleteIndexByPos(I,False,True);
                        end
                     else if (NumberOfIndexes > IndexCount) then
                        begin
                        for I:=NumberOfIndexes downto (IndexCount+1) do
                           begin
                           SetIndexDefinition(I,IndexDefinitions[I]);
                           IndexDefinitions[I]^.IndexChanged:=True;
                           end;
                        end;
                     for I:=0 to IndexCount do
                        begin
                        IndexDefinitions[I]^.IndexChanged:=IndexDefinitionHasChanged(GetIndexDefinition(I),
                                                                                 IndexDefinitions[I],
                                                                                 NumberOfFields,
                                                                                 FieldDefinitions);
                        if IndexDefinitions[I]^.IndexChanged then
                           begin
                           DeleteIndexByPos(I,False,False);
                           SetIndexDefinition(I,IndexDefinitions[I]);
                           end;
                        end;
                     { Check the text index for changes }
                     if ((not CompareTStrings(NewLocaleID,TempStopWords,TextStopWords)) or
                         (TempSpaceChars <> TextSpaceChars) or
                         (TempIncludeChars <> TextIncludeChars) or
                          IndexDefinitionHasChanged(GetIndexDefinition(TEXT_INDEX_POS),
                                                    IndexDefinitions[TEXT_INDEX_POS],
                                                    NumberOfFields,FieldDefinitions)) then
                        begin
                        IndexDefinitions[TEXT_INDEX_POS]^.IndexChanged:=True;
                        DeleteIndexByPos(TEXT_INDEX_POS,False,False);
                        SetIndexDefinition(TEXT_INDEX_POS,IndexDefinitions[TEXT_INDEX_POS]);
                        end;
                     IndexCount:=NumberOfIndexes;
                     IndexesChanged:=False;
                     for I:=0 to IndexCount do
                        begin
                        if IndexDefinitions[I]^.IndexChanged then
                           begin
                           IndexesChanged:=True;
                           Break;
                           end;
                        end;
                     if IndexDefinitions[TEXT_INDEX_POS]^.IndexChanged then
                        begin
                        IndexesChanged:=True;
                        SetTextIndexParams(TempStopWords,TempSpaceChars,
                                           TempIncludeChars);
                        end;
                     if IndexesChanged then
                        begin
                        InternalSetIndexPos(PHYSICAL_INDEX_POS);
                        TempRecordNumber:=1;
                        TempLastPercentDone:=0;
                        while (TempRecordNumber <= PhysicalRecordsUsed) do
                           begin
                           GetRecord(TempRecordNumber,True,READ_FORWARD,
                                     TempRecord);
                           try
                              if (TempRecord.Status <> RECORD_DELETED) then
                                 begin
                                 try
                                    for I:=0 to IndexCount do
                                       begin
                                       if IndexDefinitions[I]^.IndexChanged then
                                          begin
                                          if IsUniqueIndex(I) then
                                             begin
                                             InternalSetIndexPos(I);
                                             GetKeyValues(TempRecord.Buffer,
                                                          @TempKeyBuffer);
                                             if CheckForKeyViolation(@TempKeyBuffer) then
                                                RaiseKeyViolationError;
                                             end;
                                          end;
                                       end;
                                    for I:=0 to IndexCount do
                                       begin
                                       if IndexDefinitions[I]^.IndexChanged then
                                          begin
                                          InternalSetIndexPos(I);
                                          GetKeyValues(TempRecord.Buffer,
                                                       @TempKeyBuffer);
                                          AddIndexKey(@TempKeyBuffer,TempRecordNumber);
                                          end;
                                       end;
                                    if IndexDefinitions[TEXT_INDEX_POS]^.IndexChanged then
                                       CreateTextIndexes(TempRecord);
                                 except
                                    on E: Exception do
                                       begin
                                       if (E is EDBISAMEngineError) then
                                          begin
                                          with EDBISAMEngineError(E) do
                                             begin
                                             if not StopAsking then
                                                begin
                                                if (ErrorCode=DBISAM_KEYVIOL) then
                                                   begin
                                                   Self.DoDataLost(DATALOSS_KEYVIOLATION,ErrorIndexName,
                                                      ContinueAlter,StopAsking);
                                                   if ContinueAlter then
                                                      RemoveDuplicateRecord(TempRecord,FIndexPos);
                                                   end
                                                else
                                                   Self.DoDataLost(DATALOSS_UNKNOWN,'',
                                                      ContinueAlter,StopAsking);
                                                end
                                             else
                                                begin
                                                if (ErrorCode=DBISAM_KEYVIOL) then
                                                   RemoveDuplicateRecord(TempRecord,FIndexPos);
                                                end;
                                             end;
                                          end
                                       else
                                          Self.DoDataLost(DATALOSS_UNKNOWN,'',
                                                   ContinueAlter,StopAsking);
                                       if not ContinueAlter then
                                          Break;
                                       end;
                                 end;
                                 end;
                              TempPercentDone:=Trunc(((TempRecordNumber/PhysicalRecordsUsed)*100));
                              if (TempPercentDone >= (TempLastPercentDone+ProgressPercent)) then
                                 begin
                                 DoProgress(TempPercentDone);
                                 TempLastPercentDone:=TempPercentDone;
                                 end;
                              Inc(TempRecordNumber);
                           finally
                              PutRecord(TempRecord);
                              InternalSetIndexPos(PHYSICAL_INDEX_POS);
                           end;
                           end;
                        if (TempLastPercentDone <> 100) then
                           DoProgress(100);
                        end;
                     if ContinueAlter then
                        begin
                        InternalRestoreIndex(NewDataDirectory,True,SuppressBackups);
                        for I:=0 to NumberOfFields-1 do
                           UpdatePhysicalFieldDefinitionByPos(I+1,FieldDefinitions[I]);
                        for I:=0 to NumberOfIndexes do
                           UpdateIndexDefinition(I,IndexDefinitions[I]);
                        UpdateDataHeader(NewLocaleID,
                                         NewUserMajorVersion,NewUserMinorVersion,
                                         NewEncrypted,NewPassword,
                                         NewDescription,
                                         NewIndexPageSize,NewBlobBlockSize,
                                         NewLastAutoIncID);
                        end
                     else
                        begin
                        InternalRestoreIndex(NewDataDirectory,False,True);
                        FreeBuffers(False,True,True);
                        end;
                     end
                  else
                     begin
                     for I:=0 to NumberOfFields-1 do
                        UpdatePhysicalFieldDefinitionByPos(I+1,FieldDefinitions[I]);
                     for I:=0 to NumberOfIndexes do
                        UpdateIndexDefinition(I,IndexDefinitions[I]);
                     UpdateDataHeader(NewLocaleID,
                                      NewUserMajorVersion,NewUserMinorVersion,
                                      NewEncrypted,NewPassword,
                                      NewDescription,
                                      NewIndexPageSize,NewBlobBlockSize,
                                      NewLastAutoIncID);
                     end;
               finally
                  TempStopWords.Free;

               end;
            finally
               NewDataCursor.Free;
            end;
         finally
            DataSession.CloseDataDirectory(NewDataDirectory,False);
         end;
      finally
         CloseCursor(True);
      end;
      end;
end;

procedure TDataCursor.RemoveDuplicateRecord(RecordToRemove: TRecord;
                                            IndexToSkip: Byte);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   I: Byte;
   SaveIndexPos: Byte;
begin
   SaveIndexPos:=FIndexPos;
   try
      for I:=0 to IndexCount do
         begin
         if (I <> IndexToSkip) then
            begin
            InternalSetIndexPos(I);
            GetKeyValues(RecordToRemove.Buffer,@TempKeyBuffer);
            RemoveIndexKey(@TempKeyBuffer);
            end;
         end;
      DecTotalRecordCount;
      if (BlobFieldCount > 0) then
         begin
         DeleteAllBlobs(RecordToRemove.Buffer);
         RemoveTextIndexes(RecordToRemove);
         UpdateBlobSignatures(RecordToRemove.Buffer,False);
         FlushBlobBuffers;
         UpdateBlobBlocks(RecordToRemove.Buffer,False);
         FreeAllBlobs(False,False);
         end
      else
         RemoveTextIndexes(RecordToRemove);
      SetNextFreeRecord(RecordToRemove);
   finally
      InternalSetIndexPos(SaveIndexPos);
   end;
end;

function TDataCursor.HasCallbackFilters: Boolean;
var
   I: Integer;
begin
   Result:=False;
   for I:=0 to FFilters.Count-1 do
      begin
      with TFilter(FFilters[I]) do
         begin
         if IsCallbackFilter and IsActive then
            begin
            Result:=True;
            Break;
            end;
         end;
      end;
end;

function TDataCursor.ParseFilter(FilterExpr: PChar): TExpToken;
begin
   with FFilterExpressionParser do
      begin
      ErrorCode:=DBISAM_INVALIDFILTER;
      ErrorDBName:=ProperDataDirectoryName;
      ErrorTableName:=FTableName;
      ErrorContext:='filter expression';
      ObjectContext:=Self;
      SetExpression(FilterExpr,1,1);
      NextToken;
      Result:=ParseExpression1([pmAllowExtPredicates]);
      end;
end;

procedure TDataCursor.VerifyFilter(FilterTokens: TExpToken);
begin
   with FFilterExpressionVerifier do
      begin
      ErrorCode:=DBISAM_INVALIDFILTER;
      ErrorDBName:=ProperDataDirectoryName;
      ErrorTableName:=FTableName;
      ErrorContext:='filter expression';
      SetFieldCallback(Integer(Self),@TDataCursor.VerifyFilterFieldData);
      VerifyExpression(FilterTokens,True,True);
      end;
   if (FilterTokens.DataType <> TYPE_BOOL) then
      DataEngine.RaiseError(DBISAM_INVALIDFILTER,'','',ProperDataDirectoryName,
                              FTableName,'','','filter expression must '+
                              'be a boolean expression');
end;

function TDataCursor.VerifyFilterFieldData(FieldToken: TExpToken): Boolean;
var
   TempFieldDefinition: pFieldDefinition;
begin
   Result:=False;
   with FieldToken do
      begin
      { Be sure to update all of the data field types and field
        numbers in the current token }
      TempFieldDefinition:=GetPhysicalFieldDefinitionByName(FieldName);
      if (TempFieldDefinition <> nil) then
         begin
         if (TempFieldDefinition^.FieldNum <> 0) then
            begin
            FieldNumber:=TempFieldDefinition^.FieldNum;
            SourceAlias:='';
            DataType:=TempFieldDefinition^.DataType;
            SubType:=TempFieldDefinition^.SubType;
            DataSize:=TempFieldDefinition^.DataSize;
            DataDecimals:=TempFieldDefinition^.DataDecimals;
            Result:=True;
            end;
         end;
      end;
end;

procedure TDataCursor.NormalizeFilter(NextToken: TExpToken);
begin
   with NextToken do
      begin
      case TokenType of
         etUNARY:
            NormalizeFilter(LeftExpToken);
         etBINARY:
            begin
            if (TokenOperator in [eoEQ,eoNE,eoGT,eoGE,eoLT,eoLE]) and
                    ((ContainsFields(LeftExpToken) and
                      (not ContainsFields(RightExpToken))) or
                     (ContainsFields(RightExpToken) and
                      (not ContainsFields(LeftExpToken)))) then
               begin
               { Make sure to reverse operators, if needed }
               if ((not ContainsFields(LeftExpToken)) and
                   ContainsFields(RightExpToken)) then
                  ReverseBinaryTokenOperator(NextToken);
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.AddFilter(ClientData: Integer;
                                FilterExpr: PChar;
                                NextToken: TExpToken;
                                FreeTokens: Boolean;
                                FilterCallBack: pFilterFunction;
                                UseExisting: Boolean;
                                CalculateCosts: Boolean;
                                CaseInsensitive: Boolean;
                                NoPartialMatch: Boolean;
                                var FilterHandle: Pointer);
var
   TempToken: TExpToken;
   TempRemoteID: Integer;
   TempOptimizeLevel: TOptimizeLevel;
   TempExpTokenBuffer: PChar;
   TempExpTokenSize: Integer;
   TempPerformIOCheck: Boolean;
begin
   if (FFilters.Count=MAX_NUM_FILTERS) then
      DataEngine.RaiseError(DBISAM_INTERNALLIMIT,'','',ProperDataDirectoryName,
                              FTableName);
   if (FilterExpr <> nil) or (NextToken <> nil) then
      begin
      if (FilterExpr <> nil) then
         begin
         TempToken:=ParseFilter(FilterExpr);
         VerifyFilter(TempToken);
         NormalizeFilter(TempToken);
         NextToken:=BuildNextFilterExpression(TempToken,Integer(Self),
                                                 @TDataCursor.EvaluateFilterFieldData,
                                                 LocaleID,
                                                 CaseInsensitive,NoPartialMatch);
         FreeExpressionTokens(TempToken);
         end;
      FilterHandle:=Pointer(TFilter.Create(Self,NextToken,FreeTokens,UseExisting,
                                           CalculateCosts,0,nil));
      end
   else if Assigned(FilterCallback) then
      FilterHandle:=Pointer(TFilter.Create(Self,nil,False,UseExisting,
                                           CalculateCosts,
                                           ClientData,FilterCallback))
   else
      DataEngine.RaiseError(DBISAM_INVALIDFILTER,'','',ProperDataDirectoryName,
                              FTableName,'','','invalid filter specified');
   AddFilterHandle(FilterHandle,UseExisting);
   if IsRemote then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         TempPerformIOCheck:=False;
         if TFilter(FilterHandle).IsCallbackFilter then
            begin
            SetRequestCode(REQUEST_ADDCALLBACKFILTER);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(UseExisting,SizeOf(Boolean));
            if (RemoteEngineVersion < 4.11) then
               Pack(TempPerformIOCheck,SizeOf(Boolean));
            Pack(CalculateCosts,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(TempRemoteID);
            with TFilter(FilterHandle) do
               RemoteID:=TempRemoteID;
            end
         else
            begin
            SetRequestCode(REQUEST_ADDEXPRFILTER);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            TempExpTokenBuffer:=nil;
            if (RemoteEngineVersion <= 4.05) then
               TranslateExpressionTokens(NextToken);               
            TempExpTokenSize:=PackExpressionTokens(NextToken,TempExpTokenBuffer);
            try
               Pack(TempExpTokenSize,SizeOf(Integer));
               Pack(TempExpTokenBuffer^,TempExpTokenSize);
            finally
               DeAllocMem(TempExpTokenBuffer);
            end;
            Pack(FreeTokens,SizeOf(Boolean));
            Pack(UseExisting,SizeOf(Boolean));
            if (RemoteEngineVersion < 4.11) then
               Pack(TempPerformIOCheck,SizeOf(Boolean));
            Pack(CalculateCosts,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
            Unpack(TempRemoteID);
            Unpack(TempOptimizeLevel);
            with TFilter(FilterHandle) do
               begin
               RemoteID:=TempRemoteID;
               OptimizeLevel:=TempOptimizeLevel;
               end;
            end;
      finally
         EndRemoteRequest;
      end;
      end;
end;

procedure TDataCursor.AddFilterHandle(FilterHandle: Pointer;
                                      UseExisting: Boolean);
var
   I: Integer;
   FilterInserted: Boolean;   
begin
   if UseExisting then
      FFilters.Add(FilterHandle)
   else
      begin
      I:=0;
      FilterInserted:=False;
      while (I <= (FFilters.Count-1)) do
         begin
         if TFilter(FFilters[I]).UseExistingBitmaps then
            begin
            FFilters.Insert(I,FilterHandle);
            FilterInserted:=True;
            Break;
            end;
         Inc(I);
         end;
      if (not FilterInserted) then
         FFilters.Add(FilterHandle);
      end;
end;

procedure TDataCursor.DropFilter(FilterHandle: Pointer; NoRemoteCall: Boolean);
var
   I: Integer;
   FilterFound: Boolean;
   TempRemoteID: Integer;
begin
   FilterFound:=False;
   TempRemoteID:=0;
   if (FilterHandle=nil) then
      begin
      FilterFound:=True;
      DropAllFilters;
      end
   else
      begin
      for I:=0 to FFilters.Count-1 do
         begin
         if (FFilters[I]=FilterHandle) then
            begin
            with TFilter(FFilters[I]) do
               begin
               TempRemoteID:=RemoteID;
               Free;
               end;
            FFilters.Delete(I);
            FilterFound:=True;
            Break;
            end;
         end;
      end;
   CheckForActiveFilters;
   if FilterFound then
      begin
      if IsRemote then
         begin
         if (not NoRemoteCall) then
            begin
            StartRemoteRequest;
            try
               CheckForConnection;
               SetRequestCode(REQUEST_DROPFILTER);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               Pack(FBookmarkBuffer,BookmarkSize);
               Pack(FBOF,SizeOf(Boolean));
               Pack(FEOF,SizeOf(Boolean));
               Pack(TempRemoteID,SizeOf(Integer));
               EndPack;
               SendReceive;
               CheckForException;
               UnpackCursorInfo;
            finally
               EndRemoteRequest;
            end;
            end;
         end
      else
         begin
         CheckForChangeDetection;
         try
            { Version 5 }
            UpdateRange;
            { Version 5 }
            RebuildFilterBitmap;
            RebuildFilterKeys;
            RepositionCurrentRecord;
         finally
            ReadUnlockTable;
         end;
         end;
      end
   else
      DataEngine.RaiseError(DBISAM_NOSUCHFILTER,'','',ProperDataDirectoryName,
                              FTableName);
end;

procedure TDataCursor.ActivateFilter(FilterHandle: Pointer);
var
   I: Integer;
   FilterFound: Boolean;
   TempRemoteID: Integer;
   BeginTicks: Cardinal;
   EndTicks: Cardinal;
begin
   FilterFound:=False;
   TempRemoteID:=0;
   if (FilterHandle=nil) then
      begin
      FilterFound:=True;
      ActivateAllFilters;
      end
   else
      begin
      for I:=0 to FFilters.Count-1 do
         begin
         if (FFilters[I]=FilterHandle) then
            begin
            with TFilter(FFilters[I]) do
               begin
               TempRemoteID:=RemoteID;
               Activate;
               end;
            FilterFound:=True;
            Break;
            end;
         end;
      end;
   CheckForActiveFilters;
   if FilterFound then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_ACTIVATEFILTER);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(TempRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            if (RemoteEngineVersion >= 4.06) then
               Unpack(FFilterExecutionTime);
            UnpackCursorInfo;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         CheckForChangeDetection;
         try
            { Version 5 }
            UpdateRange;
            { Version 5 }
            BeginTicks:=OSGetTickCount;
            if (FilterHandle=nil) then
               UpdateAllFilters
            else
               UpdateFilter(FilterHandle);
            EndTicks:=OSGetTickCount;
            if (EndTicks > BeginTicks) then
               FFilterExecutionTime:=(OSCalcElapsedTime(BeginTicks,EndTicks)/1000)
            else
               FFilterExecutionTime:=0;
            RebuildFilterBitmap;
            RebuildFilterKeys;
            RepositionCurrentRecord;
         finally
            ReadUnlockTable;
         end;
         end;
      end
   else
      DataEngine.RaiseError(DBISAM_NOSUCHFILTER,'','',ProperDataDirectoryName,
                              FTableName);
end;

procedure TDataCursor.ResetFilter(FilterHandle: Pointer;
                                  RecordBuffer: PChar;
                                  ClientData: Integer;
                                  FieldCallback: pEvaluateFieldCallback;
                                  LocaleID: Integer);
begin
   CheckForChangeDetection;
   try
      TFilter(FilterHandle).ResetFilterExpression(RecordBuffer,
                                                  ClientData,FieldCallback,LocaleID);
      UpdateFilter(FilterHandle);
      RebuildFilterBitmap;
      RebuildFilterKeys;
      RepositionCurrentRecord;
   finally
      ReadUnlockTable;
   end;
end;

procedure TDataCursor.DeactivateFilter(FilterHandle: Pointer);
var
   I: Integer;
   FilterFound: Boolean;
   TempRemoteID: Integer;
begin
   FilterFound:=False;
   TempRemoteID:=0;
   if (FilterHandle=nil) then
      begin
      FilterFound:=True;
      DeactivateAllFilters;
      end
   else
      begin
      for I:=0 to FFilters.Count-1 do
         begin
         if (FFilters[I]=FilterHandle) then
            begin
            with TFilter(FFilters[I]) do
               begin
               TempRemoteID:=RemoteID;
               Deactivate;
               end;
            FilterFound:=True;
            Break;
            end;
         end;
      end;
   CheckForActiveFilters;
   if FilterFound then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            CheckForConnection;
            SetRequestCode(REQUEST_DEACTIVATEFILTER);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FBookmarkBuffer,BookmarkSize);
            Pack(FBOF,SizeOf(Boolean));
            Pack(FEOF,SizeOf(Boolean));
            Pack(TempRemoteID,SizeOf(Integer));
            EndPack;
            SendReceive;
            CheckForException;
            UnpackCursorInfo;
         finally
            EndRemoteRequest;
         end;
         end
      else
         begin
         CheckForChangeDetection;
         try
            { Version 5 }
            UpdateRange;
            { Version 5 }
            RebuildFilterBitmap;
            RebuildFilterKeys;
            RepositionCurrentRecord;
         finally
            ReadUnlockTable;
         end;
         end;
      end
   else
      DataEngine.RaiseError(DBISAM_NOSUCHFILTER,'','',ProperDataDirectoryName,
                              FTableName);
end;

procedure TDataCursor.ActivateAllFilters;
var
   I: Integer;
begin
   for I:=0 to FFilters.Count-1 do
      TFilter(FFilters[I]).Activate;
end;

procedure TDataCursor.DeactivateAllFilters;
var
   I: Integer;
begin
   for I:=0 to FFilters.Count-1 do
      TFilter(FFilters[I]).Deactivate;
end;

procedure TDataCursor.DropAllFilters;
var
   I: Integer;
begin
   I:=0;
   while (I < FFilters.Count) do
      begin
      TFilter(FFilters[I]).Free;
      FFilters.Delete(I);
      end;
   CheckForActiveFilters;
end;

procedure TDataCursor.CheckForActiveFilters;
var
   I: Integer;
begin
   FFiltersInEffect:=False;
   for I:=0 to FFilters.Count-1 do
      begin
      if TFilter(FFilters[I]).IsActive then
         begin
         FFiltersInEffect:=True;
         Break;
         end;
      end;
   if FFiltersInEffect or IsPhysicalNavigation then
      FFiltersInEffect:=True;
end;

function TDataCursor.UpdateFilter(FilterToUpdate: TFilter): Integer;
var
   I: Integer;
   { Version 5 }
   UpperOperator: TExpOperator;
   FirstOne: Boolean;
   { Version 5 }
begin
   Result:=DBISAM_NONE;
   { Version 5 }
   UpperOperator:=eoNOTDEFINED;
   { Version 5 }
   with FilterToUpdate do
      begin
      if IsActive then
         begin
         if (PhysicalRecordsUsed > 0) then
            begin
            { Allocate bitmap data }
            Self.FFilterBitmap.NumOfBits:=PhysicalRecordsUsed;
            if FRangeInEffect then
               begin
               UpdateRangeBitmap;
               FilterBitmap.Assign(FRangeBitmap);
               { Version 5 }
               UpperOperator:=eoAND;
               FirstOne:=False;
               { Version 5 }
               end
            else
               begin
               { Allocate bitmap data }
               FilterBitmap.NumOfBits:=Self.FFilterBitmap.NumOfBits;
               FilterBitmap.SetBits;
               { Version 5 }
               FirstOne:=True;
               { Version 5 }
               end;
            if (OptimizeLevel <> olFull) and UseExistingBitmaps then
               begin
               I:=0;
               { Version 5 }
               while (FFilters[I] <> FilterToUpdate) do
                  begin
                  if TFilter(FFilters[I]).IsActive then
                     begin
                     if FirstOne then
                        begin
                        FilterBitmap.Assign(TFilter(FFilters[I]).FilterBitmap);
                        FirstOne:=False;
                        end
                     else
                        FilterBitmap.AndBits(TFilter(FFilters[I]).FilterBitmap);
                     UpperOperator:=eoAND;
                     end;
                  Inc(I);
                  end;
               { Version 5 }
               end;
            { Version 5 }
            Update(UpperOperator);
            { Version 5 }
            end;
         end;
      end;
end;

function TDataCursor.GetFilterOptimizeLevel: TOptimizeLevel;
var
   I: Integer;
begin
   Result:=olNone;
   for I:=0 to FFilters.Count-1 do
      begin
      with TFilter(FFilters[I]) do
         begin
         if (I=0) then
            Result:=OptimizeLevel
         else
            Result:=EvaluateAndOptimizeLevels(Result,OptimizeLevel);
         end;
      end;
end;

function TDataCursor.EvaluateAndOptimizeLevels(LeftLevel: TOptimizeLevel;
                                               RightLevel: TOptimizeLevel): TOptimizeLevel;
begin
   Result:=olNone;
   if ((LeftLevel in [olNone,olPartial]) and (RightLevel in [olPartial,olFull])) or
      ((LeftLevel in [olPartial,olFull]) and (RightLevel in [olNone,olPartial])) then
      Result:=olPartial
   else if (LeftLevel=olFull) and (RightLevel=olFull) then
      Result:=olFull;
end;

function TDataCursor.EvaluateOrOptimizeLevels(LeftLevel: TOptimizeLevel;
                                              RightLevel: TOptimizeLevel): TOptimizeLevel;
begin
   Result:=olNone;
   if (LeftLevel=olFull) and (RightLevel=olFull) then
      Result:=olFull
   { Version 5 }
   else if (LeftLevel in [olPartial,olFull]) and (RightLevel in [olPartial,olFull]) then
      Result:=olPartial;
   { Version 5 }
end;

function TDataCursor.GetExpressionOptimizeLevel(NextToken: TExpToken;
                                                CalculateCosts: Boolean): TOptimizeLevel;
var
   CurIndexPos: Byte;
   AllConstants: Boolean;
   I: Integer;
begin
   { If the expression can be evaluated once then treat it as optimized }
   if (not ContainsFields(NextToken)) then
      begin
      { Version 5 }
      with NextToken do
         begin
         if CalculateCosts then
            begin
            OptimizeCount:=PhysicalRecordsUsed;
            OptimizeCost:=(Int64(PhysicalRecordSize)*OptimizeCount);
            end;
         OptimizeLevel:=olFull;
         Result:=olFull;
         end;
      { Version 5 }
      end
   else
      begin
      CurIndexPos:=FIndexPos;
      try
         with NextToken do
            begin
            if CalculateCosts then
               begin
               OptimizeCount:=PhysicalRecordsUsed;
               OptimizeCost:=(Int64(PhysicalRecordSize)*OptimizeCount);
               end;
            OptimizeLevel:=olNone;
            case TokenType of
               etUNARY:
                  begin
                  case TokenOperator of
                     eoNOT:
                        begin
                        OptimizeLevel:=GetExpressionOptimizeLevel(LeftExpToken,
                                                                  CalculateCosts);
                        if (OptimizeLevel in [olPartial,olFull]) then
                           begin
                           OptimizeLevel:=olPartial;
                           if CalculateCosts then
                              begin
                              OptimizeCount:=LeftExpToken.OptimizeCount;
                              OptimizeCost:=LeftExpToken.OptimizeCost;
                              { Add in record scan for deleted records to cost }
                              { Version 5 }
                              OptimizeCost:=(OptimizeCost+(Int64(PhysicalRecordSize)*
                                             (PhysicalRecordsUsed-(PhysicalRecordsUsed-OptimizeCount))));
                              { Version 5 }
                              end;
                           end;
                        end;
                     eoPLUS,eoMINUS:
                        begin
                        OptimizeLevel:=GetExpressionOptimizeLevel(LeftExpToken,
                                                                  CalculateCosts);
                        if CalculateCosts then
                           begin
                           OptimizeCount:=LeftExpToken.OptimizeCount;
                           OptimizeCost:=LeftExpToken.OptimizeCost;
                           end;
                        end;
                     end;
                  end;
               etBINARY:
                  begin
                  case TokenOperator of
                     eoAND,eoOR:
                        begin
                        GetExpressionOptimizeLevel(LeftExpToken,
                                                   CalculateCosts);
                        GetExpressionOptimizeLevel(RightExpToken,
                                                   CalculateCosts);
                        if CalculateCosts then
                           begin
                           if (TokenOperator=eoAND) then
                              begin
                              { Determine if we need to turn some optimized
                                expressions into scan expressions }
                              if (LeftExpToken.OptimizeCost < RightExpToken.OptimizeCost) then
                                 begin
                                 if ((LeftExpToken.OptimizeCount*Int64(PhysicalRecordSize)) <
                                      RightExpToken.OptimizeCost) then
                                    begin
                                    RightExpToken.OptimizeLevel:=olNone;
                                    RightExpToken.OptimizeCount:=LeftExpToken.OptimizeCount;
                                    RightExpToken.OptimizeCost:=(RightExpToken.OptimizeCount*
                                                                 Int64(PhysicalRecordSize));
                                    { Version 5 }
                                    OptimizeCount:=MinimumInteger(LeftExpToken.OptimizeCount,
                                                                  RightExpToken.OptimizeCount);
                                    { Version 5 }
                                    OptimizeCost:=(LeftExpToken.OptimizeCost+
                                                   RightExpToken.OptimizeCost);
                                    end
                                 else
                                    { Version 5 }
                                    begin
                                    OptimizeCount:=MinimumInteger(LeftExpToken.OptimizeCount,
                                                                  RightExpToken.OptimizeCount);
                                    OptimizeCost:=(LeftExpToken.OptimizeCost+
                                                   RightExpToken.OptimizeCost);
                                    end;
                                    { Version 5 }
                                 end
                              else if (LeftExpToken.OptimizeCost > RightExpToken.OptimizeCost) then
                                 begin
                                 if ((RightExpToken.OptimizeCount*Int64(PhysicalRecordSize)) <
                                      LeftExpToken.OptimizeCost) then
                                    begin
                                    LeftExpToken.OptimizeLevel:=olNone;
                                    LeftExpToken.OptimizeCount:=RightExpToken.OptimizeCount;
                                    LeftExpToken.OptimizeCost:=(RightExpToken.OptimizeCount*
                                                                Int64(PhysicalRecordSize));
                                    { Version 5 }
                                    OptimizeCount:=MinimumInteger(LeftExpToken.OptimizeCount,
                                                                  RightExpToken.OptimizeCount);
                                    { Version 5 }
                                    OptimizeCost:=(LeftExpToken.OptimizeCost+
                                                   RightExpToken.OptimizeCost);
                                    end
                                 else
                                    { Version 5 }
                                    begin
                                    OptimizeCount:=MinimumInteger(LeftExpToken.OptimizeCount,
                                                                  RightExpToken.OptimizeCount);
                                    OptimizeCost:=(LeftExpToken.OptimizeCost+
                                                   RightExpToken.OptimizeCost);
                                    end;
                                    { Version 5 }
                                 end
                              else
                                 begin
                                 { Version 5 }
                                 OptimizeCount:=MinimumInteger(LeftExpToken.OptimizeCount,
                                                               RightExpToken.OptimizeCount);
                                 { Version 5 }
                                 OptimizeCost:=LeftExpToken.OptimizeCost;
                                 end;
                              OptimizeLevel:=EvaluateAndOptimizeLevels(LeftExpToken.OptimizeLevel,
                                                                       RightExpToken.OptimizeLevel)
                              end
                           else
                              begin
                              OptimizeLevel:=EvaluateOrOptimizeLevels(LeftExpToken.OptimizeLevel,
                                                                      RightExpToken.OptimizeLevel);
                              { Version 5 }
                              if (OptimizeLevel in [olPartial,olFull]) then
                              { Version 5 }
                                 begin
                                 { Version 5 }
                                 OptimizeCount:=(LeftExpToken.OptimizeCount+
                                                 RightExpToken.OptimizeCount);
                                 OptimizeCost:=(LeftExpToken.OptimizeCost+
                                                RightExpToken.OptimizeCost);
                                 { Version 5 }
                                 end;
                              end;
                           end
                        else
                           begin
                           if (TokenOperator=eoAND) then
                              OptimizeLevel:=EvaluateAndOptimizeLevels(LeftExpToken.OptimizeLevel,
                                                                       RightExpToken.OptimizeLevel)
                           else
                              OptimizeLevel:=EvaluateOrOptimizeLevels(LeftExpToken.OptimizeLevel,
                                                                      RightExpToken.OptimizeLevel);
                           end;
                        end;
                     eoEQ,eoNE,eoLT,eoGT,eoLE,eoGE:
                        begin
                        if (not IsTextSearchFunc(LeftExpToken)) and
                           ((LeftExpToken.TokenType=etFIELD) or
                            (CaseInsensitive and IsCaseInsensitiveField(LeftExpToken))) then
                           begin
                           if (RightExpToken.TokenType=etCONST) then
                              begin
                              if IsCaseInsensitiveField(LeftExpToken) then
                                 begin
                                 if ChangeToIndexForFields(LeftExpToken.ArgumentExpToken[0].FieldNumber,
                                                          True,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken.ArgumentExpToken[0],
                                                                           RightExpToken,0);
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end
                              else
                                 begin
                                 if ChangeToIndexForFields(LeftExpToken.FieldNumber,
                                                          False,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken,
                                                                           RightExpToken,0);
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end;
                              end;
                           end
                        else if IsTextSearchFunc(LeftExpToken) then
                           begin
                           if (RightExpToken.TokenType=etCONST) and
                              IsTextIndexed(LeftExpToken.ArgumentExpToken[1].FieldNumber) then
                              begin
                              OptimizeLevel:=olFull;
                              if CalculateCosts then
                                 begin
                                 InternalSetIndexPos(TEXT_INDEX_POS);
                                 { Version 5 }
                                 if (not FNoKeyStatistics) then
                                    OptimizeCount:=GetTextSearchOptimizationCount(
                                                       LeftExpToken.ArgumentExpToken[1].FieldNumber,
                                                       LeftExpToken.ArgumentExpToken[1].FieldName,
                                                       LeftExpToken.ArgumentExpToken[0].Value,
                                                       LeftExpToken.ArgumentExpToken[0].DataSize-1)
                                 else
                                    OptimizeCount:=0;
                                 { Version 5 }
                                 OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                 { Version 5 }
                                 if (FKeyCompressionType=NO_COMPRESS) then
                                    OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                 else
                                    OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                 { Version 5 }
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               etEXTBINARY:
                  begin
                  case TokenOperator of
                     eoBETWEEN,eoNOTBETWEEN:
                        begin
                        if (ArgumentExpToken[0].TokenType=etFIELD) or
                            (CaseInsensitive and IsCaseInsensitiveField(ArgumentExpToken[0])) then
                           begin
                           if (ArgumentExpToken[1].TokenType=etCONST) and
                              (ArgumentExpToken[2].TokenType=etCONST) then
                              begin
                              if IsCaseInsensitiveField(ArgumentExpToken[0]) then
                                 begin
                                 if ChangeToIndexForFields(ArgumentExpToken[0].ArgumentExpToken[0].FieldNumber,
                                                          True,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       OptimizeCount:=MinimumInteger(GetOptimizationCount(eoGE,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                     ArgumentExpToken[1],0),
                                                                     GetOptimizationCount(eoLE,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                     ArgumentExpToken[2],0));
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end
                              else
                                 begin
                                 if ChangeToIndexForFields(ArgumentExpToken[0].FieldNumber,
                                                          False,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       OptimizeCount:=MinimumInteger(GetOptimizationCount(eoGE,ArgumentExpToken[0],
                                                                     ArgumentExpToken[1],0),
                                                                     GetOptimizationCount(eoLE,ArgumentExpToken[0],
                                                                     ArgumentExpToken[2],0));
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end;
                              end;
                           end;
                        end;
                     eoIN,eoNOTIN:
                        begin
                        if (ArgumentExpToken[0].TokenType=etFIELD) or
                            (CaseInsensitive and IsCaseInsensitiveField(ArgumentExpToken[0])) then
                           begin
                           AllConstants:=True;
                           for I:=1 to ArgumentExpTokens.Count-1 do
                              begin
                              { Version 5 }
                              if (ArgumentExpToken[I].TokenType <> etCONST) then
                              { Version 5 }
                                 begin
                                 AllConstants:=False;
                                 Break;
                                 end;
                              end;
                           if AllConstants then
                              begin
                              if IsCaseInsensitiveField(ArgumentExpToken[0]) then
                                 begin
                                 if ChangeToIndexForFields(ArgumentExpToken[0].ArgumentExpToken[0].FieldNumber,
                                                          True,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       if (TokenOperator=eoIN) then
                                          begin
                                          for I:=1 to ArgumentExpTokens.Count-1 do
                                             begin
                                             { Version 5 }
                                             if (I > 1) then
                                                OptimizeCount:=(OptimizeCount+
                                                                GetOptimizationCount(eoEQ,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0))
                                             else
                                                OptimizeCount:=GetOptimizationCount(eoEQ,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0);
                                             { Version 5 }
                                             end;
                                          end
                                       else
                                          begin
                                          for I:=1 to ArgumentExpTokens.Count-1 do
                                             begin
                                             { Version 5 }
                                             if (I > 1) then
                                                OptimizeCount:=(OptimizeCount+
                                                            GetOptimizationCount(eoNE,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0))
                                             else
                                                OptimizeCount:=GetOptimizationCount(eoNE,ArgumentExpToken[0].ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0);
                                             { Version 5 }
                                             end;
                                          end;
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end
                              else
                                 begin
                                 if ChangeToIndexForFields(ArgumentExpToken[0].FieldNumber,
                                                          False,False) then
                                    begin
                                    OptimizeLevel:=olFull;
                                    if CalculateCosts then
                                       begin
                                       if (TokenOperator=eoIN) then
                                          begin
                                          for I:=1 to ArgumentExpTokens.Count-1 do
                                             begin
                                             { Version 5 }
                                             if (I > 1) then
                                                OptimizeCount:=(OptimizeCount+
                                                            GetOptimizationCount(eoEQ,ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0))
                                             else
                                                OptimizeCount:=GetOptimizationCount(eoEQ,ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0);
                                             { Version 5 }
                                             end;
                                          end
                                       else
                                          begin
                                          for I:=1 to ArgumentExpTokens.Count-1 do
                                             begin
                                             { Version 5 }
                                             if (I > 1) then
                                                OptimizeCount:=(OptimizeCount+
                                                            GetOptimizationCount(eoNE,ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0))
                                             else
                                                OptimizeCount:=GetOptimizationCount(eoNE,ArgumentExpToken[0],
                                                                        ArgumentExpToken[I],0);
                                             { Version 5 }
                                             end;
                                          end;
                                       OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                       { Version 5 }
                                       if (FKeyCompressionType=NO_COMPRESS) then
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                       else
                                          OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                       { Version 5 }
                                       end;
                                    end;
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               etCOMPARE:
                  begin
                  if (LeftExpToken.TokenType=etFIELD) or
                     (CaseInsensitive and IsCaseInsensitiveField(LeftExpToken)) then
                     begin
                     if (RightExpToken.TokenType=etCONST) then
                        begin
                        if IsCaseInsensitiveField(LeftExpToken) then
                           begin
                           if ChangeToIndexForFields(LeftExpToken.ArgumentExpToken[0].FieldNumber,
                                                    True,False) then
                              begin
                              { Version 5 }
                              if (TokenOperator=eoNE) and (PartialLength <> 0) then
                                 begin
                                 OptimizeLevel:=olPartial;
                                 if CalculateCosts then
                                    begin
                                    OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken.ArgumentExpToken[0],
                                                               RightExpToken,PartialLength);
                                    OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                    { Version 5 }
                                    if (FKeyCompressionType=NO_COMPRESS) then
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                    else
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                    { Version 5 }
                                    { Add in record scan for deleted records to cost }
                                    OptimizeCost:=(OptimizeCost+(Int64(PhysicalRecordSize)*
                                                   (PhysicalRecordsUsed-(PhysicalRecordsUsed-OptimizeCount))));
                                    end;
                                 end
                              { Version 5 }
                              else
                                 begin
                                 OptimizeLevel:=olFull;
                                 if CalculateCosts then
                                    begin
                                    OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken.ArgumentExpToken[0],
                                                            RightExpToken,PartialLength);
                                    OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                    { Version 5 }
                                    if (FKeyCompressionType=NO_COMPRESS) then
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                    else
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                    { Version 5 }
                                    end;
                                 end;
                              end;
                           end
                        else
                           begin
                           if ChangeToIndexForFields(LeftExpToken.FieldNumber,
                                                    CaseInsensitive,False) then
                              begin
                              { Version 5 }
                              if (TokenOperator=eoNE) and (PartialLength <> 0) then
                                 begin
                                 OptimizeLevel:=olPartial;
                                 if CalculateCosts then
                                    begin
                                    OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken,
                                                            RightExpToken,PartialLength);
                                    OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                    { Version 5 }
                                    if (FKeyCompressionType=NO_COMPRESS) then
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                    else
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                    { Version 5 }
                                    { Add in record scan for deleted records to cost }
                                    OptimizeCost:=(OptimizeCost+(Int64(PhysicalRecordSize)*
                                                  (PhysicalRecordsUsed-(PhysicalRecordsUsed-OptimizeCount))));
                                    end;
                                 end
                              { Version 5 }
                              else
                                 begin
                                 OptimizeLevel:=olFull;
                                 if CalculateCosts then
                                    begin
                                    OptimizeCount:=GetOptimizationCount(TokenOperator,LeftExpToken,
                                                            RightExpToken,PartialLength);
                                    OptimizeCost:=(Int64(KeySize)*OptimizeCount);
                                    { Version 5 }
                                    if (FKeyCompressionType=NO_COMPRESS) then
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*UNCOMPRESS_PAGE_SLACK_FACTOR))
                                    else
                                       OptimizeCost:=(OptimizeCost+Trunc(OptimizeCost*COMPRESS_PAGE_SLACK_FACTOR));
                                    { Version 5 }
                                    end;
                                 end;
                              end;
                           end;
                        end;
                     end;
                  end;
               end;
            Result:=OptimizeLevel;
            end;
      finally
         InternalSetIndexPos(CurIndexPos);
      end;
      end;
end;

function TDataCursor.RewriteExpression(NextToken: TExpToken;
                                       UseCosts: Boolean): Boolean;
var
   TempToken: TExpToken;
   TempLeftResult: Boolean;
   TempRightResult: Boolean;
   TempLeftToken: TExpToken;
   TempRightToken: TExpToken;
begin
   Result:=False;
   with NextToken do
      begin
      Level:=1;
      if (TokenType=etBINARY) and (TokenOperator=eoAND) then
         begin
         TempLeftToken:=GetSmallestCost(NextToken,LeftExpToken,UseCosts);
         TempRightToken:=GetSmallestCost(NextToken,RightExpToken,UseCosts);
         TempToken:=CompareCosts(TempLeftToken,TempRightToken,UseCosts);
         if (TempToken=TempLeftToken) then
            begin
            if (TempLeftToken.Level > TempRightToken.Level) then
               begin
               { And finally switch them around for the current token }
               SwitchTokens(TempLeftToken,TempRightToken);
               ReverseBinaryTokens(NextToken);
               Result:=True;
               end;
            end
         else if (TempToken=TempRightToken) then
            begin
            Result:=True;
            if (TempRightToken.Level > TempLeftToken.Level) then
               SwitchTokens(TempLeftToken,TempRightToken)
            else
               ReverseBinaryTokens(NextToken);
            end;
         { Now recurse }
         TempLeftResult:=RewriteExpression(LeftExpToken,UseCosts);
         TempRightResult:=RewriteExpression(RightExpToken,UseCosts);
         if (not Result) then
            Result:=(TempLeftResult or TempRightResult);
         end;
      end;
end;

function TDataCursor.GetSmallestCost(UpperToken: TExpToken;
                                     NextToken: TExpToken;
                                     UseCosts: Boolean): TExpToken;
var
   TempLeftToken: TExpToken;
   TempRightToken: TExpToken;
begin
   with NextToken do
      begin
      if (TokenType=etBINARY) and (TokenOperator=eoAND) then
         begin
         { Assign the levels }
         LeftExpToken.UpperExpToken:=NextToken;
         LeftExpToken.Level:=Level+1;
         RightExpToken.UpperExpToken:=NextToken;
         RightExpToken.Level:=Level+1;
         { Now recurse to get the lower costs }
         TempLeftToken:=GetSmallestCost(NextToken,LeftExpToken,UseCosts);
         TempRightToken:=GetSmallestCost(NextToken,RightExpToken,UseCosts);
         Result:=CompareCosts(TempLeftToken,TempRightToken,UseCosts);
         end
      else
         begin
         NextToken.UpperExpToken:=UpperToken;
         Result:=NextToken;
         end;
      end;
end;

function TDataCursor.CompareCosts(LeftToken: TExpToken;
                                  RightToken: TExpToken;
                                  UseCosts: Boolean): TExpToken;
begin
   { Only use costs if the flag is set and the costs are different, if the
     costs are the same (usually 0 due to no conditions being met) then
     evaluate them based upon the optimization level instead (is an index
     available or not) }
   if UseCosts and (LeftToken.OptimizeCost <> RightToken.OptimizeCost) then
      begin
      { Don't switch around the tokens if the right token's optimize
        level is none and the left token's optimize level is not, but
        the cost for the right token is less.  This means that the
        cost was calculated based upon a record scan of the results of
        the left token, which we don't want to mess with. }
      if (LeftToken.OptimizeCost > RightToken.OptimizeCost) and
         ((RightToken.OptimizeLevel <> olNone) or
          ((RightToken.OptimizeLevel=olNone) and (LeftToken.OptimizeLevel=olNone))) then
         Result:=RightToken
      else
         Result:=LeftToken;
      end
   else
      begin
      if ((LeftToken.OptimizeLevel=olNone) and
          (RightToken.OptimizeLevel in [olPartial,olFull])) or
         ((LeftToken.OptimizeLevel=olPartial) and
          (RightToken.OptimizeLevel=olFull)) then
         Result:=RightToken
      else
         Result:=LeftToken;
      end;
end;

procedure TDataCursor.UpdateRangeBitmap;
begin
   if FRangeInEffect then
      begin
      FRangeBitmap.NumOfBits:=FFilterBitmap.NumOfBits;
      { Version 5 }
      NavigateIndexedRecords(@FBeginBuffer,@FEndBuffer,
                             FRangeBitmap);
      { Version 5 }
      end;
end;

procedure TDataCursor.UpdateAllFilters;
var
   I: Integer;
   J: Integer;
   { Version 5 }
   UpperOperator: TExpOperator;
   FirstOne: Boolean;
   { Version 5 }
begin
   if FFiltersInEffect then
      begin
      { Version 5 }
      UpperOperator:=eoNOTDEFINED;
      { Version 5 }
      if (PhysicalRecordsUsed > 0) then
         begin
         FFilterBitmap.NumOfBits:=PhysicalRecordsUsed;
         UpdateRangeBitmap;
         for I:=0 to FFilters.Count-1 do
            begin
            with TFilter(FFilters[I]) do
               begin
               if IsActive then
                  begin
                  if FRangeInEffect then
                     begin
                     FilterBitmap.Assign(FRangeBitmap);
                     { Version 5 }
                     UpperOperator:=eoAND;
                     FirstOne:=False;
                     { Version 5 }
                     end
                  else
                     begin
                     { Allocate bitmap data }
                     FilterBitmap.NumOfBits:=Self.FFilterBitmap.NumOfBits;
                     FilterBitmap.SetBits;
                     { Version 5 }
                     FirstOne:=True;
                     { Version 5 }
                     end;
                  if (OptimizeLevel <> olFull) and UseExistingBitmaps then
                     begin
                     J:=0;
                     { Version 5 }
                     while (FFilters[J] <> FFilters[I]) do
                        begin
                        if TFilter(FFilters[J]).IsActive then
                           begin
                           if FirstOne then
                              begin
                              FilterBitmap.Assign(TFilter(FFilters[J]).FilterBitmap);
                              FirstOne:=False;
                              end
                           else
                              FilterBitmap.AndBits(TFilter(FFilters[J]).FilterBitmap);
                           UpperOperator:=eoAND;
                           end;
                        Inc(J);
                        end;
                     { Version 5 }
                     end;
                  { Version 5 }
                  Update(UpperOperator);
                  { Version 5 }
                  end;
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.RebuildFilterBitmap;
var
   I: Integer;
   { Version 5 }
   FirstOne: Boolean;
   { Version 5 }
begin
   if FFiltersInEffect then
      begin
      if (PhysicalRecordsUsed > 0) then
         begin
         { Reset filter record count }
         FFilterRecordCount:=PhysicalRecordsUsed;
         if FRangeInEffect then
            begin
            FFilterBitmap.Assign(FRangeBitmap);
            if (FFilters.Count > 0) then
               begin
               for I:=0 to FFilters.Count-1 do
                  begin
                  if TFilter(FFilters[I]).IsActive then
                     FFilterBitmap.AndBits(TFilter(FFilters[I]).FilterBitmap);
                  end;
               end;
            FFilterRecordCount:=FFilterBitmap.GetTotalBitsSet;
            { Version 5 }
            { Adjust record count, if necesssary, for callback filters }
            if (FFilterRecordCount > TotalRecordCount) then
               FFilterRecordCount:=TotalRecordCount;
            { Version 5 }
            end
         else
            begin
            FFilterBitmap.SetBits;
            if (FFilters.Count > 0) then
               begin
               { Version 5 }
               FirstOne:=True;
               for I:=0 to FFilters.Count-1 do
                  begin
                  if TFilter(FFilters[I]).IsActive then
                     begin
                     if FirstOne then
                        begin
                        FFilterBitmap.Assign(TFilter(FFilters[I]).FilterBitmap);
                        FirstOne:=False;
                        end
                     else
                        FFilterBitmap.AndBits(TFilter(FFilters[I]).FilterBitmap);
                     end;
                  end;
               FFilterRecordCount:=FFilterBitmap.GetTotalBitsSet;
               { Version 5 }
               end
            else
               FFilterRecordCount:=TotalRecordCount;
            end;
         end
      else
         FFilterRecordCount:=0;
      end;
end;

procedure TDataCursor.RebuildFilterKeys;
var
   TempRecordNumber: Integer;
   TempRecord: TRecord;
   TempFilterKeyBuffer: pFilterKeyBuffer;
begin
   if FFiltersInEffect then
      begin
      FreeFilterKeys;
      if (PhysicalRecordsUsed > 0) then
         begin
         if (not IsPhysicalNavigation) and (not FRangeInEffect) and
            (FFilterRecordCount > 0) and
            (((FFilterRecordCount/PhysicalRecordsUsed)*100) <= DataEngine.FilterIndexThreshhold) then
            begin
            FFilterKeys.Capacity:=FFilterRecordCount;
            FFilterKeyIndexPos:=FIndexPos;
            TempRecordNumber:=0;
            { Version 5 }
            try
               while FFilterBitmap.GetNextBitsSet(TempRecordNumber,1) do
                  begin
                  if (not GetRecord(TempRecordNumber,True,READ_CURRENT,TempRecord)) then
                     GetRecord(TempRecordNumber,True,READ_CURRENT,TempRecord);
                  try
                     TempFilterKeyBuffer:=AllocMem(SizeOf(TFilterKeyBuffer));
                     TempFilterKeyBuffer^.Cursor:=Self;
                     GetKeyValues(TempRecord.Buffer,@TempFilterKeyBuffer^.KeyBuffer);
                     FFilterKeys.Add(TempFilterKeyBuffer);
                  finally
                     PutRecord(TempRecord);
                  end;
                  end;
            finally
               ReadUnlockTable;
            end;
            { Version 5 }
            FFilterKeys.Sort(CompareFilterKeys);
            end;
         end;
      end;
end;

{ Version 5 }
function TDataCursor.VerifyRecordInSet(RecordToVerify: Integer;
                                       RecordBuffer: PChar): Boolean;
var
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   CompareResult: Integer;
   TempResult: Boolean;
begin
   Result:=True;
   if (PhysicalRecordsUsed > 0) then
      begin
      if (FIndexPos <> PHYSICAL_INDEX_POS) then
         begin
         if (GetRecordStatus(RecordBuffer)=RECORD_DELETED) then
            begin
            Result:=False;
            if FFiltersInEffect then
               begin
               if FRangeInEffect then
                  begin
                  FRangeBitmap.NumOfBits:=PhysicalRecordsUsed;
                  FRangeBitmap.ClearBit(RecordToVerify);
                  end;
               FFilterBitmap.NumOfBits:=PhysicalRecordsUsed;
               for I:=0 to FFilters.Count-1 do
                  begin
                  with TFilter(FFilters[I]) do
                     begin
                     if IsActive then
                        DeleteRecord(RecordToVerify);
                     end;
                  end;
               end;
            end
         else
            begin
            if FFiltersInEffect then
               begin
               if FRangeInEffect then
                  begin
                  FRangeBitmap.NumOfBits:=PhysicalRecordsUsed;
                  GetKeyValues(RecordBuffer,@TempKeyBuffer);
                  CompareResult:=CompareKeys(@TempKeyBuffer,@FBeginBuffer,
                                             FKeySize);
                  if (CompareResult=CMP_EQUAL) or (CompareResult=CMP_GREATER) then
                     begin
                     CompareResult:=CompareKeys(@TempKeyBuffer,@FEndBuffer,
                                                FKeySize);
                     if (CompareResult=CMP_EQUAL) or (CompareResult=CMP_LESS) then
                        FRangeBitmap.SetBit(RecordToVerify)
                     else
                        begin
                        Result:=False;
                        FRangeBitmap.ClearBit(RecordToVerify);
                        end;
                     end
                  else
                     begin
                     Result:=False;
                     FRangeBitmap.ClearBit(RecordToVerify);
                     end;
                  end;
               for I:=0 to FFilters.Count-1 do
                  begin
                  with TFilter(FFilters[I]) do
                     begin
                     if IsActive then
                        TempResult:=VerifyRecord(RecordToVerify,RecordBuffer)
                     else
                        TempResult:=True;
                     Result:=(Result and TempResult);
                     end;
                  end;
               end
            else if FRangeInEffect then
               begin
               GetKeyValues(RecordBuffer,@TempKeyBuffer);
               CompareResult:=CompareKeys(@TempKeyBuffer,@FBeginBuffer,
                                          FKeySize);
               if (CompareResult=CMP_EQUAL) or (CompareResult=CMP_GREATER) then
                  begin
                  CompareResult:=CompareKeys(@TempKeyBuffer,@FEndBuffer,
                                             FKeySize);
                  if (CompareResult=CMP_GREATER) then
                     Result:=False;
                  end
               else
                  Result:=False;
               end;
            end;
         end;
      end
   else
      Result:=False;
end;
{ Version 5 }

procedure TDataCursor.UpdateRecordInBitmap(RecordToUpdate: Integer;
                                           RecordBuffer: PChar);
var
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   CompareResult: Integer;
begin
   if FFiltersInEffect then
      begin
      if (PhysicalRecordsUsed > 0) then
         begin
         FFilterBitmap.NumOfBits:=PhysicalRecordsUsed;
         if FRangeInEffect then
            begin
            { Version 5 }
            FRangeBitmap.NumOfBits:=PhysicalRecordsUsed;
            { Version 5 }
            GetKeyValues(RecordBuffer,@TempKeyBuffer);
            CompareResult:=CompareKeys(@TempKeyBuffer,@FBeginBuffer,
                                       FKeySize);
            if (CompareResult=CMP_EQUAL) or (CompareResult=CMP_GREATER) then
               begin
               CompareResult:=CompareKeys(@TempKeyBuffer,@FEndBuffer,
                                          FKeySize);
               if (CompareResult=CMP_EQUAL) or (CompareResult=CMP_LESS) then
                  FRangeBitmap.SetBit(RecordToUpdate)
               else
                  FRangeBitmap.ClearBit(RecordToUpdate);
               end
            else
               FRangeBitmap.ClearBit(RecordToUpdate);
            end;
         for I:=0 to FFilters.Count-1 do
            begin
            with TFilter(FFilters[I]) do
               begin
               if IsActive then
                  UpdateRecord(RecordToUpdate,RecordBuffer);
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.UpdateRecordFilterKey(RecordToUpdate: Integer;
                                            RecordBuffer: PChar;
                                            OldRecordBuffer: PChar);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempFilterKeyPos: Integer;
   TempFilterKeyBuffer: pFilterKeyBuffer;
begin
   if FFiltersInEffect and (FFilterKeys.Count > 0) then
      begin
      GetKeyValues(OldRecordBuffer,@TempKeyBuffer);
      if SearchFilterKeys(@TempKeyBuffer,TempFilterKeyPos) then
         begin
         TempFilterKeyBuffer:=FFilterKeys[TempFilterKeyPos];
         FFilterKeys.Delete(TempFilterKeyPos);
         end
      else
         begin
         TempFilterKeyBuffer:=AllocMem(SizeOf(TFilterKeyBuffer));
         TempFilterKeyBuffer^.Cursor:=Self;
         end;
      if (PhysicalRecordsUsed > 0) and (FFilterRecordCount > 0) and
         FFilterBitmap.IsBitSet(RecordToUpdate) then
         begin
         GetKeyValues(RecordBuffer,@TempFilterKeyBuffer^.KeyBuffer);
         SearchFilterKeys(@TempFilterKeyBuffer^.KeyBuffer,TempFilterKeyPos);
         FFilterKeys.Insert(TempFilterKeyPos,TempFilterKeyBuffer);
         end
      else
         DeAllocMem(TempFilterKeyBuffer);         
      end;
end;

procedure TDataCursor.DeleteRecordInBitmap(RecordDeleted: Integer);
var
   I: Integer;
begin
   if FFiltersInEffect then
      begin
      if (PhysicalRecordsUsed > 0) then
         begin
         if FRangeInEffect then
            FRangeBitmap.ClearBit(RecordDeleted);
         for I:=0 to FFilters.Count-1 do
            begin
            with TFilter(FFilters[I]) do
               begin
               if IsActive then
                  DeleteRecord(RecordDeleted);
               end;
            end;
         Dec(FFilterRecordCount);
         end;
      end;
end;

procedure TDataCursor.DeleteRecordFilterKey(RecordBuffer: PChar);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempFilterKeyPos: Integer;
   TempFilterKeyBuffer: pFilterKeyBuffer;
begin
   if FFiltersInEffect and (FFilterKeys.Count > 0) then
      begin
      GetKeyValues(RecordBuffer,@TempKeyBuffer);
      if SearchFilterKeys(@TempKeyBuffer,TempFilterKeyPos) then
         begin
         TempFilterKeyBuffer:=FFilterKeys[TempFilterKeyPos];         
         DeAllocMem(TempFilterKeyBuffer);
         FFilterKeys.Delete(TempFilterKeyPos);
         end;
      end;
end;

function TDataCursor.CountIndexedRecords(FirstBuffer: PChar;
                                         SecondBuffer: PChar): Integer;
var
   ParentPage: TPage;
   ChildPage: TPage;
   BeginNumber: Integer;
   EndNumber: Integer;
   TempKeyCounter: Integer;
   CompareResult: Integer;
   PageFound: Boolean;
   { Version 5 }
   RetryCount: Boolean;
   { Version 5 }
begin
   { Check to make sure that the begin and end buffers are not crossed }
   CompareResult:=CompareKeys(FirstBuffer,SecondBuffer,FKeySize);
   if (CompareResult=CMP_LESS) or
      (CompareResult=CMP_EQUAL) then
      begin
      try
         RetryCount:=True;
         while RetryCount do
            begin
            RetryCount:=False;
            PageFound:=GetRootPage(ParentPage,RetryCount);
            if (not RetryCount) then
               begin
               if PageFound then
                  begin
                  try
                     BeginNumber:=1;
                     TempKeyCounter:=1;
                     while True do
                        begin
                        BeginRangeScan(ParentPage,BeginNumber,TempKeyCounter,FirstBuffer);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryCount:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                    ChildPage));
                           if RetryCount then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryCount) then
                        begin
                        if (CompareKeys(ParentPage.GetKey(TempKeyCounter),FirstBuffer,
                                        FKeySize)=CMP_LESS) then
                           begin
                           PageFound:=GotoRightPage(ParentPage,RetryCount,TempKeyCounter);
                           if (not RetryCount) then
                              begin
                              if PageFound then
                                 begin
                                 CompareResult:=CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                                            FirstBuffer,FKeySize);
                                 if (CompareResult=CMP_GREATER) or
                                    (CompareResult=CMP_EQUAL) then
                                    Inc(BeginNumber,ParentPage.GetLowerKeyCount(TempKeyCounter))
                                 else
                                    BeginNumber:=0;
                                 end
                              else
                                 BeginNumber:=0;
                              end;
                           end;
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end
               else
                  BeginNumber:=0;
               PageFound:=GetRootPage(ParentPage,RetryCount);
               if (not RetryCount) then
                  begin
                  if PageFound then
                     begin
                     try
                        EndNumber:=1;
                        TempKeyCounter:=1;
                        while True do
                           begin
                           EndRangeScan(ParentPage,EndNumber,TempKeyCounter,SecondBuffer);
                           if (ParentPage.PageType > INTERNAL_NODE) then
                              Break
                           else
                              begin
                              RetryCount:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                        ChildPage));
                              if RetryCount then
                                 begin
                                 ParentPage:=nil;
                                 Break;
                                 end
                              else
                                 begin
                                 PutPage(ParentPage);
                                 ParentPage:=ChildPage;
                                 end;
                              end;
                           end;
                        if (not RetryCount) then
                           begin
                           if (CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                           SecondBuffer,FKeySize)=CMP_GREATER) then
                              begin
                              PageFound:=GotoLeftPage(ParentPage,RetryCount,TempKeyCounter);
                              if (not RetryCount) then
                                 begin
                                 if PageFound then
                                    begin
                                    CompareResult:=CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                                               SecondBuffer,FKeySize);
                                    if (CompareResult=CMP_LESS) or
                                       (CompareResult=CMP_EQUAL) then
                                       Dec(EndNumber,ParentPage.GetLowerKeyCount(TempKeyCounter))
                                    else
                                       EndNumber:=0;
                                    end
                                 else
                                    EndNumber:=0;
                                 end;
                              end;
                           end;
                     finally
                        PutPage(ParentPage);
                     end;
                     end
                  else
                     EndNumber:=0;
                  end;
               end;
            end;
      finally
         ReadUnlockTable;
      end;
      end
   else
      begin
      BeginNumber:=0;
      EndNumber:=0;
      end;
   if (BeginNumber > 0) and (EndNumber > 0) then
      Result:=(EndNumber-BeginNumber)+1
   else
      Result:=0;
end;

procedure TDataCursor.NavigateIndexedRecords(FirstBuffer: PChar;
                                             SecondBuffer: PChar;
                                             Bitmap: TRecordsBitmap);
var
   ParentPage: TPage;
   ChildPage: TPage;
   CompareResult: Integer;
   TempKeyCounter: Integer;
   PageFound: Boolean;
   { Version 5 }
   RetryFilter: Boolean;
   { Version 5 }
begin
   Bitmap.ClearBits;
   { Check to make sure that the first and second buffers are not crossed }
   CompareResult:=CompareKeys(FirstBuffer,SecondBuffer,FKeySize);
   if (CompareResult=CMP_LESS) or
      (CompareResult=CMP_EQUAL) then
      begin
      try
         RetryFilter:=True;
         while RetryFilter do
            begin
            RetryFilter:=False;
            PageFound:=GetRootPage(ParentPage,RetryFilter);
            if (not RetryFilter) then
               begin
               if PageFound then
                  begin
                  try
                     TempKeyCounter:=1;
                     while True do
                        begin
                        BeginScan(ParentPage,TempKeyCounter,FirstBuffer);
                        if (ParentPage.PageType > INTERNAL_NODE) then
                           Break
                        else
                           begin
                           RetryFilter:=(not GetPage(ParentPage.GetRecordNumber(TempKeyCounter),
                                                     ChildPage));
                           if RetryFilter then
                              begin
                              ParentPage:=nil;
                              Break;
                              end
                           else
                              begin
                              PutPage(ParentPage);
                              ParentPage:=ChildPage;
                              end;
                           end;
                        end;
                     if (not RetryFilter) then
                        begin
                        if (CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                        FirstBuffer,FKeySize)=CMP_LESS) then
                           begin
                           PageFound:=GotoRightPage(ParentPage,RetryFilter,TempKeyCounter);
                           if RetryFilter then
                              Exit
                           else if PageFound then
                              begin
                              if (CompareKeys(ParentPage.GetKey(TempKeyCounter),
                                              FirstBuffer,FKeySize)=CMP_LESS) then
                                 Exit;
                              end
                           else
                              Exit;
                           end;
                        { Start looping through records and setting record bits in
                          bitmap }
                        FilterSetIndexedBits(ParentPage,Bitmap,SecondBuffer,
                                             TempKeyCounter,RetryFilter);
                        end;
                  finally
                     PutPage(ParentPage);
                  end;
                  end;
               end;
            end;
      finally
         ReadUnlockTable;
      end;
      end;
end;

procedure TDataCursor.NavigateNonIndexedRecords(Bitmap: TRecordsBitmap;
                                                NextToken: TExpToken;
                                                UpperFilterOperator: TExpOperator;
                                                ClientFilterData: Integer;
                                                CallbackFilterFunction: pFilterFunction);
var
   TempRecord: TRecord;
   NextRecordNum: Integer;
   SaveIndexPos: Byte;
   { Version 5 }
   TempReadLockInterval: Integer;
   TempRecordsReadLocked: Integer;
   { Version 5 }
begin
   SaveIndexPos:=FIndexPos;
   InternalSetIndexPos(PHYSICAL_INDEX_POS);
   try
      { Optimize for the AND condition to only look at records with the
        bit already turned on }
      { Version 5 }
      if (UpperFilterOperator=eoAND) then
         begin
         TempRecordsReadLocked:=0;
         TempReadLockInterval:=MaximumInteger(1,(Bitmap.GetTotalBitsSet div DataEngine.MaxReadLockCount));
         NextRecordNum:=0;
         while Bitmap.GetNextBitsSet(NextRecordNum,1) do
            begin
            if (not GetRecord(NextRecordNum,True,READ_FORWARD,
                              TempRecord)) then
               GetRecord(NextRecordNum,True,READ_FORWARD,TempRecord);
            try
               if (TempRecord.Status <> RECORD_DELETED) then
                  begin
                  try
                     EvaluateFilterForRecord(TempRecord.Buffer,
                                             TempRecord.Number,
                                             Bitmap,NextToken,
                                             ClientFilterData,CallbackFilterFunction);
                  except
                     on E: Exception do
                        begin
                        if (DataEngine.ConvertExceptionToCode(E)=DBISAM_KEYORRECDELETED) then
                           Bitmap.ClearBit(TempRecord.Number)
                        else
                           raise;
                        end;
                  end;
                  end
               else
                  Bitmap.ClearBit(TempRecord.Number);
               Inc(TempRecordsReadLocked);
               if (TempRecordsReadLocked=TempReadLockInterval) then
                  begin
                  ReadUnlockTable;
                  TempRecordsReadLocked:=0;
                  end;
            finally
               PutRecord(TempRecord);
            end;
            end;
         end
      else
         begin
         TempRecordsReadLocked:=0;
         TempReadLockInterval:=MaximumInteger(1,(Bitmap.NumOfBits div DataEngine.MaxReadLockCount));
         Bitmap.SetBits;
         for NextRecordNum:=1 to Bitmap.NumOfBits do
            begin
            if (not GetRecord(NextRecordNum,True,READ_FORWARD,
                              TempRecord)) then
               GetRecord(NextRecordNum,True,READ_FORWARD,TempRecord);
            try
               if (TempRecord.Status <> RECORD_DELETED) then
                  begin
                  try
                     EvaluateFilterForRecord(TempRecord.Buffer,
                                             TempRecord.Number,
                                             Bitmap,NextToken,
                                             ClientFilterData,CallbackFilterFunction);
                  except
                     on E: Exception do
                        begin
                        if (DataEngine.ConvertExceptionToCode(E)=DBISAM_KEYORRECDELETED) then
                           Bitmap.ClearBit(TempRecord.Number)
                        else
                           raise;
                        end;
                  end;
                  end
               else
                  Bitmap.ClearBit(TempRecord.Number);
               Inc(TempRecordsReadLocked);
               if (TempRecordsReadLocked=TempReadLockInterval) then
                  begin
                  ReadUnlockTable;
                  TempRecordsReadLocked:=0;
                  end;
            finally
               PutRecord(TempRecord);
            end;
            end;
         end;
      { Version 5 }
   finally
      InternalSetIndexPos(SaveIndexPos);
      CheckForActiveFilters;
      ReadUnlockTable;
   end;
end;

procedure TDataCursor.NavigateNonDeletedRecords(Bitmap: TRecordsBitmap);
var
   TempRecord: TRecord;
   NextRecordNum: Integer;
   SaveIndexPos: Byte;
   { Version 5 }
   TempReadLockInterval: Integer;
   TempRecordsReadLocked: Integer;
   { Version 5 }
begin
   SaveIndexPos:=FIndexPos;
   InternalSetIndexPos(PHYSICAL_INDEX_POS);
   try
      TempRecordsReadLocked:=0;
      TempReadLockInterval:=MaximumInteger(1,(Bitmap.GetTotalBitsSet div DataEngine.MaxReadLockCount));
      NextRecordNum:=0;
      { Version 5 }
      while Bitmap.GetNextBitsSet(NextRecordNum,1) do
         begin
         if (not GetRecord(NextRecordNum,True,READ_FORWARD,
                           TempRecord)) then
            GetRecord(NextRecordNum,True,READ_FORWARD,TempRecord);
         try
            if (TempRecord.Status=RECORD_DELETED) then
               Bitmap.ClearBit(TempRecord.Number);
            Inc(TempRecordsReadLocked);
            if (TempRecordsReadLocked=TempReadLockInterval) then
               begin
               ReadUnlockTable;
               TempRecordsReadLocked:=0;
               end;
         finally
            PutRecord(TempRecord);
         end;
         end;
      { Version 5 }
   finally
      InternalSetIndexPos(SaveIndexPos);
      CheckForActiveFilters;
      ReadUnlockTable;
   end;
end;

{ Version 5 }
function TDataCursor.EvaluateFilterForRecord(RecordBuffer: PChar;
                                             RecordNum: Integer;
                                             Bitmap: TRecordsBitmap;
                                             NextToken: TExpToken;
                                             ClientFilterData: Integer;
                                             CallbackFilterFunction: pFilterFunction): Boolean;
begin
   Result:=True;
   if (not Assigned(CallbackFilterFunction)) then
      begin
      EvaluateExpressionToken(NextToken,RecordBuffer,Integer(Self),
                              @TDataCursor.EvaluateFilterFieldData,LocaleID);
      if (not VerifyWordBool(pWordBool(NextToken.Value)^)) then
         begin
         Result:=False;
         Bitmap.ClearBit(RecordNum);
         end
      else
         Result:=True;
      end
   else
      begin
      if (not Boolean(CallbackFilterFunction(ClientFilterData,FRecordSize,
                                             RecordBuffer,RecordNum))) then
         begin
         Result:=False;
         Bitmap.ClearBit(RecordNum);
         end;
      end;
end;
{ Version 5 }

function TDataCursor.EvaluateFilterFieldData(RecordBuffer: PChar;
                                             FieldToken: TExpToken): Boolean;
var
   IsBlank: Boolean;
   BlobHandle: Integer;
   BlobSizeToLoad: Integer;
   BlobSizeLoaded: Integer;
   { Version 5 }
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   { Version 5 }
begin
   Result:=True;
   with FieldToken do
      begin
      if (DataSource=nil) then
         DataSource:=Self;
      IsBlank:=True;
      if (DataType=TYPE_BLOB) then
         begin
         BlobHandle:=0;
         GetPhysicalField(FieldNumber,RecordBuffer,@BlobHandle,IsBlank);
         if not IsBlank then
            begin
            OpenBlob(FieldNumber,RecordBuffer,BLOB_OPENREADONLY,True,True,
                     BlobSizeToLoad,False);
            try
               if (SubType=SUBTYPE_MEMO) then
                  DataSize:=(BlobSizeToLoad+1)
               else
                  DataSize:=BlobSizeToLoad;
               GetBlob(FieldNumber,RecordBuffer,0,Value,BlobSizeToLoad,
                       BlobSizeLoaded,True);
               if (SubType=SUBTYPE_MEMO) then
                  (Value+BlobSizeToLoad)^:=#0;
            finally
               FreeBlob(FieldNumber,RecordBuffer,True,True);
            end;
            end
         else
            begin
            if ((DataType=TYPE_BLOB) and (SubType=SUBTYPE_MEMO)) then
               begin
               DataSize:=1;
               Value^:=#0;
               end
            else
               DataSize:=0;
            end;
         end
      else
         { Version 5 }
         begin
         if (DataType=TYPE_ZSTRING) then
            begin
            GetPhysicalField(FieldNumber,RecordBuffer,@TempFieldBuffer,IsBlank);
            DataSize:=StrLen(@TempFieldBuffer)+1;
            Move(TempFieldBuffer,Value^,DataSize);
            end
         else
            GetPhysicalField(FieldNumber,RecordBuffer,Value,IsBlank);
         end;
        { Version 5 }
      IsNull:=IsBlank;
      end;
end;

function TDataCursor.ChangeToIndexForFields(FieldNum: Word;
                                            IsCaseInsensitive: Boolean;
                                            AnyIndex: Boolean): Boolean;
var
   I: Byte;
begin
   Result:=False;
   for I:=0 to IndexCount do
      begin
      if AnyIndex or ((GetIndexDefinition(I)^.KeyCaseInsensitive=IsCaseInsensitive) or
                      (GetPhysicalFieldDefinition(GetIndexDefinition(I)^.KeyFields[1])^.DataType <> TYPE_ZSTRING)) then
         begin
         if (GetIndexDefinition(I)^.KeyFields[1]=FieldNum) then
            begin
            InternalSetIndexPos(I);
            Result:=True;
            Exit;
            end;
         end;
      end;
end;

function TDataCursor.GetOptimizationCount(Operator: TExpOperator;
                                          FieldToken: TExpToken;
                                          ConstantToken: TExpToken;
                                          PartialLength: Word): Integer;
var
   FirstKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   SecondKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   ThirdKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   FourthKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempFieldDefinition: pFieldDefinition;
   TempOperator: TExpOperator;
begin
   Result:=0;
   FillChar(FirstKeyBuffer,MAX_KEYLEN,#0);
   FillChar(SecondKeyBuffer,MAX_KEYLEN,#0);
   FillChar(ThirdKeyBuffer,MAX_KEYLEN,#0);
   FillChar(FourthKeyBuffer,MAX_KEYLEN,#0);
   TempFieldDefinition:=GetPhysicalFieldDefinition(FieldToken.FieldNumber);
   TempOperator:=Operator;
   if (ConstantToken <> nil) and (not ConstantToken.IsNull) then
      begin
      FirstKeyBuffer[0]:=#1;
      PrepareDataForIndex(TempFieldDefinition,ConstantToken.Value,
                          @FirstKeyBuffer,FKeyCaseInsensitive,
                          FLocaleID);
      end
   else
      begin
      { Handle special case of a < or > NULL expression }
      if ((TempFieldDefinition^.DataType <> TYPE_ZSTRING) and
          (Operator in [eoLT,eoGT])) or
         ((TempFieldDefinition^.DataType=TYPE_ZSTRING) and
          (Operator=eoLT)) then
         Exit;
      end;
   if (TempOperator=eoNE) and (FirstKeyBuffer[0] <> #0) then
      begin
      { Version 5 }
      { Only use the optimized ranges if the partial length is not set }
      if (PartialLength=0) then
      { Version 5 }
         begin
         Move(FirstKeyBuffer,ThirdKeyBuffer,MAX_KEYLEN);
         BuildRangeFromConstant(eoLT,TempFieldDefinition^.DataType,
                                GetIndexedSize(TempFieldDefinition),
                                PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                                (FirstKeyBuffer[0]=#0),True);
         BuildRangeFromConstant(eoGT,TempFieldDefinition^.DataType,
                                GetIndexedSize(TempFieldDefinition),
                                PartialLength,@ThirdKeyBuffer,@FourthKeyBuffer,
                                (ThirdKeyBuffer[0]=#0),True);
         { Version 5 }
         Result:=CountIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer);
         { Version 5 }
         end
      else
         begin
         BuildRangeFromConstant(TempOperator,TempFieldDefinition^.DataType,
                                GetIndexedSize(TempFieldDefinition),
                                PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                                (FirstKeyBuffer[0]=#0),False);
         { Version 5}
         Result:=CountIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer);
         Result:=(PhysicalRecordsUsed-Result);
         { Version 5 }
         end;
      end
   else
      begin
      BuildRangeFromConstant(TempOperator,TempFieldDefinition^.DataType,
                             GetIndexedSize(TempFieldDefinition),
                             PartialLength,@FirstKeyBuffer,@SecondKeyBuffer,
                             (FirstKeyBuffer[0]=#0),False);
      { Version 5 }
      Result:=CountIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer);
      { Version 5 }
      end;
end;

function TDataCursor.GetTextSearchOptimizationCount(FieldNum: Word;
                                                    const FieldName: string;
                                                    WordBuffer: PChar;
                                                    WordBufferSize: Integer): Integer;
var
   TempWordsList: TLocaleStringList;
   StopWordPos: Integer;
   I: Integer;
   FirstKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   SecondKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempPartialLength: Word;
   TempResult: Integer;
begin
   Result:=0;
   TempWordsList:=TLocaleStringList.Create;
   try
      with TempWordsList do
         begin
         SetLocaleID(FLocaleID);
         Duplicates:=dupIgnore;
         Sorted:=True;
         end;
      CreateWordsList(FTableName,FieldName,
                      WordBuffer,WordBufferSize,TempWordsList,True);
      { Version 5 }
      for I:=0 to TempWordsList.Count-1 do
         begin
         if (not FTextStopWords.Find(TempWordsList[I],StopWordPos)) then
            begin
            FillChar(FirstKeyBuffer,SizeOf(FirstKeyBuffer),#0);
            FillChar(SecondKeyBuffer,SizeOf(SecondKeyBuffer),#0);
            Boolean(FirstKeyBuffer[0]):=True;
            FlipWordBits(FieldNum,@FirstKeyBuffer[FLDCHG_DATA]);
            Move(TempWordsList[I][1],FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                 Length(TempWordsList[I]));
            OSUpperString(FLocaleID,
                          @FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
            if (StrLen(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]) > 0) then
               begin
               if ((StrEnd(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1)^=PARSE_ASTERISK) then
                  begin
                  TempPartialLength:=StrLen(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1;
                  (StrEnd(@FirstKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE])-1)^:=#0;
                  end
               else
                  TempPartialLength:=0;
               end
            else
               TempPartialLength:=0;
            BuildRangeFromConstant(eoEQ,TYPE_ZSTRING,
                                   TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE,
                                   TempPartialLength,
                                   @FirstKeyBuffer,
                                   @SecondKeyBuffer,False,False);
            TempResult:=CountIndexedRecords(@FirstKeyBuffer,@SecondKeyBuffer);
            Result:=MinimumInteger(Result,TempResult);
            end;
         end;
      { Version 5 }
   finally
      TempWordsList.Free;
   end;
end;

procedure TDataCursor.BuildRangeFromConstant(Operator: TExpOperator;
                                             DataType: Byte;
                                             DataSize: Word;
                                             PartialLength: Word;
                                             FirstBuffer: PChar;
                                             SecondBuffer: PChar;
                                             IsNull: Boolean;
                                             IncludeNulls: Boolean);
var
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempSize: Word;
   LastByte: Word;
begin
   { Determine size to use for constant }
   if (PartialLength=0) then
      TempSize:=DataSize
   else
      { Be sure to add in the NULL terminator byte }
      TempSize:=(PartialLength+1);
   { Handle NULLs with <= or >= }
   if (DataType <> TYPE_ZSTRING) and IsNull and (Operator in [eoLE,eoGE]) then
      Operator:=eoEQ;
   if (not (Operator in [eoBETWEEN,eoNOTBETWEEN])) then
      begin
      if (Operator in [eoGT,eoGE,eoLT,eoLE]) then
         begin
         if FKeyDescendingFields[1] then
            begin
            case Operator of
               eoGT: Operator:=eoLT;
               eoGE: Operator:=eoLE;
               eoLT: Operator:=eoGT;
               eoLE: Operator:=eoGE;
               end;
            end;
         if (Operator=eoGT) then
            begin
            { Be sure to set the NULL flag, if necessary }
            if IsNull and (not FKeyDescendingFields[1]) then
               FirstBuffer^:=#1;
            Move(FirstBuffer^,TempKeyBuffer,MAX_KEYLEN);
            if (not IsNull) then
               IncKeyBuffer(FirstBuffer,@TempKeyBuffer,DataType,TempSize);
            end
         else if (Operator=eoLT) then
            begin
            { Be sure to set the NULL flag, if necessary }
            if IsNull and FKeyDescendingFields[1] then
               FirstBuffer^:=#1;
            Move(FirstBuffer^,TempKeyBuffer,MAX_KEYLEN);
            if (not IsNull) then
               DecKeyBuffer(FirstBuffer,@TempKeyBuffer,DataType,TempSize);
            end;
         { Fill the second field buffer with high bytes if we're not
           dealing with a less than type of operator }
         if not (Operator in [eoLT,eoLE]) then
            FillAllHighBytes(SecondBuffer)
         else
            begin
            Move(FirstBuffer^,SecondBuffer^,MAX_KEYLEN);
            FillAllLowBytes(FirstBuffer);
            end;
         { If we're not dealing with a string and the comparison was
           not a direct comparison against a NULL, then NULLs must
           be weeded out }
         if (not IncludeNulls) then
            begin
            if (DataType <> TYPE_ZSTRING) and
               ((Operator in [eoLT,eoGT]) or
                (Operator in [eoLE,eoGE]) and (not IsNull)) then
               begin
               FirstBuffer^:=#1;
               SecondBuffer^:=#1;
               end;
            end;
         end
      else if (Operator in [eoEQ,eoNE]) then
         begin
         Move(FirstBuffer^,SecondBuffer^,MAX_KEYLEN);
         { If we're dealing with a <> NULL, then weed out the NULLS }
         if (Operator=eoNE) and IsNull then
            begin
            FirstBuffer^:=#1;
            SecondBuffer^:=#1;
            end;
         end;
      end
   else
      begin
      if FKeyDescendingFields[1] then
         begin
         Move(FirstBuffer^,TempKeyBuffer,MAX_KEYLEN);
         Move(SecondBuffer^,FirstBuffer^,MAX_KEYLEN);
         Move(TempKeyBuffer,SecondBuffer^,MAX_KEYLEN);
         end;
      end;
   if (not IsNull) then
      begin
      if (PartialLength=0) then
         LastByte:=FLDCHG_DATA+DataSize
      else
         LastByte:=FLDCHG_DATA+PartialLength;
      end
   else
      LastByte:=FLDCHG_DATA;
   SetLowBytes(FirstBuffer,LastByte);
   SetHighBytes(SecondBuffer,LastByte);
end;

procedure TDataCursor.SetLowBytes(Buffer: PChar; EndByte: Word);
var
   I: Byte;
   BufferOffset: Word;
   TempSetOffset: Word;
   TempSetLength: Word;
begin
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if ((BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]))) >= EndByte) then
            begin
            if (EndByte < BufferOffset) then
               begin
               TempSetOffset:=0;
               TempSetLength:=(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
               end
            else
               begin
               TempSetOffset:=(EndByte-BufferOffset);
               TempSetLength:=((BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])))-EndByte);
               end;
            if FKeyDescendingFields[I] then
               begin
               if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                           FCharMap[High(Byte)])
               else
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,#255);
               end
            else
               begin
               if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                           FCharMap[Low(Byte)])
               else
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,#0);
               end;
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#0);
      end
   else
      begin
      Inc(EndByte,TEXT_FLDNUM_SIZE);
      BufferOffset:=(FLDCHG_DATA+TEXT_FLDNUM_SIZE);
      if ((BufferOffset+TEXT_WORD_SIZE) >= EndByte) then
         begin
         if (EndByte < BufferOffset) then
            begin
            TempSetOffset:=0;
            TempSetLength:=TEXT_WORD_SIZE;
            end
         else
            begin
            TempSetOffset:=(EndByte-BufferOffset);
            TempSetLength:=((BufferOffset+TEXT_WORD_SIZE)-EndByte);
            end;
         FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                   FCharMap[Low(Byte)])
         end;
      Inc(BufferOffset,TEXT_WORD_SIZE);
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#0);
      end;
end;

procedure TDataCursor.SetHighBytes(Buffer: PChar; EndByte: Word);
var
   I: Byte;
   BufferOffset: Word;
   TempSetOffset: Word;
   TempSetLength: Word;
begin
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if ((BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]))) >= EndByte) then
            begin
            if (EndByte < BufferOffset) then
               begin
               TempSetOffset:=0;
               TempSetLength:=(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I]));
               end
            else
               begin
               TempSetOffset:=(EndByte-BufferOffset);
               TempSetLength:=((BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])))-EndByte);
               end;
            if FKeyDescendingFields[I] then
               begin
               if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                           FCharMap[Low(Byte)])
               else
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,#0);
               end
            else
               begin
               if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                           FCharMap[High(Byte)])
               else
                  FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,#255);
               end;
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#255);
      end
   else
      begin
      Inc(EndByte,TEXT_FLDNUM_SIZE);
      BufferOffset:=(FLDCHG_DATA+TEXT_FLDNUM_SIZE);
      if ((BufferOffset+TEXT_WORD_SIZE) >= EndByte) then
         begin
         if (EndByte < BufferOffset) then
            begin
            TempSetOffset:=0;
            TempSetLength:=TEXT_WORD_SIZE;
            end
         else
            begin
            TempSetOffset:=(EndByte-BufferOffset);
            TempSetLength:=((BufferOffset+TEXT_WORD_SIZE)-EndByte);
            end;
         FillChar((Buffer+BufferOffset+TempSetOffset)^,TempSetLength,
                   FCharMap[High(Byte)])
         end;
      Inc(BufferOffset,TEXT_WORD_SIZE);
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#255);
      end;
end;

procedure TDataCursor.FillAllLowBytes(Buffer: PChar);
var
   I: Byte;
   BufferOffset: Word;
begin
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if FKeyDescendingFields[I] then
            begin
            (Buffer+BufferOffset)^:=#1;
            if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),
                        FCharMap[High(Byte)])
            else
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),#255);
            end
         else
            begin
            (Buffer+BufferOffset)^:=#0;
            if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),
                        FCharMap[Low(Byte)])
            else
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),#0);
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#0);
      end
   else
      begin
      FillChar(Buffer^,(FLDCHG_DATA+TEXT_FLDNUM_SIZE),#0);
      FillChar((Buffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE))^,
               TEXT_WORD_SIZE,FCharMap[Low(Byte)]);
      FillChar((Buffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE))^,
               RECORDID_SIZE,#0);
      end;
end;

procedure TDataCursor.FillAllHighBytes(Buffer: PChar);
var
   I: Byte;
   BufferOffset: Word;
begin
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if FKeyDescendingFields[I] then
            begin
            (Buffer+BufferOffset)^:=#0;
            if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),
                        FCharMap[Low(Byte)])
            else
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),#0);
            end
         else
            begin
            (Buffer+BufferOffset)^:=#1;
            if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),
                        FCharMap[High(Byte)])
            else
               FillChar((Buffer+BufferOffset+FLDCHG_DATA)^,
                        GetIndexedSize(FKeyFieldDefinitions[I]),#255);
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      if (BufferOffset < FKeySize) then
         FillChar((Buffer+BufferOffset)^,(FKeySize-BufferOffset),#255);
      end
   else
      begin
      FillChar(Buffer^,(FLDCHG_DATA+TEXT_FLDNUM_SIZE),#255);
      FillChar((Buffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE))^,
               TEXT_WORD_SIZE,FCharMap[High(Byte)]);
      FillChar((Buffer+(FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE))^,
               RECORDID_SIZE,#255);
      end;
end;

procedure TDataCursor.IncKeyBuffer(KeyBuffer: PChar; OriginalBuffer: PChar;
                                   DataType: Byte; DataSize: Word);
var
   TempLastByte: Word;
   TempTotalSize: Word;
begin
   if (FLocaleID <> LOCALE_ANSI_STD) and (DataType=TYPE_ZSTRING) then
      begin
      TempTotalSize:=(FLDCHG_DATA+DataSize-1);
      TempLastByte:=(TempTotalSize-1);
      while (not (CompareKeys(KeyBuffer,OriginalBuffer,FKeySize)=CMP_GREATER)) do
         IncLastByte(KeyBuffer,TempLastByte,TempTotalSize);
      end
   else
      begin
      if (DataType <> TYPE_ZSTRING) then
         TempTotalSize:=(FLDCHG_DATA+DataSize)
      else
         TempTotalSize:=(FLDCHG_DATA+DataSize-1);
      TempLastByte:=(TempTotalSize-1);
      IncLastByte(KeyBuffer,TempLastByte,TempTotalSize)
      end;
end;

procedure TDataCursor.DecKeyBuffer(KeyBuffer: PChar; OriginalBuffer: PChar;
                                   DataType: Byte; DataSize: Word);
var
   TempLastByte: Word;
   TempTotalSize: Word;
begin
   if (FLocaleID <> LOCALE_ANSI_STD) and (DataType=TYPE_ZSTRING) then
      begin
      TempTotalSize:=(FLDCHG_DATA+DataSize-1);
      TempLastByte:=(TempTotalSize-1);
      while (not (CompareKeys(KeyBuffer,OriginalBuffer,FKeySize)=CMP_LESS)) do
         DecLastByte(KeyBuffer,TempLastByte,TempTotalSize);
      end
   else
      begin
      if (DataType <> TYPE_ZSTRING) then
         TempTotalSize:=(FLDCHG_DATA+DataSize)
      else
         TempTotalSize:=(FLDCHG_DATA+DataSize-1);
      TempLastByte:=(TempTotalSize-1);
      DecLastByte(KeyBuffer,TempLastByte,TempTotalSize);
      end;
end;

procedure TDataCursor.IncLastByte(Buffer: PChar; var LastByte: Word;
                                  TotalSize: Word);
begin
   while (LastByte > 0) do
      begin
      if GetIndexFieldDescending(LastByte) then
         begin
         if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
            begin
            if EqualToFirstChar(Buffer[LastByte]) then
               Buffer[LastByte]:=FCharMap[High(Byte)]
            else
               Break;
            end
         else
            begin
            if (Buffer[LastByte]=#0) then
               Buffer[LastByte]:=#255
            else
               Break;
            end;
         end
      else
         begin
         if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
            begin
            if EqualToLastChar(Buffer[LastByte]) then
               Buffer[LastByte]:=FCharMap[Low(Byte)]
            else
               Break;
            end
         else
            begin
            if (Buffer[LastByte]=#255) then
               Buffer[LastByte]:=#0
            else
               Break;
            end;
         end;
      Dec(LastByte);
      end;
   if GetIndexFieldDescending(LastByte) then
      begin
      if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
         begin
         if EqualToFirstChar(Buffer[LastByte]) then
            SetLowBytes(Buffer,TotalSize)
         else
            Buffer[LastByte]:=GetPriorChar(Buffer[LastByte]);
         end
      else
         begin
         if (Buffer[LastByte]=#0) then
            FillChar(Buffer^,TotalSize,#0)
         else
            Dec(Byte(Buffer[LastByte]));
         end;
      end
   else
      begin
      if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
         begin
         if EqualToLastChar(Buffer[LastByte]) then
            SetHighBytes(Buffer,TotalSize)
         else
            Buffer[LastByte]:=GetNextChar(Buffer[LastByte]);
         end
      else
         begin
         if (Buffer[LastByte]=#255) then
            FillChar(Buffer^,TotalSize,#255)
         else
            Inc(Byte(Buffer[LastByte]));
         end;
      end;
end;

procedure TDataCursor.DecLastByte(Buffer: PChar; var LastByte: Word;
                                  TotalSize: Word);
begin
   while (LastByte > 0) do
      begin
      if GetIndexFieldDescending(LastByte) then
         begin
         if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
            begin
            if EqualToLastChar(Buffer[LastByte]) then
               Buffer[LastByte]:=FCharMap[Low(Byte)]
            else
               Break;
            end
         else
            begin
            if (Buffer[LastByte]=#255) then
               Buffer[LastByte]:=#0
            else
               Break;
            end;
         end
      else
         begin
         if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
            begin
            if EqualToFirstChar(Buffer[LastByte]) then
               Buffer[LastByte]:=FCharMap[High(Byte)]
            else
               Break;
            end
         else
            begin
            if (Buffer[LastByte]=#0) then
               Buffer[LastByte]:=#255
            else
               Break;
            end;
         end;
      Dec(LastByte);
      end;
   if GetIndexFieldDescending(LastByte) then
      begin
      if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
         begin
         if EqualToLastChar(Buffer[LastByte]) then
            SetHighBytes(Buffer,TotalSize)
         else
            Buffer[LastByte]:=GetNextChar(Buffer[LastByte]);
         end
      else
         begin
         if (Buffer[LastByte]=#255) then
            FillChar(Buffer^,TotalSize,#255)
         else
            Inc(Byte(Buffer[LastByte]));
         end;
      end
   else
      begin
      if (GetIndexFieldDataType(LastByte)=TYPE_ZSTRING) then
         begin
         if EqualToFirstChar(Buffer[LastByte]) then
            SetLowBytes(Buffer,TotalSize)
         else
            Buffer[LastByte]:=GetPriorChar(Buffer[LastByte]);
         end
      else
         begin
         if (Buffer[LastByte]=#0) then
            FillChar(Buffer^,TotalSize,#0)
         else
            Dec(Byte(Buffer[LastByte]));
         end;
      end;
end;

function TDataCursor.GetIndexFieldDataType(SearchOffset: Word): Byte;
var
   BufferOffset: Word;
   I: Byte;
begin
   Result:=TYPE_UNKNOWN;
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if (SearchOffset >= BufferOffset) and
            (SearchOffset < (BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])))) then
            begin
            Result:=FKeyFieldDefinitions[I]^.DataType;
            Break;
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      end
   else
      begin
      if (SearchOffset <= (FLDCHG_DATA+TEXT_FLDNUM_SIZE)) then
         Result:=TYPE_UINT16
      else if (SearchOffset >= (FLDCHG_DATA+TEXT_FLDNUM_SIZE)) and
              (SearchOffset < (FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE)) then
         Result:=TYPE_ZSTRING
       else if (SearchOffset >= (FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE)) and
              (SearchOffset < (FLDCHG_DATA+TEXT_FLDNUM_SIZE+TEXT_WORD_SIZE+
                               RECORDID_SIZE)) then
         Result:=TYPE_INT32;
      end;
end;

function TDataCursor.GetIndexFieldDescending(SearchOffset: Word): Boolean;
var
   BufferOffset: Word;
   I: Byte;
begin
   Result:=False;
   if (FIndexPos <> TEXT_INDEX_POS) then
      begin
      BufferOffset:=0;
      I:=1;
      while (I <= FKeyFieldCount) and
            (BufferOffset < FKeySize) do
         begin
         if (SearchOffset >= BufferOffset) and
            (SearchOffset < (BufferOffset+(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])))) then
            begin
            Result:=FKeyDescendingFields[I];
            Break;
            end;
         Inc(BufferOffset,(FLDCHG_DATA+GetIndexedSize(FKeyFieldDefinitions[I])));
         Inc(I);
         end;
      end;
end;

function TDataCursor.EqualToFirstChar(SourceChar: Char): Boolean;
var
   FirstChar: Char;
begin
   FirstChar:=FCharMap[Low(Byte)];
   Result:=(CompareChar(FLocaleID,SourceChar,FirstChar)=CMP_EQUAL);
end;

function TDataCursor.EqualToLastChar(SourceChar: Char): Boolean;
var
   LastChar: Char;
begin
   LastChar:=FCharMap[High(Byte)];
   Result:=(CompareChar(FLocaleID,SourceChar,LastChar)=CMP_EQUAL);
end;

function TDataCursor.GetPriorChar(SourceChar: Char): Char;
var
   CharPos: Byte;
begin
   CharPos:=(GetCharMapPos(SourceChar)-1);
   Result:=FCharMap[CharPos];
   while (CompareChar(FLocaleID,SourceChar,Result)=CMP_EQUAL) and
         (CharPos <> Low(Byte)) do
      begin
      Dec(CharPos);
      Result:=FCharMap[CharPos];
      end;
end;

function TDataCursor.GetNextChar(SourceChar: Char): Char;
var
   CharPos: Byte;
begin
   CharPos:=(GetCharMapPos(SourceChar)+1);
   Result:=FCharMap[CharPos];
   while (CompareChar(FLocaleID,SourceChar,Result)=CMP_EQUAL) and
         (CharPos <> High(Byte)) do
      begin
      Inc(CharPos);
      Result:=FCharMap[CharPos]
      end;
end;

function TDataCursor.GetCharMapPos(SourceChar: Char): Byte;
var
   I: Byte;
begin
   Result:=0;
   for I:=0 to High(Byte) do
      begin
      if (FCharMap[I]=SourceChar) then
         begin
         Result:=I;
         Break;
         end;
      end;
end;

function TDataCursor.GetPhysicalRecordsUsed: Integer;
begin
   Result:=FDataTable.PhysicalRecordsUsed;
end;

function TDataCursor.GetPhysicalPagesUsed: Integer;
begin
   Result:=FDataTable.PhysicalPagesUsed;
end;

function TDataCursor.GetPhysicalBlocksUsed: Integer;
begin
   Result:=FDataTable.PhysicalBlocksUsed;
end;

function TDataCursor.GetDescription: string;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.Description
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.Description;
      end;
end;

function TDataCursor.GetLastUpdated: TDateTime;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.LastUpdated
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=(TempHeader.LastUpdated+DateDelta)
      end;
end;

function TDataCursor.GetEncrypted: Boolean;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   if FIsOpen then
      Result:=FDataTable.Encrypted
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempHeader.Encrypted;
      end;
end;

function TDataCursor.GetPassword: string;
var
   TempHeader: TDataHeader;
   TempPassword: string;
begin
   Result:='';
   if FIsOpen then
      Result:=FDataTable.Password
   else
      begin
      GetDataHeader(TempHeader,TempPassword);
      Result:=TempPassword;
      end;
end;

procedure TDataCursor.SetSteppedProgressCallback(ClientData: Integer;
                                                 SteppedProgressCallback: pSteppedProgressCallback);
begin
   FSteppedProgressClientData:=ClientData;
   FSteppedProgressCallback:=pSteppedProgressCallback(@SteppedProgressCallback);
end;

procedure TDataCursor.SetLogCallback(ClientData: Integer;
                                     LogCallback: pLogCallback);
begin
   FLogClientData:=ClientData;
   FLogCallback:=pLogCallback(@LogCallback);
end;

procedure TDataCursor.SetProgressCallback(ClientData: Integer;
                                          ProgressCallback: pProgressCallback);
begin
   FProgressClientData:=ClientData;
   FProgressCallback:=pProgressCallback(@ProgressCallback);
end;

procedure TDataCursor.SetDataLostCallback(ClientData: Integer;
                                          DataLostCallback: pDataLostCallback);
begin
   FDataLostClientData:=ClientData;
   FDataLostCallback:=pDataLostCallback(@DataLostCallback);
end;

procedure TDataCursor.OpenBlob(FieldNum: Word; RecordBuffer: PChar;
                               Mode: Byte; UsePhysicalFields: Boolean;
                               SystemBlob: Boolean; var NewSize: Integer;
                               NoRemoteCall: Boolean);
var
   BlobBlock: Integer;
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   RemoteBlobHandle: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
   { Version 5 }
   RetryBlob: Boolean;
   TempRecord: TRecord;
   { Version 5 }
begin
   NewSize:=0;
   if (not IsRemote) then
      CheckForChangeDetection;
   try
      BlobBlock:=0;
      BlobHandle:=0;
      if UsePhysicalFields then
         GetPhysicalField(FieldNum,RecordBuffer,@BlobBlock,IsBlank)
      else
         GetField(FieldNum,RecordBuffer,@BlobBlock,IsBlank);
      if (BlobBlock < 0) then
         BlobHandle:=FlipIntegerSign(BlobBlock);
      if ValidBlobBufferHandle(BlobHandle,BlobBufferPos) then
         begin
         with TBlobBuffer(BlobHandle) do
            begin
            { If the blob was opened by the engine, but then
              was opened again by the client application, then
              don't increment the use count, just hand it over
              to the control of the client application }
            if (Mode=BLOB_OPENREADWRITE) and
               (EngineAllocated and (not SystemBlob)) then
               EngineAllocated:=SystemBlob
            else
               IncUseCount;
            NewSize:=Size;
            end;
         Exit;
         end
      else
         begin
         if ((not IsRemote) or (IsRemote and (not NoRemoteCall))) and
             (BlobBlock < 0) then
            DataEngine.RaiseError(DBISAM_INVALIDBLOBOFFSET,'','',ProperDataDirectoryName,
                                  FTableName);
         if (FBlobBuffers.Count=MAX_OPEN_BLOBS) then
            DataEngine.RaiseError(DBISAM_OPENBLOBLIMIT,'','',ProperDataDirectoryName,
                                  FTableName);
         if IsRemote and (not NoRemoteCall) then
            StartRemoteRequest;
         try
            if IsRemote and (not NoRemoteCall) then
               begin
               CheckForConnection;
               SetRequestCode(REQUEST_OPENBLOB);
               BeginPack;
               Pack(FRemoteID,SizeOf(Integer));
               Pack(FieldNum,SizeOf(Word));
               Pack(RecordBuffer^,FRecordSize);
               Pack(Mode,SizeOf(Byte));
               Pack(UsePhysicalFields,SizeOf(Boolean));
               Pack(SystemBlob,SizeOf(Boolean));
               EndPack;
               SendReceive;
               CheckForException;
               Unpack(RecordBuffer^);
               end;
            BlobBuffer:=TBlobBuffer.Create(Self);
            try
               with TBlobBuffer(BlobBuffer) do
                  begin
                  if UsePhysicalFields then
                     FieldDefinition:=GetPhysicalFieldDefinition(FieldNum)
                  else
                     FieldDefinition:=GetFieldDefinition(FieldNum);
                  BlockNumber:=BlobBlock;
                  { Version 5 }
                  RecordNumber:=GetRecordNo(RecordBuffer);
                  { Version 5 }
                  OpenMode:=Mode;
                  EngineAllocated:=SystemBlob;
                  Signature:=GetBlobSignature(FieldNum,RecordBuffer,UsePhysicalFields);
                  BlobHandle:=Integer(BlobBuffer);
                  if IsRemote then
                     begin
                     RemoteBlobHandle:=0;
                     if UsePhysicalFields then
                        GetPhysicalField(FieldNum,RecordBuffer,@RemoteBlobHandle,IsBlank)
                     else
                        GetField(FieldNum,RecordBuffer,@RemoteBlobHandle,IsBlank);
                     RemoteBlobHandle:=FlipIntegerSign(RemoteBlobHandle);
                     RemoteID:=RemoteBlobHandle;
                     end;
                  RetryBlob:=False;
                  { Version 5 }
                  ReadBlob(BlobBuffer,RetryBlob);
                  { If necessary, re-read the current record (only local access
                    will set the flag) }
                  if RetryBlob then
                     begin
                     GetRecord(RecordNumber,False,READ_CURRENT,TempRecord);
                     try
                        { If the record isn't deleted and hasn't been re-used,
                          then reset the BLOB block information and try again }
                        if (TempRecord.Status <> RECORD_DELETED) and
                           (TempRecord.ID=GetRecordID(RecordBuffer)) then
                           begin
                           if UsePhysicalFields then
                              begin
                              GetPhysicalField(FieldNum,TempRecord.Buffer,@BlobBlock,IsBlank);
                              PutPhysicalField(FieldNum,RecordBuffer,@BlobBlock,False)
                              end
                           else
                              begin
                              GetField(FieldNum,TempRecord.Buffer,@BlobBlock,IsBlank);
                              PutField(FieldNum,RecordBuffer,@BlobBlock,True,False);
                              end;
                           BlockNumber:=BlobBlock;
                           Signature:=GetBlobSignature(FieldNum,TempRecord.Buffer,UsePhysicalFields);
                           PutBlobSignature(FieldNum,RecordBuffer,Signature,UsePhysicalFields);
                           RetryBlob:=False;
                           ReadBlob(BlobBuffer,RetryBlob);
                           { If retry is set again, then the BLOB is corrupted }
                           if RetryBlob then
                              DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',
                                                    ProperDataDirectoryName,
                                                    FTableName);
                           end
                        else
                           DataEngine.RaiseError(DBISAM_KEYORRECDELETED,'','',
                                                 ProperDataDirectoryName,FTableName)
                     finally
                        PutRecord(TempRecord);
                     end;
                     end;
                     { Version 5 }
                  IncUseCount;
                  NewSize:=Size;
                  end;
               FBlobBuffers.Add(BlobBuffer);
               if (not IsRemote) then
                  begin
                  if IsTextIndexed(FieldNum) then
                     BlobBuffer.SaveBuffer;
                  end;
               BlobHandle:=FlipIntegerSign(BlobHandle);
               if UsePhysicalFields then
                  PutPhysicalField(FieldNum,RecordBuffer,@BlobHandle,(BlobBuffer.Size=0))
               else
                  PutField(FieldNum,RecordBuffer,@BlobHandle,True,(BlobBuffer.Size=0));
            except
               BlobBuffer.Free;
               raise;
            end;
         finally
            if IsRemote and (not NoRemoteCall) then
               EndRemoteRequest;
         end;
      end;
   finally
      if (not IsRemote) then
         ReadUnlockTable;
   end;
end;

{ Version 5 }
procedure TDataCursor.ReadBlob(BlobBuffer: TBlobBuffer; var RetryBlob: Boolean);
var
   ActualBytes: Integer;
   BytesToRead: Word;
   BlockBytesRead: Word;
   CurrentBlock: TBlock;
   NextBlock: TBlock;
   TempSize: Integer;
begin
   RetryBlob:=False;
   if (BlobBuffer.BlockNumber=0) then
      begin
      BlobBuffer.Size:=0;
      Exit;
      end;
   if IsRemote then
      begin
      Unpack(TempSize);
      BlobBuffer.Size:=TempSize;
      if (BlobBuffer.Size <> 0) then
         Unpack(BlobBuffer.Buffer^)
      end
   else
      begin
      ActualBytes:=0;
      RetryBlob:=(not GetBlock(BlobBuffer.BlockNumber,False,1,CurrentBlock));
      if RetryBlob then
         Exit
      else
         begin
         try
            if (CurrentBlock.Signature <> BlobBuffer.Signature) then
               begin
               if InternalReadLockTable then
                  CurrentBlock:=nil;
               RetryBlob:=True;
               Exit;
               end
            else
               BlobBuffer.Size:=CurrentBlock.TotalLength;
            while (ActualBytes < BlobBuffer.Size) do
               begin
               if (CurrentBlock.Signature <> BlobBuffer.Signature) then
                  begin
                  if InternalReadLockTable then
                     CurrentBlock:=nil;
                  RetryBlob:=True;
                  Exit;
                  end;
               if (CurrentBlock.UseCount > 1) then
                  begin
                  PutBlock(CurrentBlock);
                  DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                          FTableName);
                  end;
               BytesToRead:=MinimumInteger(BlobBlockBufferSize,(BlobBuffer.Size-ActualBytes));
               BlockBytesRead:=CurrentBlock.GetBlockData(0,BytesToRead,
                                                        (BlobBuffer.Buffer+ActualBytes));
               if (BlockBytesRead=0) or (BlockBytesRead <> BytesToRead) then
                  Break;
               Inc(ActualBytes,BlockBytesRead);
               if (ActualBytes=BlobBuffer.Size) then
                  Break;
               if (CurrentBlock.NextNumber <> 0) then
                  begin
                  if (CurrentBlock.NextNumber > PhysicalBlocksUsed) or
                     (CurrentBlock.NextNumber < 0) then
                     DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                             FTableName);
                  RetryBlob:=(not GetBlock(CurrentBlock.NextNumber,True,
                                           GetBlockCount(BlobBuffer.Size-ActualBytes),
                                           NextBlock));
                  if RetryBlob then
                     begin
                     CurrentBlock:=nil;
                     Break;
                     end
                  else
                     begin
                     PutBlock(CurrentBlock);
                     CurrentBlock:=NextBlock;
                     end;
                  end
               else
                  Break;
               end;
            if (not RetryBlob) then
               begin
               BlobBuffer.IsDirty:=False;
               if (ActualBytes <> BlobBuffer.Size) then
                  DataEngine.RaiseError(DBISAM_ENDOFBLOB,'','',ProperDataDirectoryName,
                                          FTableName);
               end
            else
               Exit;
         finally
            PutBlock(CurrentBlock);
         end;
         end;
      BlobBuffer.Decompress;
      end;
end;
{ Version 5 }

procedure TDataCursor.WriteBlob(BlobBuffer: TBlobBuffer);
var
   ActualBytes: Integer;
   BytesToWrite: Word;
   BlockBytesWritten: Word;
   CurrentBlock: TBlock;
   NextBlock: TBlock;
   LastSize: Integer;
begin
   if IsRemote then
      begin
      Pack(BlobBuffer.RemoteID,SizeOf(Integer));
      Pack(BlobBuffer.EngineAllocated,SizeOf(Boolean));
      Pack(BlobBuffer.Size,SizeOf(Integer));
      Pack(BlobBuffer.Buffer^,BlobBuffer.Size);
      end
   else
      begin
      if (BlobBuffer.Size=0) then
         Exit;
      BlobBuffer.Compress;
      ActualBytes:=0;
      if (BlobBuffer.BlockNumber=0) then
         begin
         GetNextFreeBlock(CurrentBlock);
         BlobBuffer.BlockNumber:=CurrentBlock.Number;
         CurrentBlock.Signature:=BlobBuffer.Signature;
         LastSize:=0;
         end
      else
         begin
         GetBlock(BlobBuffer.BlockNumber,False,1,CurrentBlock);
         CurrentBlock.Signature:=BlobBuffer.Signature;
         LastSize:=CurrentBlock.TotalLength;
         end;
      try
         CurrentBlock.TotalLength:=BlobBuffer.Size;
         while (ActualBytes < BlobBuffer.Size) do
            begin
            BytesToWrite:=MinimumInteger(BlobBlockBufferSize,(BlobBuffer.Size-ActualBytes));
            BlockBytesWritten:=CurrentBlock.PutBlockData(0,BytesToWrite,
                                                        (BlobBuffer.Buffer+ActualBytes));
            if (BlockBytesWritten=0) or (BlockBytesWritten <> BytesToWrite) then
               Break;
            Inc(ActualBytes,BlockBytesWritten);
            if (ActualBytes=BlobBuffer.Size) then
               Break;
            if (CurrentBlock.NextNumber <> 0) then
               begin
               if (CurrentBlock.NextNumber > PhysicalBlocksUsed) or
                  (CurrentBlock.NextNumber < 0) then
                  DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                          FTableName);
               GetBlock(CurrentBlock.NextNumber,True,
                        GetBlockCount(LastSize-ActualBytes),NextBlock);
               end
            else
               GetNextFreeBlock(NextBlock);
            CurrentBlock.NextNumber:=NextBlock.Number;
            NextBlock.PrevNumber:=CurrentBlock.Number;
            NextBlock.Signature:=BlobBuffer.Signature;
            NextBlock.TotalLength:=0;
            PutBlock(CurrentBlock);
            CurrentBlock:=NextBlock;
            end;
         if (ActualBytes <> BlobBuffer.Size) then
            DataEngine.RaiseError(DBISAM_ENDOFBLOB,'','',ProperDataDirectoryName,
                                    FTableName);
         if (CurrentBlock.NextNumber <> 0) then
            begin
            if (CurrentBlock.NextNumber > PhysicalBlocksUsed) or
               (CurrentBlock.NextNumber < 0) then
                  DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                          FTableName);
            GetBlock(CurrentBlock.NextNumber,True,
                     GetBlockCount(LastSize-ActualBytes),NextBlock);
            FreeNextBlocks(BlobBuffer,NextBlock,
                           GetBlockCount(LastSize-ActualBytes));
            CurrentBlock.NextNumber:=0;
            end;
         BlobBuffer.IsDirty:=False;
      finally
         PutBlock(CurrentBlock);
      end;
      end;
end;

procedure TDataCursor.RemoveBlob(BlobBuffer: TBlobBuffer);
var
   CurrentBlock: TBlock;
begin
   if IsRemote then
      begin
      Pack(BlobBuffer.RemoteID,SizeOf(Integer));
      Pack(BlobBuffer.EngineAllocated,SizeOf(Boolean));
      Pack(BlobBuffer.Size,SizeOf(Integer));
      end
   else
      begin
      if (BlobBuffer.BlockNumber=0) then
         Exit;
      GetBlock(BlobBuffer.BlockNumber,False,1,CurrentBlock);
      CurrentBlock.Signature:=BlobBuffer.Signature;
      FreeNextBlocks(BlobBuffer,CurrentBlock,
                     GetBlockCount(CurrentBlock.TotalLength));
      BlobBuffer.BlockNumber:=0;
      end;
end;

procedure TDataCursor.FreeNextBlocks(BlobBuffer: TBlobBuffer;
                                     StartFromBlock: TBlock;
                                     NumBlocks: Integer);
var
   CurrentBlock: TBlock;
   NextBlock: TBlock;
begin
   CurrentBlock:=StartFromBlock;
   try
      if (NumBlocks > 1) then
         NumBlocks:=NumBlocks-1
      else
         NumBlocks:=1;
      while (CurrentBlock.NextNumber <> 0) do
         begin
         if (CurrentBlock.NextNumber > PhysicalBlocksUsed) or
            (CurrentBlock.NextNumber < 1) then
            DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                  FTableName);
         GetBlock(CurrentBlock.NextNumber,True,NumBlocks,NextBlock);
         try
            if (NextBlock.UseCount > 1) then
               begin
               PutBlock(NextBlock);
               DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                     FTableName);
               end;
            NextBlock.Signature:=BlobBuffer.Signature;
            SetNextFreeBlock(CurrentBlock);
            PutBlock(CurrentBlock);
         finally
            CurrentBlock:=NextBlock;
            Dec(NumBlocks);
         end;
         end;
      SetNextFreeBlock(CurrentBlock);
   finally
      PutBlock(CurrentBlock);
   end;
end;

procedure TDataCursor.VerifyBlobHandle(var BlobHandle: Integer;
                                       var BlobBufferPos: Integer);
begin
   if (BlobHandle >= 0) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBHANDLE,'','',ProperDataDirectoryName,
                            FTableName);
   BlobHandle:=FlipIntegerSign(BlobHandle);
   if (BlobHandle=0) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBHANDLE,'','',ProperDataDirectoryName,
                            FTableName);
   if (not ValidBlobBufferHandle(BlobHandle,BlobBufferPos)) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBHANDLE,'','',ProperDataDirectoryName,
                            FTableName);
end;


procedure TDataCursor.FreeBlob(FieldNum: Word; RecordBuffer: PChar;
                               UsePhysicalFields: Boolean;
                               SystemBlob: Boolean);
var
   BlobHandle: Integer;
   RemoteBlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   VerifyBlobHandle(BlobHandle,BlobBufferPos);
   BlobBuffer:=TBlobBuffer(BlobHandle);
   BlobBuffer.DecUseCount;
   if (BlobBuffer.UseCount=0) then
      begin
      if IsRemote then
         begin
         StartRemoteRequest;
         try
            RemoteBlobHandle:=BlobBuffer.RemoteID;
            RemoteBlobHandle:=FlipIntegerSign(RemoteBlobHandle);
            if UsePhysicalFields then
               PutPhysicalField(FieldNum,RecordBuffer,@RemoteBlobHandle,False)
            else
               PutField(FieldNum,RecordBuffer,@RemoteBlobHandle,True,False);
            CheckForConnection;
            SetRequestCode(REQUEST_FREEBLOB);
            BeginPack;
            Pack(FRemoteID,SizeOf(Integer));
            Pack(FieldNum,SizeOf(Word));
            Pack(RecordBuffer^,FRecordSize);
            Pack(UsePhysicalFields,SizeOf(Boolean));
            Pack(SystemBlob,SizeOf(Boolean));
            EndPack;
            SendReceive;
            CheckForException;
         finally
            EndRemoteRequest;
         end;
         end;
      BlobHandle:=BlobBuffer.BlockNumber;
      BlobBuffer.Free;
      FBlobBuffers.Delete(BlobBufferPos);
      end
   else
      BlobHandle:=FlipIntegerSign(BlobHandle);
   if UsePhysicalFields then
      PutPhysicalField(FieldNum,RecordBuffer,@BlobHandle,False)
   else
      PutField(FieldNum,RecordBuffer,@BlobHandle,True,False);
end;

procedure TDataCursor.GetBlob(FieldNum: Word; RecordBuffer: PChar;
                              Offset: Integer; Buffer: PChar;
                              ReadBytes: Integer; var ActualBytes: Integer;
                              UsePhysicalFields: Boolean);
var
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   ActualBytes:=0;
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   VerifyBlobHandle(BlobHandle,BlobBufferPos);
   BlobBuffer:=TBlobBuffer(BlobHandle);
   if ((Offset+ReadBytes) > BlobBuffer.Size) then
      begin
      if (Offset < BlobBuffer.Size) then
         ActualBytes:=BlobBuffer.Size-Offset;
      end
   else
      ActualBytes:=ReadBytes;
   if (ActualBytes > 0) then
      Move((BlobBuffer.Buffer+Offset)^,Buffer^,ActualBytes);
end;

procedure TDataCursor.PutBlob(FieldNum: Word; RecordBuffer: PChar;
                              Offset: Integer; Buffer: PChar;
                              WriteBytes: Integer; UsePhysicalFields: Boolean);
var
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   VerifyBlobHandle(BlobHandle,BlobBufferPos);
   BlobBuffer:=TBlobBuffer(BlobHandle);
   if (BlobBuffer.OpenMode=BLOB_OPENREADWRITE) then
      begin
      BlobBuffer.IsDirty:=True;
      if ((Offset+WriteBytes) > BlobBuffer.Size) then
         BlobBuffer.Size:=Offset+WriteBytes;
      if (WriteBytes > 0) then
         Move(Buffer^,(TBlobBuffer(BlobHandle).Buffer+Offset)^,WriteBytes);
      BlobHandle:=FlipIntegerSign(BlobHandle);
      if UsePhysicalFields then
         PutPhysicalField(FieldNum,RecordBuffer,@BlobHandle,(BlobBuffer.Size=0))
      else
         PutField(FieldNum,RecordBuffer,@BlobHandle,True,(BlobBuffer.Size=0));
      end;
end;

procedure TDataCursor.TruncateBlob(FieldNum: Word; RecordBuffer: PChar;
                                   NewBytes: Integer; UsePhysicalFields: Boolean);
var
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   VerifyBlobHandle(BlobHandle,BlobBufferPos);
   BlobBuffer:=TBlobBuffer(BlobHandle);
   if (BlobBuffer.OpenMode=BLOB_OPENREADWRITE) then
      begin
      BlobBuffer.IsDirty:=True;
      BlobBuffer.Size:=NewBytes;
      BlobHandle:=FlipIntegerSign(BlobHandle);
      if UsePhysicalFields then
         PutPhysicalField(FieldNum,RecordBuffer,@BlobHandle,(BlobBuffer.Size=0))
      else
         PutField(FieldNum,RecordBuffer,@BlobHandle,True,(BlobBuffer.Size=0));
      end;
end;

procedure TDataCursor.GetBlobSize(FieldNum: Word; RecordBuffer: PChar;
                                   var Size: Integer; UsePhysicalFields: Boolean);
var
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   Size:=0;
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   VerifyBlobHandle(BlobHandle,BlobBufferPos);
   BlobBuffer:=TBlobBuffer(BlobHandle);
   Size:=BlobBuffer.Size;
end;

function TDataCursor.ValidBlobHandle(FieldNum: Word; RecordBuffer: PChar;
                                     UsePhysicalFields: Boolean): Boolean;
var
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   IsBlank: Boolean;
begin
   Result:=False;
   BlobHandle:=0;
   if UsePhysicalFields then
      GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank)
   else
      GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
   if (BlobHandle >= 0) then Exit;
   BlobHandle:=FlipIntegerSign(BlobHandle);
   Result:=ValidBlobBufferHandle(BlobHandle,BlobBufferPos);
end;

function TDataCursor.ValidBlobBufferHandle(BlobHandle: Integer;
                                           var BlobBufferPos: Integer): Boolean;
var
   I: Integer;
begin
   Result:=False;
   BlobBufferPos:=-1;
   if (BlobHandle=0) then
      Exit;
   for I:=0 to FBlobBuffers.Count-1 do
      begin
      if (FBlobBuffers[I]=Pointer(BlobHandle)) then
         begin
         BlobBufferPos:=I;
         Result:=True;
         Exit;
         end;
      end;
end;

procedure TDataCursor.DeleteAllBlobs(RecordBuffer: PChar);
var
   I: Word;
   BlobSize: Integer;
begin
   for I:=1 to PhysicalFieldCount do
      begin
      with GetPhysicalFieldDefinition(I)^ do
         begin
         if (DataType=TYPE_BLOB) then
            begin
            OpenBlob(FieldNum,RecordBuffer,
                     BLOB_OPENREADWRITE,True,True,BlobSize,False);
            TruncateBlob(FieldNum,RecordBuffer,0,True);
            end;
         end;
      end;
end;

procedure TDataCursor.UpdateBlobBlocks(RecordBuffer: PChar;
                                       UsePhysicalFields: Boolean);
var
   I: Integer;
   TempBlobBlock: Integer;
begin
   { Update the passed record buffer with all of the new blob offsets }
   for I:=0 to FBlobBuffers.Count-1 do
      begin
      with TBlobBuffer(FBlobBuffers[I]) do
         begin
         if (OpenMode <> BLOB_OPENCOPY) then
            begin
            TempBlobBlock:=BlockNumber;
            if UsePhysicalFields then
               PutPhysicalField(FieldDefinition^.FieldNum,RecordBuffer,@TempBlobBlock,False)
            else
               PutField(FieldDefinition^.FieldNum,RecordBuffer,@TempBlobBlock,True,False);
            end;
         end;
      end;
end;

procedure TDataCursor.UpdateBlobSignatures(RecordBuffer: PChar;
                                           UsePhysicalFields: Boolean);
var
   I: Integer;
begin
   { Update the passed record buffer with all of the new blob signatures }
   for I:=0 to FBlobBuffers.Count-1 do
      begin
      with TBlobBuffer(FBlobBuffers[I]) do
         begin
         if IsDirty and (OpenMode <> BLOB_OPENCOPY) then
            begin
            Signature:=NextBlobSignature;
            PutBlobSignature(FieldDefinition^.FieldNum,RecordBuffer,Signature,UsePhysicalFields);
            end;
         end;
      end;
end;

function TDataCursor.FlushBlobBuffers: Boolean;
var
   I: Integer;
   LastRecordNumber: Integer;
   TotalDirtyBlobs: Integer;
begin
   Result:=False;
   LastRecordNumber:=0;
   if IsRemote then
      begin
      TotalDirtyBlobs:=0;
      { Write out all opened and dirty blob buffers }
      for I:=0 to FBlobBuffers.Count-1 do
         begin
         with TBlobBuffer(FBlobBuffers[I]) do
            begin
            if IsDirty and (OpenMode <> BLOB_OPENCOPY) then
               Inc(TotalDirtyBlobs);
            end;
         end;
      Pack(TotalDirtyBlobs,SizeOf(Integer));
      end;
   { Write out all opened and dirty blob buffers }
   for I:=0 to FBlobBuffers.Count-1 do
      begin
      with TBlobBuffer(FBlobBuffers[I]) do
         begin
         if IsDirty and (OpenMode <> BLOB_OPENCOPY) then
            begin
            Result:=True;
            if (LastRecordNumber <> 0) and
               (RecordNumber <> LastRecordNumber) then
               DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                                       FTableName);
            LastRecordNumber:=RecordNumber;
            if (Size > 0) then
               WriteBlob(TBlobBuffer(FBlobBuffers[I]))
            else
               RemoveBlob(TBlobBuffer(FBlobBuffers[I]));
            end;
         end;
      end;
end;

procedure TDataCursor.CancelAllBlobs(RecordBuffer: PChar);
var
   I: Word;
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   IsBlank: Boolean;
begin
   for I:=1 to FFieldCount do
      begin
      if (FFieldDefinitions[I]^.DataType=TYPE_BLOB) then
         begin
         BlobHandle:=0;
         Self.GetField(FFieldDefinitions[I]^.FieldNum,
                       RecordBuffer,@BlobHandle,IsBlank);
         if not IsBlank then
            begin
            if (BlobHandle < 0) then
               begin
               BlobHandle:=FlipIntegerSign(BlobHandle);
               if ValidBlobBufferHandle(BlobHandle,BlobBufferPos) and
                  ((not TBlobBuffer(BlobHandle).IsDirty) or
                   TBlobBuffer(BlobHandle).EngineAllocated) then
                  FreeBlob(FFieldDefinitions[I]^.FieldNum,RecordBuffer,False,True);
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.FreeAllBlobs(ForceFree: Boolean; NoRemoteCall: Boolean);
var
   I: Integer;
begin
   if IsRemote and (not NoRemoteCall) then
      begin
      StartRemoteRequest;
      try
         CheckForConnection;
         SetRequestCode(REQUEST_FREEALLBLOBS);
         BeginPack;
         Pack(FRemoteID,SizeOf(Integer));
         Pack(ForceFree,SizeOf(Boolean));
         EndPack;
         SendReceive;
         CheckForException;
      finally
         EndRemoteRequest;
      end;
      end;
   { Free all opened blob buffers allocated by the engine, regardless
     of whether they've been written to disk or not }
   for I:=FBlobBuffers.Count-1 downto 0 do
      begin
      with TBlobBuffer(FBlobBuffers[I]) do
         begin
         if ForceFree or EngineAllocated then
            begin
            Free;
            FBlobBuffers.Delete(I);
            end;
         end;
      end;
end;

procedure TDataCursor.CreateBlobCopies(RecordBuffer: PChar;
                                       UsePhysicalFields: Boolean);
var
   I: Word;
   TempSize: Integer;
begin
   for I:=1 to FieldCount do
      begin
      if (FFieldDefinitions[I]^.DataType=TYPE_BLOB) then
         OpenBlob(I,RecordBuffer,BLOB_OPENCOPY,UsePhysicalFields,
                  False,TempSize,True);
      end;
end;

procedure TDataCursor.FreeBlobCopies(RecordBuffer: PChar;
                                     UsePhysicalFields: Boolean);
var
   I: Word;
   BlobHandle: Integer;
   BlobBufferPos: Integer;
   BlobBuffer: TBlobBuffer;
   IsBlank: Boolean;
begin
   { Code duplicated from FreeBlob() for performance reasons }
   if UsePhysicalFields then
      begin
      for I:=1 to PhysicalFieldCount do
         begin
         with GetPhysicalFieldDefinition(I)^ do
            begin
            if (DataType=TYPE_BLOB) then
               begin
               BlobHandle:=0;
               GetPhysicalField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
               if (BlobHandle < 0) then
                  begin
                  BlobHandle:=FlipIntegerSign(BlobHandle);
                  if (BlobHandle <> 0) then
                     begin
                     if ValidBlobBufferHandle(BlobHandle,BlobBufferPos) then
                        begin
                        BlobBuffer:=TBlobBuffer(BlobHandle);
                        BlobBuffer.DecUseCount;
                        if (BlobBuffer.UseCount=0) then
                           begin
                           BlobHandle:=BlobBuffer.BlockNumber;
                           BlobBuffer.Free;
                           FBlobBuffers.Delete(BlobBufferPos);
                           end
                        else
                           BlobHandle:=FlipIntegerSign(BlobHandle);
                        PutPhysicalField(FieldNum,RecordBuffer,@BlobHandle,False);
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end
   else
      begin
      for I:=1 to FFieldCount do
         begin
         with FFieldDefinitions[I]^ do
            begin
            if (DataType=TYPE_BLOB) then
               begin
               BlobHandle:=0;
               GetField(FieldNum,RecordBuffer,@BlobHandle,IsBlank);
               if (BlobHandle < 0) then
                  begin
                  BlobHandle:=FlipIntegerSign(BlobHandle);
                  if (BlobHandle <> 0) then
                     begin
                     if ValidBlobBufferHandle(BlobHandle,BlobBufferPos) then
                        begin
                        BlobBuffer:=TBlobBuffer(BlobHandle);
                        BlobBuffer.DecUseCount;
                        if (BlobBuffer.UseCount=0) then
                           begin
                           BlobHandle:=BlobBuffer.BlockNumber;
                           BlobBuffer.Free;
                           FBlobBuffers.Delete(BlobBufferPos);
                           end
                        else
                           BlobHandle:=FlipIntegerSign(BlobHandle);
                        PutField(FieldNum,RecordBuffer,@BlobHandle,False,False);
                        end;
                     end;
                  end;
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.AddTextIndexes(NewRecord: TRecord);
var
   I: Byte;
   J: Integer;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
begin
   InternalSetIndexPos(TEXT_INDEX_POS);
   for I:=1 to FKeyFieldCount do
      begin
      if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
         begin
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          NewRecord.Buffer,@TempFieldBuffer,IsBlank);
         if (not IsBlank) then
            begin
            if FAlteringStructure then
               AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldPos,
                                FKeyFieldDefinitions[I]^.FieldName,
                                @TempFieldBuffer,
                                StrLen(@TempFieldBuffer),
                                NewRecord.ID,NewRecord.Number)
            else
               AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                FKeyFieldDefinitions[I]^.FieldName,
                                @TempFieldBuffer,
                                StrLen(@TempFieldBuffer),
                                NewRecord.ID,NewRecord.Number);
            end;
         end
      else if (FKeyFieldDefinitions[I]^.DataType=TYPE_BLOB) and
              (FKeyFieldDefinitions[I]^.SubType=SUBTYPE_MEMO) then
         begin
         for J:=0 to FBlobBuffers.Count-1 do
            begin
            with TBlobBuffer(FBlobBuffers[J]) do
               begin
               if IsDirty and (FieldDefinition^.FieldNum=FKeyFieldDefinitions[I]^.FieldNum) then
                  begin
                  if FAlteringStructure then
                     AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldPos,
                                      FKeyFieldDefinitions[I]^.FieldName,
                                      Buffer,Size,
                                      NewRecord.ID,NewRecord.Number)
                  else
                     AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                      FKeyFieldDefinitions[I]^.FieldName,
                                      Buffer,Size,
                                      NewRecord.ID,NewRecord.Number);
                  end;
               end;
            end;
         end;
      end;
end;

function TDataCursor.VerifyTextIndexes(CurRecord: TRecord): Boolean;
var
   I: Byte;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   BlobHandle: Integer;
   BlobSize: Integer;
   IsBlank: Boolean;
begin
   Result:=True;
   InternalSetIndexPos(TEXT_INDEX_POS);
   for I:=1 to FKeyFieldCount do
      begin
      if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
         begin
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          CurRecord.Buffer,@TempFieldBuffer,IsBlank);
         if (not IsBlank) then
            begin
            Result:=VerifyTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                        FKeyFieldDefinitions[I]^.FieldName,
                                        @TempFieldBuffer,StrLen(@TempFieldBuffer),
                                        CurRecord.ID,CurRecord.Number);
            if (not Result) then
               Break;
            end;
         end
      else if (FKeyFieldDefinitions[I]^.DataType=TYPE_BLOB) and
              (FKeyFieldDefinitions[I]^.SubType=SUBTYPE_MEMO) then
         begin
         OpenBlob(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,
                  BLOB_OPENREADWRITE,True,True,BlobSize,False);
         try
            GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,
                             @BlobHandle,IsBlank);
            BlobHandle:=FlipIntegerSign(BlobHandle);
            if (not IsBlank) then
               begin
               with TBlobBuffer(BlobHandle) do
                  begin
                  Result:=VerifyTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                              FKeyFieldDefinitions[I]^.FieldName,
                                              Buffer,BlobSize,
                                              CurRecord.ID,CurRecord.Number);
                  if (not Result) then
                     Break;
                  end;
               end;
         finally
            FreeBlob(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,True,True);
         end;
         end;
      end;
end;

procedure TDataCursor.CreateTextIndexes(CurRecord: TRecord);
var
   I: Byte;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   BlobHandle: Integer;
   BlobSize: Integer;
   IsBlank: Boolean;
begin
   InternalSetIndexPos(TEXT_INDEX_POS);
   for I:=1 to FKeyFieldCount do
      begin
      if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
         begin
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          CurRecord.Buffer,@TempFieldBuffer,IsBlank);
         if (not IsBlank) then
            AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                             FKeyFieldDefinitions[I]^.FieldName,                                 
                             @TempFieldBuffer,StrLen(@TempFieldBuffer),
                             CurRecord.ID,CurRecord.Number);
         end
      else if (FKeyFieldDefinitions[I]^.DataType=TYPE_BLOB) and
              (FKeyFieldDefinitions[I]^.SubType=SUBTYPE_MEMO) then
         begin
         OpenBlob(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,
                  BLOB_OPENREADWRITE,True,True,BlobSize,False);
         try
            GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,
                             @BlobHandle,IsBlank);
            BlobHandle:=FlipIntegerSign(BlobHandle);
            if (not IsBlank) then
               begin
               with TBlobBuffer(BlobHandle) do
                  AddTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                   FKeyFieldDefinitions[I]^.FieldName,
                                   Buffer,BlobSize,
                                   CurRecord.ID,CurRecord.Number);
               end;
         finally
            FreeBlob(FKeyFieldDefinitions[I]^.FieldNum,CurRecord.Buffer,True,True);
         end;
         end;
      end;
end;

function TDataCursor.ModifyTextIndexes(CurRecord: TRecord; OldRecord: TRecord): Boolean;
var
   I: Byte;
   J: Integer;
   NewTempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   OldTempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   NewIsBlank: Boolean;
   OldIsBlank: Boolean;
begin
   Result:=False;
   InternalSetIndexPos(TEXT_INDEX_POS);
   for I:=1 to FKeyFieldCount do
      begin
      if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
         begin
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          OldRecord.Buffer,@OldTempFieldBuffer,
                          OldIsBlank);
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          CurRecord.Buffer,@NewTempFieldBuffer,
                          NewIsBlank);
         if (not (OldIsBlank and NewIsBlank)) then
            Result:=ModifyTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                        FKeyFieldDefinitions[I]^.FieldName,
                                        @NewTempFieldBuffer,StrLen(@NewTempFieldBuffer),
                                        @OldTempFieldBuffer,StrLen(@OldTempFieldBuffer),
                                        CurRecord.ID,OldRecord.ID,OldRecord.Number);
         end
      else if (FKeyFieldDefinitions[I]^.DataType=TYPE_BLOB) and
              (FKeyFieldDefinitions[I]^.SubType=SUBTYPE_MEMO) then
         begin
         for J:=0 to FBlobBuffers.Count-1 do
            begin
            with TBlobBuffer(FBlobBuffers[J]) do
               begin
               if IsDirty and (FieldDefinition^.FieldNum=FKeyFieldDefinitions[I]^.FieldNum) then
                  Result:=ModifyTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                              FKeyFieldDefinitions[I]^.FieldName,
                                              Buffer,Size,OldBuffer,OldSize,
                                              CurRecord.ID,OldRecord.ID,OldRecord.Number);
               end;
            end;
         end;
      end;
end;

procedure TDataCursor.RemoveTextIndexes(CurRecord: TRecord);
var
   I: Byte;
   J: Integer;
   TempFieldBuffer: array [0..MAX_FIELD_SIZE] of Char;
   IsBlank: Boolean;
begin
   InternalSetIndexPos(TEXT_INDEX_POS);
   for I:=1 to FKeyFieldCount do
      begin
      if (FKeyFieldDefinitions[I]^.DataType=TYPE_ZSTRING) then
         begin
         GetPhysicalField(FKeyFieldDefinitions[I]^.FieldNum,
                          CurRecord.Buffer,@TempFieldBuffer,IsBlank);
         if (not IsBlank) then
            RemoveTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                FKeyFieldDefinitions[I]^.FieldName,
                                @TempFieldBuffer,
                                StrLen(@TempFieldBuffer),
                                CurRecord.ID);
         end
      else if (FKeyFieldDefinitions[I]^.DataType=TYPE_BLOB) and
              (FKeyFieldDefinitions[I]^.SubType=SUBTYPE_MEMO) then
         begin
         for J:=0 to FBlobBuffers.Count-1 do
            begin
            with TBlobBuffer(FBlobBuffers[J]) do
               begin
               if IsDirty and (FieldDefinition^.FieldNum=FKeyFieldDefinitions[I]^.FieldNum) then
                  RemoveTextKeyValues(FKeyFieldDefinitions[I]^.FieldNum,
                                      FKeyFieldDefinitions[I]^.FieldName,
                                      OldBuffer,OldSize,
                                      CurRecord.ID);
               end;
            end;
         end;
      end;
end;

function TDataCursor.IsTextIndexed(FieldNumber: Word): Boolean;
var
   I: Byte;
begin
   Result:=False;
   with GetIndexDefinition(TEXT_INDEX_POS)^ do
      begin
      I:=1;
      while (KeyFields[I] <> 0) and (I <= MAX_NUM_FLDSINKEY) do
         begin
         if (FieldNumber=KeyFields[I]) then
            begin
            Result:=True;
            Break;
            end;
         Inc(I);
         end;
      end;
end;

procedure TDataCursor.CreateWordsList(const TableName: string; const FieldName: string;
                                      WordBuffer: PChar; WordBufferSize: Integer;
                                      WordsList: TLocaleStringList;
                                      AllowPartialWords: Boolean);
begin
   GetTextIndexParams;
   DataEngine.BuildWordList(TableName,FieldName,WordBuffer,WordBufferSize,WordsList,
                            FTextSpaceChars,FTextIncludeChars,True,AllowPartialWords);
end;

procedure TDataCursor.AddTextKeyValues(FieldNum: Word; const FieldName: string;
                                       WordBuffer: PChar; WordBufferSize: Integer;
                                       RecordID: Integer; RecordNum: Integer);
var
   TempWordsList: TLocaleStringList;
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   StopWordPos: Integer;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   TempWordsList:=TLocaleStringList.Create;
   try
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 WordBuffer,WordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempWordsList,False);
      finally
         if (TempOutBuffer <> WordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      for I:=0 to TempWordsList.Count-1 do
         begin
         if (not FTextStopWords.Find(TempWordsList[I],StopWordPos)) then
            begin
            FillChar(TempKeyBuffer,SizeOf(TempKeyBuffer),#0);
            Boolean(TempKeyBuffer[0]):=True;
            FlipWordBits(FieldNum,@TempKeyBuffer[FLDCHG_DATA]);
            Move(TempWordsList[I][1],TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                 Length(TempWordsList[I]));
            OSUpperString(FLocaleID,
                          @TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
            FlipIntegerBits(RecordID,@TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE+
                                                         TEXT_WORD_SIZE]);
            AddIndexKey(@TempKeyBuffer,RecordNum);
            end;
         end;
   finally
      TempWordsList.Free;
   end;
end;

function TDataCursor.ModifyTextKeyValues(FieldNum: Word; const FieldName: string;
                                         WordBuffer: PChar; WordBufferSize: Integer;
                                         OldWordBuffer: PChar; OldWordBufferSize: Integer;
                                         RecordID: Integer; OldRecordID: Integer;
                                         RecordNum: Integer): Boolean;
var
   TempOldWordsList: TLocaleStringList;
   TempWordsList: TLocaleStringList;
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   StopWordPos: Integer;
   OldWordPos: Integer;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   Result:=False;
   TempWordsList:=TLocaleStringList.Create;
   TempOldWordsList:=TLocaleStringList.Create;
   try
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 WordBuffer,WordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempWordsList,False);
      finally
         if (TempOutBuffer <> WordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 OldWordBuffer,OldWordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempOldWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempOldWordsList,False);
      finally
         if (TempOutBuffer <> OldWordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      if (RecordID=OldRecordID) then
         begin
         for I:=TempWordsList.Count-1 downto 0 do
            begin
            if TempOldWordsList.Find(TempWordsList[I],OldWordPos) then
               begin
               TempOldWordsList.Delete(OldWordPos);
               TempWordsList.Delete(I);
               end;
            end;
         end;
      for I:=0 to TempOldWordsList.Count-1 do
         begin
         if (not FTextStopWords.Find(TempOldWordsList[I],StopWordPos)) then
            begin
            FillChar(TempKeyBuffer,SizeOf(TempKeyBuffer),#0);
            Boolean(TempKeyBuffer[0]):=True;
            FlipWordBits(FieldNum,@TempKeyBuffer[FLDCHG_DATA]);
            Move(TempOldWordsList[I][1],TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                 Length(TempOldWordsList[I]));
            OSUpperString(FLocaleID,
                          @TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
            FlipIntegerBits(RecordID,@TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE+
                                                         TEXT_WORD_SIZE]);
            RemoveIndexKey(@TempKeyBuffer);
            Result:=True;
            end;
         end;
      for I:=0 to TempWordsList.Count-1 do
         begin
         if (not FTextStopWords.Find(TempWordsList[I],StopWordPos)) then
            begin
            FillChar(TempKeyBuffer,SizeOf(TempKeyBuffer),#0);
            Boolean(TempKeyBuffer[0]):=True;
            FlipWordBits(FieldNum,@TempKeyBuffer[FLDCHG_DATA]);
            Move(TempWordsList[I][1],TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                 Length(TempWordsList[I]));
            OSUpperString(FLocaleID,
                          @TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
            FlipIntegerBits(RecordID,@TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE+
                                                         TEXT_WORD_SIZE]);
            AddIndexKey(@TempKeyBuffer,RecordNum);
            Result:=True;
            end;
         end;
   finally
      TempOldWordsList.Free;
      TempWordsList.Free;
   end;
end;

procedure TDataCursor.RemoveTextKeyValues(FieldNum: Word; const FieldName: string;
                                          WordBuffer: PChar; WordBufferSize: Integer;
                                          RecordID: Integer);
var
   TempWordsList: TLocaleStringList;
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   TempWordsList:=TLocaleStringList.Create;
   try
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 WordBuffer,WordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempWordsList,False);
      finally
         if (TempOutBuffer <> WordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      for I:=0 to TempWordsList.Count-1 do
         begin
         FillChar(TempKeyBuffer,SizeOf(TempKeyBuffer),#0);
         Boolean(TempKeyBuffer[0]):=True;
         FlipWordBits(FieldNum,@TempKeyBuffer[FLDCHG_DATA]);
         Move(TempWordsList[I][1],TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
              Length(TempWordsList[I]));
         OSUpperString(FLocaleID,
                       @TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
         FlipIntegerBits(RecordID,@TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE+
                                                      TEXT_WORD_SIZE]);
         if SearchIndexKeys(@TempKeyBuffer) then
            RemoveIndexKey(@TempKeyBuffer);
         end;
   finally
      TempWordsList.Free;
   end;
end;

function TDataCursor.VerifyTextKeyValues(FieldNum: Word; const FieldName: string;
                                         WordBuffer: PChar; WordBufferSize: Integer;
                                         RecordID: Integer; RecordNum: Integer): Boolean;
var
   TempWordsList: TLocaleStringList;
   I: Integer;
   TempKeyBuffer: array [0..MAX_KEYLEN-1] of Char;
   StopWordPos: Integer;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   Result:=True;
   TempWordsList:=TLocaleStringList.Create;
   try
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 WordBuffer,WordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempWordsList,False);
      finally
         if (TempOutBuffer <> WordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      for I:=0 to TempWordsList.Count-1 do
         begin
         if (not FTextStopWords.Find(TempWordsList[I],StopWordPos)) then
            begin
            FillChar(TempKeyBuffer,SizeOf(TempKeyBuffer),#0);
            Boolean(TempKeyBuffer[0]):=True;
            FlipWordBits(FieldNum,@TempKeyBuffer[FLDCHG_DATA]);
            Move(TempWordsList[I][1],TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE],
                 Length(TempWordsList[I]));
            OSUpperString(FLocaleID,
                          @TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE]);
            FlipIntegerBits(RecordID,@TempKeyBuffer[FLDCHG_DATA+TEXT_FLDNUM_SIZE+
                                                         TEXT_WORD_SIZE]);
            Result:=VerifyIndexKey(@TempKeyBuffer,RecordNum);
            if (not Result) then
               Break;
            end;
         end;
   finally
      TempWordsList.Free;
   end;
end;

function TDataCursor.TextOccurs(FieldNum: Word; const FieldName: string;
                                SearchWordBuffer: PChar;
                                SearchWordBufferSize: Integer;
                                ValueWordBuffer: PChar;
                                ValueWordBufferSize: Integer): Integer;
var
   TempSearchWordsList: TLocaleStringList;
   TempValueWordsList: TLocaleStringList;
   I: Integer;
   StopWordPos: Integer;
   ValueWordPos: Integer;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   Result:=0;
   TempSearchWordsList:=TLocaleStringList.Create;
   TempValueWordsList:=TLocaleStringList.Create;
   try
      with TempSearchWordsList do
         begin
         SetLocaleID(FLocaleID);
         Duplicates:=dupIgnore;
         Sorted:=True;
         end;
      CreateWordsList(FTableName,FieldName,
                      SearchWordBuffer,SearchWordBufferSize,TempSearchWordsList,True);
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 ValueWordBuffer,ValueWordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempValueWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempValueWordsList,False);
      finally
         if (TempOutBuffer <> ValueWordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      for I:=0 to TempSearchWordsList.Count-1 do
         begin
         if (TempSearchWordsList[I][Length(TempSearchWordsList[I])]=PARSE_ASTERISK) then
            begin
            ValueWordPos:=0;
            while TempValueWordsList.FindPartial(TempSearchWordsList[I],ValueWordPos,
                                                 Length(TempSearchWordsList[I])-1) do
               begin
               Inc(Result,Integer(TempValueWordsList.Objects[ValueWordPos]));
               Inc(ValueWordPos);
               end;
            end
         else
            begin
            if (not FTextStopWords.Find(TempSearchWordsList[I],StopWordPos)) then
               begin
               ValueWordPos:=0;
               if TempValueWordsList.Find(TempSearchWordsList[I],ValueWordPos) then
                  Inc(Result,Integer(TempValueWordsList.Objects[ValueWordPos]));
               end;
            end;
         end;
   finally
      TempValueWordsList.Free;
      TempSearchWordsList.Free;
   end;
end;

function TDataCursor.TextSearch(FieldNum: Word; const FieldName: string;
                                SearchWordBuffer: PChar;
                                SearchWordBufferSize: Integer;
                                ValueWordBuffer: PChar;
                                ValueWordBufferSize: Integer): Boolean;
var
   TempSearchWordsList: TLocaleStringList;
   TempValueWordsList: TLocaleStringList;
   I: Integer;
   StopWordPos: Integer;
   ValueWordPos: Integer;
   TempOutBuffer: Pointer;
   TempOutBufferSize: Integer;
begin
   Result:=True;
   TempSearchWordsList:=TLocaleStringList.Create;
   TempValueWordsList:=TLocaleStringList.Create;
   try
      with TempSearchWordsList do
         begin
         SetLocaleID(FLocaleID);
         Duplicates:=dupIgnore;
         Sorted:=True;
         end;
      CreateWordsList(FTableName,FieldName,
                      SearchWordBuffer,SearchWordBufferSize,TempSearchWordsList,True);
      DataEngine.TextIndexFilter(FTableName,FieldName,
                                 ValueWordBuffer,ValueWordBufferSize,
                                 TempOutBuffer,TempOutBufferSize);
      try
         with TempValueWordsList do
            begin
            SetLocaleID(FLocaleID);
            Duplicates:=dupIgnore;
            Sorted:=True;
            end;
         CreateWordsList(FTableName,FieldName,
                         TempOutBuffer,TempOutBufferSize,TempValueWordsList,False);
      finally
         if (TempOutBuffer <> ValueWordBuffer) then
            DeAllocMem(TempOutBuffer);
      end;
      for I:=0 to TempSearchWordsList.Count-1 do
         begin
         if (TempSearchWordsList[I][Length(TempSearchWordsList[I])]=PARSE_ASTERISK) then
            begin
            ValueWordPos:=0;
            if (not TempValueWordsList.FindPartial(TempSearchWordsList[I],ValueWordPos,
                                                   Length(TempSearchWordsList[I])-1)) then
               begin
               Result:=False;
               Break;
               end;
            end
         else
            begin
            if (not FTextStopWords.Find(TempSearchWordsList[I],StopWordPos)) then
               begin
               ValueWordPos:=0;
               if (not TempValueWordsList.Find(TempSearchWordsList[I],ValueWordPos)) then
                  begin
                  Result:=False;
                  Break;
                  end;
               end;
            end;
         end;
   finally
      TempValueWordsList.Free;
      TempSearchWordsList.Free;
   end;
end;

{ TRecord }

procedure TRecord.Copy(BufferToCopy: TBuffer);
begin
   inherited;
end;

procedure TRecord.Initialize(DefinitionPos: Byte=0);
begin
   inherited;
end;

procedure TRecord.Read(ReadBuffer: PChar);
begin
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Decrypt(ReadBuffer,FBufferedFile.IOBlockSize);
   Move(ReadBuffer^,FBuffer^,FBufferedFile.BufferSize);
   FIsDirty:=False;
end;

procedure TRecord.Write(WriteBuffer: PChar);
begin
   Move(FBuffer^,WriteBuffer^,FBufferedFile.BufferSize);
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Encrypt(WriteBuffer,FBufferedFile.IOBlockSize);
   FIsDirty:=False;
end;

function TRecord.GetStatus: Byte;
begin
   Result:=pRecordHeader(FBuffer)^.StatusFlag;
end;

procedure TRecord.SetStatus(Value: Byte);
begin
   pRecordHeader(FBuffer)^.StatusFlag:=Value;
   FIsDirty:=True;
end;

function TRecord.GetNextFreeNumber: Integer;
begin
   if (pRecordHeader(FBuffer)^.StatusFlag=RECORD_DELETED) then
      Result:=pRecordHeader(FBuffer)^.NextFreeNumber
   else
      Result:=0;
end;

function TRecord.GetOriginalNumber: Integer;
begin
   Result:=pRecordHeader(FBuffer)^.NextFreeNumber;
end;

function TRecord.GetID: Integer;
begin
   Result:=pRecordHeader(FBuffer)^.ID;
end;

procedure TRecord.SetID(Value: Integer);
begin
   pRecordHeader(FBuffer)^.ID:=Value;
   FIsDirty:=True;
end;

function TRecord.GetHash: TMD5Digest;
begin
   Result:=pRecordHeader(FBuffer)^.Hash;
end;

procedure TRecord.SetHash(Value: TMD5Digest);
begin
   pRecordHeader(FBuffer)^.Hash:=Value;
   FIsDirty:=True;
end;

procedure TRecord.SetNextFreeNumber(Value: Integer);
begin
   pRecordHeader(FBuffer)^.NextFreeNumber:=Value;
   FIsDirty:=True;
end;

procedure TRecord.SetOriginalNumber(Value: Integer);
begin
   pRecordHeader(FBuffer)^.NextFreeNumber:=Value;
end;

{ TDataFile }

constructor TDataFile.Create(Owner: TObject);
begin
   inherited Create(Owner);
   if (not FDataTable.IsRemote) then
      FFieldsAreDirty:=False;
   with FRecordIDField do
      begin
      FieldNum:=RECORDID_FIELD_NUM;
      FieldName:=RECORDID_FIELD_NAME;
      DataType:=TYPE_INT32;
      DataSize:=RECORDID_SIZE;
      Offset:=(DELETEFLAG_SIZE+NEXTFREE_SIZE);
      end;
   with FRecordHashField do
      begin
      FieldNum:=RECORDHASH_FIELD_NUM;
      FieldName:=RECORDHASH_FIELD_NAME;
      DataType:=TYPE_BYTES;
      SubType:=SUBTYPE_MD5;
      Length:=RECORDHASH_SIZE;
      DataSize:=RECORDHASH_SIZE;
      Offset:=(DELETEFLAG_SIZE+NEXTFREE_SIZE+RECORDID_SIZE);
      end;
end;

destructor TDataFile.Destroy;
begin
   if FDataTable.IsRemote then
      FreeFieldDefinitions;
   inherited Destroy;
end;

function TDataFile.GetProperFileName: string;
begin
   Result:=FDataTable.ProperTableName;
end;

procedure TDataFile.UnpackStaticTableInfo;
var
   I: Word;
   TempPassword: string;
begin
   FDataTable.Unpack(FHeader);
   if (FDataTable.DataSession.RemoteEngineVersion >= 4.16) then
      begin
      TempPassword[0]:=Char(Byte(FDataTable.Unpack(TempPassword[1])));
      FDataTable.DataPassword.Initialize(TempPassword);
      end;
   for I:=1 to FHeader.FieldCount do
      begin
      FFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
      FDataTable.Unpack(FFieldDefinitions[I]^);
      end;
end;

procedure TDataFile.UnpackVariableTableInfo;
begin
   FDataTable.Unpack(FHeader.NextEndingRecord);
   Inc(FHeader.NextEndingRecord);
   FDataTable.Unpack(FHeader.LastAutoIncID);
   FDataTable.Unpack(FHeader.LastUpdated);
   FHeader.LastUpdated:=(FHeader.LastUpdated-DateDelta);
   FDataTable.Unpack(FHeader.RecordCount);
end;

procedure TDataFile.LocalUnpackVariableTableInfo(DataCursor: TDataCursor);
begin
   DataCursor.LocalUnpack(FHeader.NextEndingRecord);
   Inc(FHeader.NextEndingRecord);
   DataCursor.LocalUnpack(FHeader.LastAutoIncID);
   DataCursor.LocalUnpack(FHeader.LastUpdated);
   FHeader.LastUpdated:=(FHeader.LastUpdated-DateDelta);
   DataCursor.LocalUnpack(FHeader.RecordCount);
end;

function TDataFile.CheckForChanges: Boolean;
var
   LastUpdateStamp: Integer;
begin
   Result:=False;
   LastUpdateStamp:=FHeader.UpdateStamp;
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TDataHeader),False);
   finally
      UnlockFile;
   end;
   FHeader.IsDirty:=False;
   if (FHeader.UpdateStamp <> LastUpdateStamp) then
      Result:=True;
end;

procedure TDataFile.GetHeader(var Header: TDataHeader);
begin
   Header:=FHeader;
end;

procedure TDataFile.ReadHeader;
begin
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TDataHeader),False);
   finally
      UnlockFile;
   end;
   FHeader.IsDirty:=False;
end;

function TDataFile.WriteHeader(ForceHeader: Boolean): Boolean;
begin
   Result:=False;
   if FHeader.IsDirty or ForceHeader then
      begin
      Result:=True;
      Inc(FHeader.UpdateStamp);
      FHeader.LastUpdated:=(Now-DateDelta);
      LockFile;
      try
         Seek(0,FROM_BOF);
         Write(FHeader,SizeOf(TDataHeader));
         FDataTable.WrittenTo:=True;
         FHeader.IsDirty:=False;
      finally
         UnlockFile;
      end;
      end;
end;

procedure TDataFile.UpdateHeaderStamp;
begin
   Inc(FHeader.UpdateStamp);
   FHeader.IsDirty:=True;
   FDataTable.WrittenTo:=True;
end;

procedure TDataFile.ClearHeader;
begin
   inherited;
   with FHeader do
      begin
      UpdateStamp:=0;
      NextFreeRecord:=0;
      NextEndingRecord:=1;
      LastRecordID:=0;
      LastAutoIncID:=0;
      RecordCount:=0;
      IsDirty:=True;
      end;
end;

procedure TDataFile.AddFields(NumberOfFields: Word;
                              const FieldDefinitions: array of pFieldDefinition);
var
   I: Word;
   TempRecordSize: Integer;
begin
   FillChar(FFieldDefinitions,SizeOf(FFieldDefinitions),#0);
   with FHeader do
      begin
      FieldCount:=NumberOfFields;
      BlobFieldCount:=0;
      IsDirty:=True;
      end;
   TempRecordSize:=SizeOf(TRecordHeader);
   for I:=1 to FHeader.FieldCount do
      begin
      FFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
      FFieldDefinitions[I]^:=FieldDefinitions[I-1]^;
      with FFieldDefinitions[I]^ do
         begin
         if (DataType=TYPE_BLOB) then
            begin
            if (FHeader.BlobFieldCount=MAX_NUM_BLOBS) then
               DataEngine.RaiseError(DBISAM_BLOBLIMIT,'','',ProperDataDirectoryName,
                                       TableName);
            Inc(FHeader.BlobFieldCount);
            end;
         if (not ExpressionField) then
            Inc(TempRecordSize,FLDCHG_DATA+DataSize)
         end;
      end;
   TempRecordSize:=BlockOffset(TempRecordSize,CRYPTO_BLOCK_SIZE);
   if (TempRecordSize > MAX_RECORD_SIZE) then
      DataEngine.RaiseError(DBISAM_RECTOOBIG,'','',ProperDataDirectoryName,
                              TableName);
   FHeader.RecordLength:=TempRecordSize;
   FFieldsAreDirty:=True;
end;

procedure TDataFile.ReadFields;
var
   I: Word;
begin
   ResizeReadBuffer((FHeader.FieldCount*SizeOf(TFieldDefinition)));
   try
      LockFile;
      try
         Seek(SizeOf(TDataHeader),FROM_BOF);
         Read(FReadBuffer^,(FHeader.FieldCount*SizeOf(TFieldDefinition)),False);
      finally
         UnlockFile;
      end;
      if FDataTable.Encrypted then
         FDataTable.Decrypt(FReadBuffer,(FHeader.FieldCount*SizeOf(TFieldDefinition)));
      for I:=1 to FHeader.FieldCount do
         Move((FReadBuffer+((I-1)*SizeOf(TFieldDefinition)))^,
              FFieldDefinitions[I]^,SizeOf(TFieldDefinition));
      FFieldsAreDirty:=False;
   finally
      ResizeReadBuffer(0);
   end;
end;

function TDataFile.WriteFields: Boolean;
var
   I: Word;
begin
   Result:=False;
   if FFieldsAreDirty then
      begin
      Result:=True;
      ResizeWriteBuffer((FHeader.FieldCount*SizeOf(TFieldDefinition)));
      try
         for I:=1 to FHeader.FieldCount do
            Move(FFieldDefinitions[I]^,
                 (FWriteBuffer+((I-1)*SizeOf(TFieldDefinition)))^,
                 SizeOf(TFieldDefinition));
         if FDataTable.Encrypted then
            FDataTable.Encrypt(FWriteBuffer,(FHeader.FieldCount*SizeOf(TFieldDefinition)));
         LockFile;
         try
            Seek(SizeOf(TDataHeader),FROM_BOF);
            Write(FWriteBuffer^,(FHeader.FieldCount*SizeOf(TFieldDefinition)));
            if FDataTable.DataDirectory.DataSession.ForceBufferFlush then
               Flush;
         finally
            UnlockFile;
         end;
         FFieldsAreDirty:=False;
      finally
         ResizeWriteBuffer(0);
      end;
      end;
end;

function TDataFile.CreateBuffer: TBuffer;
begin
   Result:=TRecord.Create(Self);
end;

procedure TDataFile.CorruptError;
begin
   DataEngine.RaiseError(DBISAM_FILECORRUPT,'','',ProperDataDirectoryName,
                           TableName);
end;

procedure TDataFile.CheckMaxBuffers;
begin
   if (IOBlocksUsed >= DataEngine.MaximumNumRecords) or
      (FileSize > DataEngine.MaximumFileSize) then
      DataEngine.RaiseError(DBISAM_TABLEFULL,'','',ProperDataDirectoryName,
                            TableName);
end;

procedure TDataFile.IncNextBuffer;
begin
   Inc(FHeader.NextEndingRecord);
   FHeader.IsDirty:=True;
end;

function TDataFile.CalculateCapacity: Integer;
begin
   if (BufferSize <> 0) then
      Result:=(DataEngine.MaxDataBufferSize div (BufferSize+TRecord.InstanceSize))
   else
      Result:=DataEngine.MaxDataBufferCount;
   Result:=MinimumInteger(Result,DataEngine.MaxDataBufferCount);
   Result:=MaximumInteger(Result,1);
end;

function TDataFile.CalculateReadAhead: Integer;
begin
   Result:=(FBuffers.Capacity div 2);
   Result:=MaximumInteger(Result,1);
end;

function TDataFile.GetIOBlockSize: Word;
begin
   Result:=FHeader.RecordLength;
end;

function TDataFile.GetBufferSize: Word;
begin
   Result:=FHeader.RecordLength;
end;

function TDataFile.GetHeaderSize: Int64;
begin
   Result:=(Int64(SizeOf(TDataHeader))+(Int64(SizeOf(TFieldDefinition))*Int64(FHeader.FieldCount)));
end;

function TDataFile.GetIOBlocksUsed: Integer;
begin
   Result:=(FHeader.NextEndingRecord-1);
end;

function TDataFile.GetLastUpdateStamp: Integer;
begin
   Result:=FHeader.UpdateStamp;
end;

function TDataFile.GetMRUBuffers: Byte;
begin
   Result:=DEFAULT_MRU_RECORDS;
end;

function TDataFile.GetBufferExpand: Byte;
begin
   Result:=RECORD_BUFFER_EXPAND;
end;

function TDataFile.GetReadAheadBuffers(DataCursor: TDataCursor;
                                       Direction: Byte): Integer;
begin
   Result:=DataCursor.GetNumReadAheadRecords(ReadAheadBuffers,Direction);
end;

function TDataFile.GetNextFreeRecordNumber: Integer;
begin
   if (FHeader.NextFreeRecord <> 0) then
      Result:=FHeader.NextFreeRecord
   else
      Result:=FHeader.NextEndingRecord;
end;

procedure TDataFile.SetNextFreeRecordNumber(Value: Integer);
begin
   if (Value <> FHeader.NextFreeRecord) then
      begin
      FHeader.NextFreeRecord:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TDataFile.LockRecord(RecordToLock: Integer): Boolean;
begin
   Result:=LockRegion((DataEngine.RecordLockByte-RecordToLock),1,True);
end;

function TDataFile.UnlockRecord(RecordToUnlock: Integer): Boolean;
begin
   Result:=LockRegion((DataEngine.RecordLockByte-RecordToUnlock),1,False);
end;

function TDataFile.LockTable: Boolean;
begin
   Result:=LockRegion((DataEngine.RecordLockByte-DataEngine.RecordLockRange),
                       DataEngine.RecordLockRange,True);
end;

function TDataFile.UnlockTable: Boolean;
begin
   Result:=LockRegion((DataEngine.RecordLockByte-DataEngine.RecordLockRange),
                       DataEngine.RecordLockRange,False);
end;

function TDataFile.LockSemaphore(SemaphoreToLock: Integer): Boolean;
begin
   Result:=LockRegion((DataEngine.SemaphoreLockByte-SemaphoreToLock),1,True);
end;

function TDataFile.UnlockSemaphore(SemaphoreToUnlock: Integer): Boolean;
begin
   Result:=LockRegion((DataEngine.SemaphoreLockByte-SemaphoreToUnlock),1,False);
end;

procedure TDataFile.OpenFile;
var
   I: Word;
begin
   inherited OpenFile;
   FillChar(FHeader,SizeOf(TDataHeader),#0);
   FillChar(FFieldDefinitions,SizeOf(FFieldDefinitions),#0);
   { Read the header data }
   ReadHeader;
   { Check the version information }
   if (FHeader.VersionNum <> VERSION_NUMBER) then
      begin
      if DataEngine.ValidVersion(FHeader.VersionNum) then
         DataEngine.RaiseError(DBISAM_OLDVERSION,'','',ProperDataDirectoryName,
                               TableName)
      else
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end
   else
      begin
      if (not MD5DigestCompare(FHeader.FileSignature,DataEngine.SignatureDigest)) and
         (not MD5DigestCompare(FHeader.FileSignature,MD5String(DBISAM_SIGNATURE))) then
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end;
   if (FHeader.FieldCount > MAX_NUM_FIELDS) then
      DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                              TableName);
   if FHeader.Encrypted then
      FDataTable.VerifyDigest(FHeader.Digest);
   for I:=1 to FHeader.FieldCount do
      FFieldDefinitions[I]:=AllocMem(SizeOf(TFieldDefinition));
   { Read in the field definitions }
   ReadFields;
   InitializeBuffers;
end;

procedure TDataFile.CloseFile;
begin
   FreeFieldDefinitions;
   inherited CloseFile;
end;

procedure TDataFile.FreeFieldDefinitions;
var
   I: Word;
begin
   if (FHeader.FieldCount > 0) and
      (FHeader.FieldCount <= MAX_NUM_FIELDS) then
      begin
      for I:=1 to FHeader.FieldCount do
         DeAllocMem(FFieldDefinitions[I]);
      end;
end;

procedure TDataFile.CreateFile;
begin
   inherited CreateFile;
   FillChar(FHeader,SizeOf(TDataHeader),#0);
   FillChar(FFieldDefinitions,SizeOf(FFieldDefinitions),#0);
   FHeader.VersionNum:=VERSION_NUMBER;
   FHeader.FileSignature:=DataEngine.SignatureDigest;
   FHeader.NextEndingRecord:=1;
   FHeader.IsDirty:=True;
end;

procedure TDataFile.CheckHeader;
var
   I: Word;
   J: Word;
   TotalSize: Int64;
   TempRecordSize: Integer;
   TempRecordHangSize: Integer;
   TempHeaderSize: Integer;
begin
   try
      { Check the language driver for availability }
      if (FHeader.LocaleID <> LOCALE_ANSI_STD) then
         begin
         if (not OSValidLocale(FHeader.LocaleID)) then
            DataEngine.RaiseError(DBISAM_CANNOTLOADLDDRV,'','',ProperDataDirectoryName,
                                    TableName);
         end;
      { Calculate the header size }
      TempHeaderSize:=(SizeOf(TDataHeader)+(SizeOf(TFieldDefinition)*FHeader.FieldCount));
      { Re-calculate the correct record length }
      TempRecordSize:=SizeOf(TRecordHeader);
      for I:=1 to FHeader.FieldCount do
         begin
         UpdateFieldSize(FFieldDefinitions[I]);
         UpdateFieldDecimals(FFieldDefinitions[I]);
         with FFieldDefinitions[I]^ do
            begin
            if (FieldName='') then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                     TableName);
            if (not IsAlpha(FieldName[1])) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            if (System.Length(FieldName) > MAX_FIELDNAME_SIZE) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            for J:=1 to FHeader.FieldCount do
               begin
               if (J <> I) and
                  (AnsiCompareText(Trim(FFieldDefinitions[J]^.FieldName),FieldName)=0) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName);
               end;
            for J:=1 to FHeader.FieldCount do
               begin
               if (J <> I) and
                  (FFieldDefinitions[J]^.FieldNum=FieldNum) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName);
               end;
            if (DataType=TYPE_UNKNOWN) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            if not (DataType in [TYPE_ZSTRING,TYPE_BYTES,TYPE_VARBYTES]) then
               begin
               if (Length <> 0) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName);
               end
            else
               begin
               if (SubType=SUBTYPE_UNICODE) then
                  begin
                  if (Length > (MAX_FIELD_SIZE div 2)) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                             TableName);
                  end
               else
                  begin
                  if (Length > MAX_FIELD_SIZE) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                             TableName);
                  end;
               end;
            if (not VerifyBasicExpression(Default,DataType)) or
               (not VerifyBasicExpression(Minimum,DataType)) or
               (not VerifyBasicExpression(Maximum,DataType)) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            if (DataType <> TYPE_BCD) and
               (Decimals <> 0) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            if (Offset <> TempRecordSize ) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            Inc(TempRecordSize,FLDCHG_DATA+DataSize);
            if (FieldNum <> I) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            end;
         end;
      TempRecordSize:=BlockOffset(TempRecordSize,CRYPTO_BLOCK_SIZE);
      if (FHeader.RecordLength <> TempRecordSize) then
         DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                 TableName);
      TotalSize:=GetSize;
      { Check to make sure that the records align properly }
      if (TotalSize > TempHeaderSize) then
         begin
         TempRecordHangSize:=((TotalSize-TempHeaderSize) mod FHeader.RecordLength);
         { If there is a discrepancy in the record alignment then
           issue an error }
         if (TempRecordHangSize <> 0) then
            DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                    TableName);
         end;
      { Check table header for incorrect record count }
      if (FHeader.NextEndingRecord <>
         (((TotalSize-TempHeaderSize) div FHeader.RecordLength)+1)) then
         DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                 TableName);
      { Check table header for incorrect free record pointer }
      if (FHeader.NextFreeRecord < 0) or
         (FHeader.NextFreeRecord > ((TotalSize-TempHeaderSize) div FHeader.RecordLength)) then
         DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                 TableName);
   except
      raise;
   end;
end;

function TDataFile.RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean;
var
   TempHeaderSize: Integer;
   TempRecordSize: Word;
   TempRecordHangSize: Integer;
   TempBlobFieldCount: Word;
   Buffer: array[1..1] of Char;
   I: Word;
   J: Word;
   CurFldName: string;
   CurFldNum: Word;
begin
   Result:=True;
   { Calculate the header size }
   TempHeaderSize:=(SizeOf(TDataHeader)+(SizeOf(TFieldDefinition)*FHeader.FieldCount));
   { Re-calculate the correct record length }
   TempRecordSize:=SizeOf(TRecordHeader);
   for I:=1 to FHeader.FieldCount do
      begin
      UpdateFieldSize(FFieldDefinitions[I]);
      UpdateFieldDecimals(FFieldDefinitions[I]);
      with FFieldDefinitions[I]^ do
         begin
         CurFldName:=AnsiUpperCase(FieldName);
         CurFldNum:=FieldNum;
         if (CurFldName='') then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field name (blank) for field # '+IntToStr(CurFldNum)+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field name (blank) for field # '+IntToStr(CurFldNum)+
                                ' in table header, error fixed');
               FieldName:='Repaired_Fld'+IntToStr(CurFldNum);
               end;
            Result:=False;
            end;
         if (not IsAlpha(CurFldName[1])) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field name (first character) for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field name (first character) for field '+FieldName+
                                ' in table header, error fixed');
               FieldName:='_'+Substr(FieldName,1,MAX_FIELDNAME_SIZE);
               end;
            Result:=False;
            end;
         if (System.Length(CurFldName) > MAX_FIELDNAME_SIZE) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field name (too long) for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field name (too long) for field '+FieldName+
                                ' in table header, error fixed');
               FieldName:=Substr(FieldName,1,MAX_FIELDNAME_SIZE);
               end;
            Result:=False;
            end;
         for J:=1 to FHeader.FieldCount do
            begin
            if (J <> I) and
               (AnsiCompareText(Trim(FFieldDefinitions[J]^.FieldName),CurFldName)=0) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid field name (duplicate) for field '+FieldName+
                                   ' in table header')
               else
                  begin
                  DataCursor.DoLog('Invalid field name (duplicate) for field '+FieldName+
                                   ' in table header, error fixed');
                  FieldName:=IntToStr(CurFldNum)+Substr(FieldName,1,MAX_FIELDNAME_SIZE);
                  end;
               Result:=False;
               end;
            end;
         if (DataType=TYPE_UNKNOWN) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field data type (Unknown) for field '+FieldName+
                                ' in table header')
            else
               DataCursor.DoLog('Invalid field data type (Unknown) for field '+FieldName+
                                ' in table header, error cannot be fixed');
            Result:=False;
            end;
         if not (DataType in [TYPE_ZSTRING,TYPE_BYTES,TYPE_VARBYTES]) then
            begin
            if (Length <> 0) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid field length for field '+FieldName+
                                   ' in table header')
               else
                  begin
                  DataCursor.DoLog('Invalid field length for field '+FieldName+
                                   ' in table header, error fixed');
                  Length:=0;
                  end;
               Result:=False;
               end;
            end
         else
            begin
            if (SubType=SUBTYPE_UNICODE) then
               begin
               if (Length > (MAX_FIELD_SIZE div 2)) then
                  begin
                  if VerifyOnly then
                     DataCursor.DoLog('Invalid field length for field '+FieldName+
                                      ' in table header ('+IntToStr(Length)+')')
                  else
                     begin
                     DataCursor.DoLog('Invalid field length for field '+FieldName+
                                      ' in table header ('+IntToStr(Length)+'), error fixed');
                     Length:=(MAX_FIELD_SIZE div 2);
                     UpdateFieldSize(FFieldDefinitions[I]);
                     end;
                  Result:=False;
                  end;
               end
            else
               begin
               if (Length > MAX_FIELD_SIZE) then
                  begin
                  if VerifyOnly then
                     DataCursor.DoLog('Invalid field length for field '+FieldName+
                                      ' in table header ('+IntToStr(Length)+')')
                  else
                     begin
                     DataCursor.DoLog('Invalid field length for field '+FieldName+
                                      ' in table header ('+IntToStr(Length)+'), error fixed');
                     Length:=MAX_FIELD_SIZE;
                     UpdateFieldSize(FFieldDefinitions[I]);
                     end;
                  Result:=False;
                  end;
               end;
            if (Length < 1) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid field length for field '+FieldName+
                                   ' in table header ('+IntToStr(Length)+')')
               else
                  DataCursor.DoLog('Invalid field length for field '+FieldName+
                                   ' in table header ('+IntToStr(Length)+'), error cannot be fixed');
               Result:=False;
               end;
            end;
         if (not VerifyBasicExpression(Default,DataType)) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid default value for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid default value for field '+FieldName+
                                ' in table header, error fixed');
               Default:='';
               end;
            Result:=False;
            end;
         if (not VerifyBasicExpression(Minimum,DataType)) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid minimum value for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid minimum value for field '+FieldName+
                                ' in table header, error fixed');
               Minimum:='';
               end;
            Result:=False;
            end;
         if (not VerifyBasicExpression(Maximum,DataType)) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid maximum value for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid maximum value for field '+FieldName+
                                ' in table header, error fixed');
               Maximum:='';
               end;
            Result:=False;
            end;
         if (DataType <> TYPE_BCD) and
            (Decimals <> 0) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field decimals for field '+FieldName+
                                ' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field decimals for field '+FieldName+
                                ' in table header, error fixed');
               Decimals:=0;
               end;
            Result:=False;
            end;
         if (Offset <> TempRecordSize ) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field offset for field '+
                                FieldName+' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field offset for field '+
                                FieldName+' in table header, error fixed');
               Offset:=TempRecordSize;
               end;
            Result:=False;
            end;
         Inc(TempRecordSize,FLDCHG_DATA+DataSize);
         if (FieldNum <> I) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid field number for field '+
                                FieldName+' in table header')
            else
               begin
               DataCursor.DoLog('Invalid field number for field '+
                                FieldName+' in table header, error fixed');
               FieldNum:=I;
               end;
            Result:=False;
            end;
         end;
      end;
   TempRecordSize:=BlockOffset(TempRecordSize,CRYPTO_BLOCK_SIZE);
   if (FHeader.RecordLength <> TempRecordSize) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Invalid physical record length in '+
                          'table header')
      else
         begin
         DataCursor.DoLog('Invalid physical record length in '+
                          'table header, error fixed');
         FHeader.RecordLength:=TempRecordSize;
         end;
      Result:=False;
      end;
   { Check to make sure that the records align properly }
   if (GetSize > TempHeaderSize) then
      begin
      TempRecordHangSize:=((GetSize-TempHeaderSize) mod FHeader.RecordLength);
      { If there is a discrepancy in the record alignment then
        truncate the file size to match (we cannot pad it because
        this act in itself may cause key violations,etc.) }
      if (TempRecordHangSize <> 0) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('Physical records not aligned on '+
                             'even record size boundaries')
         else
            begin
            DataCursor.DoLog('Physical records not aligned on '+
                             'even record size boundaries, error fixed');
            Seek(-TempRecordHangSize,FROM_EOF);
            Write(Buffer,0);
            if FDataTable.DataDirectory.DataSession.ForceBufferFlush then
               Flush;
            end;
         Result:=False;
         end;
      end;
   { Check table header for incorrect record count }
   if (FHeader.NextEndingRecord <>
      (((GetSize-TempHeaderSize) div FHeader.RecordLength)+1)) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Physical record count not correct')
      else
         begin
         DataCursor.DoLog('Physical record count not correct, '+
                          'error fixed');
         FHeader.NextEndingRecord:=(((GetSize-TempHeaderSize)
                                      div FHeader.RecordLength)+1);
         end;
      Result:=False;
      end;
   { Check table header for invalid free record pointer }
   if (FHeader.NextFreeRecord < 0) or
      (FHeader.NextFreeRecord > ((GetSize-TempHeaderSize) div FHeader.RecordLength)) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Invalid next free record pointer')
      else
         begin
         DataCursor.DoLog('Invalid next free record pointer, error fixed');
         FHeader.NextFreeRecord:=0;
         end;
      Result:=False;
      end;
   { Check the blob field count }
   TempBlobFieldCount:=0;
   for I:=1 to FHeader.FieldCount do
      begin
      if (FFieldDefinitions[I]^.DataType=TYPE_BLOB) then
         Inc(TempBlobFieldCount);
      end;
   if (TempBlobFieldCount <> FHeader.BlobFieldCount) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Invalid BLOB field count in table header')
      else
         begin
         DataCursor.DoLog('Invalid BLOB field count in table header, error fixed');
         FHeader.BlobFieldCount:=TempBlobFieldCount;
         end;
      Result:=False;
      end;
   { Be sure to reset the next free record pointer
     it will be rebuilt during the repair anyways }
   if (not VerifyOnly) then
      begin
      FHeader.VersionNum:=VERSION_NUMBER;
      FHeader.NextFreeRecord:=0;
      FHeader.IsDirty:=True;
      FFieldsAreDirty:=True;
      end;
end;

procedure TDataFile.IncRecordCount;
begin
   Inc(FHeader.RecordCount);
   FHeader.IsDirty:=True;
end;

procedure TDataFile.DecRecordCount;
begin
   Dec(FHeader.RecordCount);
   FHeader.IsDirty:=True;
end;

procedure TDataFile.SetRecordCount(Value: Integer);
begin
   if (Value <> FHeader.RecordCount) then
      begin
      FHeader.RecordCount:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TDataFile.GetRecordCount: Integer;
begin
   Result:=FHeader.RecordCount;
end;

function TDataFile.GetFieldCount: Word;
begin
   Result:=FHeader.FieldCount;
end;

function TDataFile.GetBlobFieldCount: Word;
begin
   Result:=FHeader.BlobFieldCount;
end;

function TDataFile.GetLastRecordID: Integer;
begin
   Result:=FHeader.LastRecordID;
end;

procedure TDataFile.SetLastRecordID(Value: Integer);
begin
   if (Value <> FHeader.LastRecordID) then
      begin
      FHeader.LastRecordID:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TDataFile.GetNextRecordID: Integer;
begin
   FHeader.LastRecordID:=WrapIncInteger(FHeader.LastRecordID);
   Result:=FHeader.LastRecordID;
   FHeader.IsDirty:=True;
end;

function TDataFile.GetLastAutoIncID: Integer;
begin
   Result:=FHeader.LastAutoIncID;
end;

procedure TDataFile.SetLastAutoIncID(Value: Integer);
begin
   if (Value <> FHeader.LastAutoIncID) then
      begin
      FHeader.LastAutoIncID:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TDataFile.GetLastBlobSignature: Integer;
begin
   Result:=FHeader.LastBlobSignature;
end;

procedure TDataFile.SetLastBlobSignature(Value: Integer);
begin
   if (Value <> FHeader.LastBlobSignature) then
      begin
      FHeader.LastBlobSignature:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TDataFile.GetNextBlobSignature: Integer;
begin
   FHeader.LastBlobSignature:=WrapIncInteger(FHeader.LastBlobSignature);
   Result:=FHeader.LastBlobSignature;
   FHeader.IsDirty:=True;
end;

function TDataFile.GetBlobBlockSize: Integer;
begin
   Result:=FHeader.BlobBlockSize;
end;

function TDataFile.GetIndexPageSize: Integer;
begin
   Result:=FHeader.IndexPageSize;
end;

function TDataFile.GetLocaleID: Integer;
begin
   Result:=FHeader.LocaleID;
end;

function TDataFile.GetUserMajorVersion: Word;
begin
   Result:=FHeader.UserMajorVersion;
end;

function TDataFile.GetUserMinorVersion: Word;
begin
   Result:=FHeader.UserMinorVersion;
end;

function TDataFile.GetVersionNum: Byte;
begin
   Result:=FHeader.VersionNum;
end;

function TDataFile.GetFieldDefinitionByPos(FieldIndex: Word): pFieldDefinition;
begin
   if (FieldIndex=RECORDID_FIELD_NUM) then
      Result:=@FRecordIDField
   else if (FieldIndex=RECORDHASH_FIELD_NUM) then
      Result:=@FRecordHashField
   else
      Result:=FFieldDefinitions[FieldIndex];
end;

function TDataFile.GetFieldDefinitionByNumber(FieldNum: Word): pFieldDefinition;
var
   I: Word;
begin
   if (FieldNum=RECORDID_FIELD_NUM) then
      Result:=@FRecordIDField
   else if (FieldNum=RECORDHASH_FIELD_NUM) then
      Result:=@FRecordHashField
   else
      begin
      Result:=nil;
      for I:=1 to FHeader.FieldCount do
         begin
         if (FFieldDefinitions[I]^.FieldNum=FieldNum) then
            begin
            Result:=FFieldDefinitions[I];
            Result^.FieldPos:=I;
            Exit;
            end;
         end;
      end;
end;

function TDataFile.GetFieldDefinitionByName(NameOfField: string): pFieldDefinition;
var
   I: Word;
begin
   if (AnsiCompareText(NameOfField,RECORDID_FIELD_NAME)=0) then
      Result:=@FRecordIDField
   else if (AnsiCompareText(NameOfField,RECORDHASH_FIELD_NAME)=0) then
      Result:=@FRecordHashField
   else
      begin
      Result:=nil;
      for I:=1 to FHeader.FieldCount do
         begin
         if (AnsiCompareText(FFieldDefinitions[I]^.FieldName,NameOfField)=0) then
            begin
            Result:=FFieldDefinitions[I];
            Result^.FieldPos:=I;
            Exit;
            end;
         end;
      end;
end;

function TDataFile.GetFieldNumber(NameOfField: string): Word;
var
   I: Word;
begin
   Result:=0;
   if (AnsiCompareText(NameOfField,RECORDID_FIELD_NAME)=0) then
      Result:=RECORDID_FIELD_NUM
   else if (AnsiCompareText(NameOfField,RECORDHASH_FIELD_NAME)=0) then
      Result:=RECORDHASH_FIELD_NUM
   else
      begin
      for I:=1 to FHeader.FieldCount do
         begin
         if (AnsiCompareText(FFieldDefinitions[I]^.FieldName,NameOfField)=0) then
            begin
            Result:=I;
            Exit;
            end;
         end;
      end;
end;

procedure TDataFile.UpdateFieldDefinitionByPos(FieldIndex: Word;
                                               Buffer: pFieldDefinition);
begin
   with FFieldDefinitions[FieldIndex]^ do
      begin
      FieldNum:=Buffer^.FieldNum;
      FieldName:=Buffer^.FieldName;
      SubType:=Buffer^.SubType;
      Description:=Buffer^.Description;
      Required:=Buffer^.Required;
      Minimum:=Buffer^.Minimum;
      Maximum:=Buffer^.Maximum;
      Default:=Buffer^.Default;
      end;
   FFieldsAreDirty:=True;
end;

function TDataFile.GetDescription: string;
begin
   Result:=FHeader.Description;
end;

function TDataFile.GetLastUpdated: TDateTime;
begin
   Result:=(FHeader.LastUpdated+DateDelta);
end;

function TDataFile.GetEncrypted: Boolean;
begin
   Result:=FHeader.Encrypted;
end;

procedure TDataFile.UpdateHeader(NewLocaleID: Integer;
                                 NewUserMajorVersion: Word; NewUserMinorVersion: Word;
                                 NewEncrypted: Boolean; NewDigest: TMD5Digest;
                                 const NewDescription: string;
                                 NewIndexPageSize: Integer;
                                 NewBlobBlockSize: Integer;
                                 NewLastAutoIncID: Integer);
begin
   with FHeader do
      begin
      LocaleID:=NewLocaleID;
      UserMajorVersion:=NewUserMajorVersion;
      UserMinorVersion:=NewUserMinorVersion;
      Encrypted:=NewEncrypted;
      Digest:=NewDigest;
      Description:=NewDescription;
      IndexPageSize:=NewIndexPageSize;
      BlobBlockSize:=NewBlobBlockSize;
      LastAutoIncID:=NewLastAutoIncID;
      IsDirty:=True;
      end;
end;

{ TPage }

function TPage.GetPageType: Byte;
begin
   Result:=FHeader.PageType;
end;

procedure TPage.SetPageType(Value: Byte);
begin
   if (Value <> FHeader.PageType) then
      begin
      FIsDirty:=True;
      FHeader.PageType:=Value;
      end;
end;

function TPage.GetCompressedSize: Word;
begin
   Result:=FHeader.CompressedSize;
end;

function TPage.GetNumberOfKeys: Word;
begin
   Result:=FHeader.NumberOfKeys;
end;

procedure TPage.SetNumberOfKeys(Value: Word);
begin
   if (Value <> FHeader.NumberOfKeys) then
      begin
      FIsDirty:=True;
      FHeader.NumberOfKeys:=Value;
      Size:=(FHeader.NumberOfKeys*(FKeySize+KEY_DATA));
      end;
end;

function TPage.GetLeftNumber: Integer;
begin
   Result:=FHeader.LeftNumber;
end;

procedure TPage.SetLeftNumber(Value: Integer);
begin
   if (Value <> FHeader.LeftNumber) then
      begin
      FIsDirty:=True;
      FHeader.LeftNumber:=Value;
      end;
end;

function TPage.GetRightNumber: Integer;
begin
   Result:=FHeader.RightNumber;
end;

procedure TPage.SetRightNumber(Value: Integer);
begin
   if (Value <> FHeader.RightNumber) then
      begin
      FIsDirty:=True;
      FHeader.RightNumber:=Value;
      end;
end;

procedure TPage.Copy(BufferToCopy: TBuffer);
begin
   Size:=TPage(BufferToCopy).FSize;
   inherited;
   Move(TPage(BufferToCopy).FHeader,FHeader,SizeOf(TPageHeader));
   FKeySize:=TPage(BufferToCopy).FKeySize;
   FKeyUnique:=TPage(BufferToCopy).FKeyUnique;
   FNoKeyStatistics:=TPage(BufferToCopy).FNoKeyStatistics;
   FKeyCompressionType:=TPage(BufferToCopy).FKeyCompressionType;
end;

procedure TPage.Initialize(DefinitionPos: Byte=0);
begin
   inherited;
   FillChar(FHeader,SizeOf(TPageHeader),#0);
   if (DefinitionPos <> NULL_INDEX_POS) and
      (DefinitionPos <> PHYSICAL_INDEX_POS) then
      begin
      with FBufferedFile.DataTable.GetIndexDefinition(DefinitionPos)^ do
         begin
         FKeySize:=KeySize;
         FKeyUnique:=KeyUnique;
         FNoKeyStatistics:=NoKeyStatistics;
         FKeyCompressionType:=KeyCompressionType;
         end;
      end
   else
      begin
      FKeySize:=0;
      FKeyUnique:=False;
      FNoKeyStatistics:=False;
      FKeyCompressionType:=NO_COMPRESS;
      end;
end;

procedure TPage.Read(ReadBuffer: PChar);
begin
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Decrypt(ReadBuffer,FBufferedFile.IOBlockSize);
   Move(ReadBuffer^,FHeader,SizeOf(TPageHeader));
   Size:=(FHeader.NumberOfKeys*(FKeySize+KEY_DATA));
   UncompressPageData((ReadBuffer+SizeOf(TPageHeader)));
   FIsDirty:=False;
end;

procedure TPage.Write(WriteBuffer: PChar);
begin
   Move(FHeader,WriteBuffer^,SizeOf(TPageHeader));
   CompressPageData((WriteBuffer+SizeOf(TPageHeader)));
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Encrypt(WriteBuffer,FBufferedFile.IOBlockSize);
   FIsDirty:=False;
end;

procedure TPage.AllocateBuffer;
begin
   Size:=FBufferedFile.BufferSize;
end;

procedure TPage.CompressPageData(PageBuffer: PChar);
var
   TempBufferPtr: PChar;
   I: Word;
   TempPos: Word;
   DuplicateCount: Byte;
   TrailCount: Byte;
   KeyCountSize: Byte;
begin
   if (FHeader.NumberOfKeys=0) and (FHeader.PageType <> DATA_NODE) then
      Exit;
   if (FHeader.PageType > INTERNAL_NODE) then
      begin
      if (FHeader.PageType <> DATA_NODE) then
         begin
         if (FKeyCompressionType > NO_COMPRESS) then
            begin
            case FKeyCompressionType of
               DUPBYTE_COMPRESS:
                  begin
                  TempPos:=0;
                  TempBufferPtr:=FBuffer;
                  for I:=1 to FHeader.NumberOfKeys do
                     begin
                     { Get duplicate count information and put into page buffer }
                     DuplicateCount:=Byte((TempBufferPtr+FKeySize+
                                            RECORD_SIZE+KEYCOUNT_SIZE)^);
                     Byte((PageBuffer+TempPos)^):=DuplicateCount;
                     { Move actual key buffer into page buffer }
                     Move((TempBufferPtr+DuplicateCount)^,
                          (PageBuffer+TempPos+DUPBYTE_SIZE)^,
                          ((FKeySize+RECORD_SIZE)-DuplicateCount));
                     Inc(TempPos,DUPBYTE_SIZE+
                         ((FKeySize+RECORD_SIZE)-DuplicateCount));
                     { Move to the next key }
                     Inc(TempBufferPtr,(FKeySize+KEY_DATA));
                     end;
                  end;
               TRAILBYTE_COMPRESS:
                  begin
                  TempPos:=0;
                  TempBufferPtr:=FBuffer;
                  for I:=1 to FHeader.NumberOfKeys do
                     begin
                     { Get trailing count information and put into page buffer }
                     TrailCount:=Byte((TempBufferPtr+FKeySize+
                                       RECORD_SIZE+KEYCOUNT_SIZE+DUPBYTE_SIZE)^);
                     Byte((PageBuffer+TempPos)^):=TrailCount;
                     if FKeyUnique then
                        begin
                        { Move actual key buffer into page buffer }
                        Move(TempBufferPtr^,
                             (PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                             (FKeySize-TrailCount));
                        Inc(TempPos,(FKeySize-TrailCount));
                        end
                     else
                        begin
                        { Move actual key buffer into page buffer }
                        Move(TempBufferPtr^,
                             (PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                             (FKeySize-TrailCount-RECORDID_SIZE));
                        Inc(TempPos,(FKeySize-TrailCount-RECORDID_SIZE));
                        Move((TempBufferPtr+(FKeySize-RECORDID_SIZE))^,
                             (PageBuffer+TempPos+TRAILBYTE_SIZE)^,RECORDID_SIZE);
                        Inc(TempPos,RECORDID_SIZE);
                        end;
                     Inc(TempBufferPtr,FKeySize);
                     Move(TempBufferPtr^,
                          (PageBuffer+TempPos+TRAILBYTE_SIZE)^,RECORD_SIZE);
                     Inc(TempPos,(TRAILBYTE_SIZE+RECORD_SIZE));
                     { Move to the next key }
                     Inc(TempBufferPtr,KEY_DATA);
                     end;
                  end;
               BOTH_COMPRESS:
                  begin
                  TempPos:=0;
                  TempBufferPtr:=FBuffer;
                  for I:=1 to FHeader.NumberOfKeys do
                     begin
                     { Get duplicate count information and put into page buffer }
                     DuplicateCount:=Byte((TempBufferPtr+FKeySize+
                                            RECORD_SIZE+KEYCOUNT_SIZE)^);
                     Byte((PageBuffer+TempPos)^):=DuplicateCount;
                     Inc(TempPos);
                     { Get trailing count information and put into page buffer }
                     TrailCount:=Byte((TempBufferPtr+FKeySize+
                                        RECORD_SIZE+KEYCOUNT_SIZE+DUPBYTE_SIZE)^);
                     Byte((PageBuffer+TempPos)^):=TrailCount;
                     Inc(TempPos);
                     if FKeyUnique then
                        begin
                        { Move actual key buffer into page buffer }
                        Move((TempBufferPtr+DuplicateCount)^,
                             (PageBuffer+TempPos)^,
                             (FKeySize-TrailCount-DuplicateCount));
                        Inc(TempPos,(FKeySize-TrailCount-DuplicateCount));
                        end
                     else
                        begin
                        { Move actual key buffer into page buffer }
                        if ((FKeySize-DuplicateCount) > RECORDID_SIZE) then
                           begin
                           Move((TempBufferPtr+DuplicateCount)^,
                                (PageBuffer+TempPos)^,
                                (FKeySize-TrailCount-DuplicateCount-RECORDID_SIZE));
                           Inc(TempPos,(FKeySize-TrailCount-DuplicateCount-RECORDID_SIZE));
                           Move((TempBufferPtr+(FKeySize-RECORDID_SIZE))^,
                                (PageBuffer+TempPos)^,RECORDID_SIZE);
                           Inc(TempPos,RECORDID_SIZE);
                           end
                        else
                           begin
                           { Move actual key buffer into page buffer }
                           Move((TempBufferPtr+DuplicateCount)^,
                                (PageBuffer+TempPos)^,
                                (FKeySize-TrailCount-DuplicateCount));
                           Inc(TempPos,(FKeySize-TrailCount-DuplicateCount));
                           end;
                        end;
                     Inc(TempBufferPtr,FKeySize);
                     Move(TempBufferPtr^,
                          (PageBuffer+TempPos)^,RECORD_SIZE);
                     Inc(TempPos,RECORD_SIZE);
                     { Move to the next key }
                     Inc(TempBufferPtr,KEY_DATA);
                     end;
                  end;
               end;
            end
         else
            begin
            TempPos:=0;
            TempBufferPtr:=FBuffer;
            for I:=1 to FHeader.NumberOfKeys do
               begin
               { Move actual key buffer into page buffer }
               Move(TempBufferPtr^,(PageBuffer+TempPos)^,
                                     (FKeySize+RECORD_SIZE));
               Inc(TempPos,(FKeySize+RECORD_SIZE));
               { Move to the next key }
               Inc(TempBufferPtr,(FKeySize+KEY_DATA));
               end;
            end;
         end
      else
         Move(FBuffer^,PageBuffer^,FBufferedFile.BufferSize);
      end
   else
      begin
      TempPos:=0;
      TempBufferPtr:=FBuffer;
      if FNoKeyStatistics then
         KeyCountSize:=0
      else
         KeyCountSize:=KEYCOUNT_SIZE;
      for I:=1 to FHeader.NumberOfKeys do
         begin
         { Move actual key buffer into page buffer }
         Move(TempBufferPtr^,(PageBuffer+TempPos)^,(FKeySize+
                                RECORD_SIZE+KeyCountSize));
         Inc(TempPos,(FKeySize+RECORD_SIZE+KeyCountSize));
         Inc(TempBufferPtr,(FKeySize+KEY_DATA));
         end;
      end;
end;

function TPage.CalculateDuplicateByteCount(PriorKeyCounter: Integer;
                                           KeyCounter: Integer): Byte;
begin
   if (PriorKeyCounter=0) then
      Result:=0
   else
      Result:=GetDuplicateCount((FBuffer+((PriorKeyCounter-1)*(FKeySize+KEY_DATA))),
                                (FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA))),FKeySize);
end;

function TPage.CalculateTrailingByteCount(KeyCounter: Integer;
                                          DuplicateCount: Byte): Byte;
begin
   if FKeyUnique then
      Result:=GetTrailingCount((((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
                                  FKeySize)-1),(FKeySize-DuplicateCount))
   else
      begin
      if ((FKeySize-DuplicateCount) > RECORDID_SIZE) then
         Result:=GetTrailingCount((((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
                                     FKeySize-RECORDID_SIZE)-1),(FKeySize-DuplicateCount-RECORDID_SIZE))
      else
         Result:=0;
      end;
end;

function TPage.GetDuplicateByteCount(KeyCounter: Integer): Byte;
begin
   Result:=Byte(((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
                   FKeySize+RECORD_SIZE+KEYCOUNT_SIZE)^);
end;

procedure TPage.SetDuplicateByteCount(KeyCounter: Integer; Value: Byte);
begin
   Byte(((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
          FKeySize+RECORD_SIZE+KEYCOUNT_SIZE)^):=Value;
end;

function TPage.GetTrailingByteCount(KeyCounter: Integer): Byte;
begin
   Result:=Byte(((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
                   FKeySize+RECORD_SIZE+KEYCOUNT_SIZE+DUPBYTE_SIZE)^);
end;

procedure TPage.SetTrailingByteCount(KeyCounter: Integer; Value: Byte);
begin
   Byte(((FBuffer+((KeyCounter-1)*(FKeySize+KEY_DATA)))+
          FKeySize+RECORD_SIZE+KEYCOUNT_SIZE+DUPBYTE_SIZE)^):=Value;
end;

procedure TPage.CalculateCompressedSize(KeyCounter: Integer; Inserted: Boolean);
var
   TrailCount: Byte;
   DuplicateCount: Byte;
begin
   if (FHeader.PageType > INTERNAL_NODE) and (FKeyCompressionType > NO_COMPRESS) then
      begin
      if Inserted then
         begin
         case FKeyCompressionType of
            DUPBYTE_COMPRESS:
               begin
               { Calculate the duplicate count for the new key first }
               DuplicateCount:=CalculateDuplicateByteCount((KeyCounter-1),KeyCounter);
               SetDuplicateByteCount(KeyCounter,DuplicateCount);
               Inc(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
               { Now calculate it for the next key (if present), and be sure
                 to subtract the existing duplicate byte count before adding in
                 the new count }
               if (KeyCounter < FHeader.NumberOfKeys) then
                  begin
                  DuplicateCount:=GetDuplicateByteCount(KeyCounter+1);
                  Dec(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
                  DuplicateCount:=CalculateDuplicateByteCount(KeyCounter,(KeyCounter+1));
                  SetDuplicateByteCount((KeyCounter+1),DuplicateCount);
                  Inc(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
                  end;
               end;
            TRAILBYTE_COMPRESS:
               begin
               { Calculate trailing count }
               TrailCount:=CalculateTrailingByteCount(KeyCounter,0);
               SetTrailingByteCount(KeyCounter,TrailCount);
               Inc(FHeader.CompressedSize,(TRAILBYTE_SIZE+(FKeySize-TrailCount)+RECORD_SIZE));
               end;
            BOTH_COMPRESS:
               begin
               { Calculate the duplicate count and trailing count for the new key first }
               DuplicateCount:=CalculateDuplicateByteCount((KeyCounter-1),KeyCounter);
               SetDuplicateByteCount(KeyCounter,DuplicateCount);
               TrailCount:=CalculateTrailingByteCount(KeyCounter,DuplicateCount);
               SetTrailingByteCount(KeyCounter,TrailCount);
               Inc(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
               { Now calculate for the next key (if present), and be sure
                 to subtract the existing duplicate count and trailing count
                 before adding in the new counts }
               if (KeyCounter < FHeader.NumberOfKeys) then
                  begin
                  DuplicateCount:=GetDuplicateByteCount(KeyCounter+1);
                  TrailCount:=GetTrailingByteCount(KeyCounter+1);
                  Dec(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
                  DuplicateCount:=CalculateDuplicateByteCount(KeyCounter,(KeyCounter+1));
                  SetDuplicateByteCount((KeyCounter+1),DuplicateCount);
                  TrailCount:=CalculateTrailingByteCount((KeyCounter+1),DuplicateCount);
                  SetTrailingByteCount((KeyCounter+1),TrailCount);
                  Inc(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
                  end;
               end;
            end;
         end
      else
         begin
         case FKeyCompressionType of
            DUPBYTE_COMPRESS:
               begin
               { Remove the compressed size of the key that is
                 being deleted }
               DuplicateCount:=GetDuplicateByteCount(KeyCounter);
               Dec(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
               { Now calculate it for the next key (if present), and be sure
                 to subtract the existing duplicate byte count before adding in
                 the new count }
               if (KeyCounter < FHeader.NumberOfKeys) then
                  begin
                  DuplicateCount:=GetDuplicateByteCount(KeyCounter+1);
                  Dec(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
                  DuplicateCount:=CalculateDuplicateByteCount((KeyCounter-1),(KeyCounter+1));
                  SetDuplicateByteCount((KeyCounter+1),DuplicateCount);
                  Inc(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-DuplicateCount)+RECORD_SIZE));
                  end;
               end;
            TRAILBYTE_COMPRESS:
               begin
               { Calculate trailing count }
               TrailCount:=GetTrailingByteCount(KeyCounter);
               Dec(FHeader.CompressedSize,(TRAILBYTE_SIZE+(FKeySize-TrailCount)+RECORD_SIZE));
               end;
            BOTH_COMPRESS:
               begin
               { Remove the compressed size of the key that is
                 being deleted }
               DuplicateCount:=GetDuplicateByteCount(KeyCounter);
               TrailCount:=GetTrailingByteCount(KeyCounter);
               Dec(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
               { Now calculate it for the next key (if present), and be sure
                 to subtract the existing duplicate byte count before adding in
                 the new count }
               if (KeyCounter < FHeader.NumberOfKeys) then
                  begin
                  DuplicateCount:=GetDuplicateByteCount(KeyCounter+1);
                  TrailCount:=GetTrailingByteCount(KeyCounter+1);
                  Dec(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
                  DuplicateCount:=CalculateDuplicateByteCount((KeyCounter-1),(KeyCounter+1));
                  SetDuplicateByteCount((KeyCounter+1),DuplicateCount);
                  TrailCount:=CalculateTrailingByteCount((KeyCounter+1),DuplicateCount);
                  SetTrailingByteCount((KeyCounter+1),TrailCount);
                  Inc(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-TrailCount-DuplicateCount)+RECORD_SIZE));
                  end;
               end;
            end;
         end;
      end
   else
      FHeader.CompressedSize:=0;
end;

procedure TPage.RecalculateTotalCompressedSize;
var
   I: Word;
   BufferPtr: PChar;
begin
   FHeader.CompressedSize:=0;
   BufferPtr:=(FBuffer+FKeySize+RECORD_SIZE+KEYCOUNT_SIZE);
   case FKeyCompressionType of
      DUPBYTE_COMPRESS:
         begin
         for I:=1 to FHeader.NumberOfKeys do
            begin
            Inc(FHeader.CompressedSize,(DUPBYTE_SIZE+(FKeySize-
                Byte(BufferPtr^))+RECORD_SIZE));
            Inc(BufferPtr,(FKeySize+KEY_DATA));
            end;
         end;
      TRAILBYTE_COMPRESS:
         begin
         for I:=1 to FHeader.NumberOfKeys do
            begin
            Inc(FHeader.CompressedSize,(TRAILBYTE_SIZE+(FKeySize-
                Byte((BufferPtr+DUPBYTE_SIZE)^))+RECORD_SIZE));
            Inc(BufferPtr,(FKeySize+KEY_DATA));
            end;
         end;
      BOTH_COMPRESS:
         begin
         for I:=1 to FHeader.NumberOfKeys do
            begin
            Inc(FHeader.CompressedSize,(BOTH_SIZE+(FKeySize-
                Byte(BufferPtr^)-Byte((BufferPtr+DUPBYTE_SIZE)^))+RECORD_SIZE));
            Inc(BufferPtr,(FKeySize+KEY_DATA));
            end;
         end;
      end;
end;

procedure TPage.UnCompressPageData(PageBuffer: PChar);
var
   TempBufferPtr: PChar;
   CompareBufferPtr: PChar;
   I: Word;
   DuplicateCount: Byte;
   TrailCount: Byte;
   TempPos: Word;
   KeyCountSize: Byte;
begin
   if (FHeader.NumberOfKeys=0) and (FHeader.PageType <> DATA_NODE) then
      Exit;
   if (FHeader.PageType > INTERNAL_NODE) then
      begin
      if (FHeader.PageType <> DATA_NODE) then
         begin
         if (FKeyCompressionType > NO_COMPRESS) then
            begin
            case FKeyCompressionType of
               DUPBYTE_COMPRESS:
                  begin
                  TempPos:=0;
                  TempBufferPtr:=(FBuffer+(FKeySize+KEY_DATA));
                  CompareBufferPtr:=FBuffer;
                  Move((PageBuffer+DUPBYTE_SIZE)^,CompareBufferPtr^,(FKeySize+RECORD_SIZE));
                  Byte((CompareBufferPtr+FKeySize+RECORD_SIZE+KEYCOUNT_SIZE)^):=0;
                  Inc(TempPos,DUPBYTE_SIZE+(FKeySize+RECORD_SIZE));
                  for I:=2 to FHeader.NumberOfKeys do
                     begin
                     { Extract duplicate count and add duplicate bytes to front
                       of buffer }
                     DuplicateCount:=Byte((PageBuffer+TempPos)^);
                     Move(CompareBufferPtr^,TempBufferPtr^,DuplicateCount);
                     { Extract rest of compressed key }
                     Move((PageBuffer+TempPos+DUPBYTE_SIZE)^,
                          (TempBufferPtr+DuplicateCount)^,
                          ((FKeySize+RECORD_SIZE)-DuplicateCount));
                     { Put duplicate count in uncompressed buffer }
                     Byte((TempBufferPtr+FKeySize+RECORD_SIZE+KEYCOUNT_SIZE)^):=DuplicateCount;
                     Inc(TempPos,DUPBYTE_SIZE+((FKeySize+RECORD_SIZE)-DuplicateCount));
                     Inc(TempBufferPtr,(FKeySize+KEY_DATA));
                     Inc(CompareBufferPtr,(FKeySize+KEY_DATA));
                     end;
                  end;
               TRAILBYTE_COMPRESS:
                  begin
                  TempPos:=0;
                  CompareBufferPtr:=FBuffer;
                  for I:=1 to FHeader.NumberOfKeys do
                     begin
                     { Extract trailing count and add trailing bytes to end
                       of buffer }
                     TrailCount:=Byte((PageBuffer+TempPos)^);
                     if FKeyUnique then
                        begin
                        { Extract first part of compressed key }
                        Move((PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                             CompareBufferPtr^,(FKeySize-TrailCount));
                        FillTrail((CompareBufferPtr+(FKeySize-TrailCount)),TrailCount);
                        Inc(TempPos,(FKeySize-TrailCount));
                        end
                     else
                        begin
                        { Extract first part of compressed key }
                        Move((PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                             CompareBufferPtr^,(FKeySize-TrailCount-RECORDID_SIZE));
                        FillTrail((CompareBufferPtr+(FKeySize-TrailCount-RECORDID_SIZE)),TrailCount);
                        Inc(TempPos,(FKeySize-TrailCount-RECORDID_SIZE));
                        Move((PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                             (CompareBufferPtr+(FKeySize-RECORDID_SIZE))^,
                             RECORDID_SIZE);
                        Inc(TempPos,RECORDID_SIZE);
                        end;
                     { Put trailing count in uncompressed buffer }
                     Byte((CompareBufferPtr+FKeySize+RECORD_SIZE+
                                          KEYCOUNT_SIZE+DUPBYTE_SIZE)^):=TrailCount;
                     { Extract record number part of compressed key }
                     Move((PageBuffer+TempPos+TRAILBYTE_SIZE)^,
                          (CompareBufferPtr+FKeySize)^,RECORD_SIZE);
                     Inc(CompareBufferPtr,(FKeySize+KEY_DATA));
                     Inc(TempPos,(TRAILBYTE_SIZE+RECORD_SIZE));
                     end;
                  end;
               BOTH_COMPRESS:
                  begin
                  TempPos:=0;
                  TempBufferPtr:=FBuffer;
                  CompareBufferPtr:=(FBuffer-(FKeySize+KEY_DATA));
                  for I:=1 to FHeader.NumberOfKeys do
                     begin
                     { Extract duplicate count }
                     if (I > 1) then
                        begin
                        DuplicateCount:=Byte((PageBuffer+TempPos)^);
                        { Extract first part of compressed key }
                        Move(CompareBufferPtr^,TempBufferPtr^,DuplicateCount);
                        end
                     else
                        DuplicateCount:=0;
                     Inc(TempPos);
                     { Extract trailing count }
                     TrailCount:=Byte((PageBuffer+TempPos)^);
                     Inc(TempPos);
                     if FKeyUnique then
                        begin
                        { Extract last part of compressed key }
                        Move((PageBuffer+TempPos)^,
                             (TempBufferPtr+DuplicateCount)^,
                             (FKeySize-DuplicateCount-TrailCount));
                        FillTrail((TempBufferPtr+(FKeySize-TrailCount)),
                                  TrailCount);
                        Inc(TempPos,(FKeySize-DuplicateCount-TrailCount));
                        end
                     else
                        begin
                        if ((FKeySize-DuplicateCount) > RECORDID_SIZE) then
                           begin
                           { Extract last part of compressed key }
                           Move((PageBuffer+TempPos)^,
                                (TempBufferPtr+DuplicateCount)^,
                                (FKeySize-DuplicateCount-TrailCount-RECORDID_SIZE));
                           FillTrail((TempBufferPtr+(FKeySize-TrailCount-RECORDID_SIZE)),
                                      TrailCount);
                           Inc(TempPos,(FKeySize-DuplicateCount-TrailCount-RECORDID_SIZE));
                           Move((PageBuffer+TempPos)^,
                                (TempBufferPtr+(FKeySize-RECORDID_SIZE))^,
                                RECORDID_SIZE);
                           Inc(TempPos,RECORDID_SIZE);
                           end
                        else
                           begin
                           { Extract last part of compressed key }
                           Move((PageBuffer+TempPos)^,
                                (TempBufferPtr+DuplicateCount)^,
                                (FKeySize-DuplicateCount-TrailCount));
                           FillTrail((TempBufferPtr+(FKeySize-TrailCount)),
                                     TrailCount);
                           Inc(TempPos,(FKeySize-DuplicateCount-TrailCount));
                           end;
                        end;
                     { Put duplicate count in uncompressed buffer }
                     Byte((TempBufferPtr+FKeySize+RECORD_SIZE+KEYCOUNT_SIZE)^):=DuplicateCount;
                     { Put trailing count in uncompressed buffer }
                     Byte((TempBufferPtr+FKeySize+RECORD_SIZE+
                                          KEYCOUNT_SIZE+DUPBYTE_SIZE)^):=TrailCount;
                     { Extract record number part of compressed key }
                     Move((PageBuffer+TempPos)^,
                          (TempBufferPtr+FKeySize)^,RECORD_SIZE);
                     Inc(TempPos,RECORD_SIZE);
                     Inc(CompareBufferPtr,(FKeySize+KEY_DATA));
                     Inc(TempBufferPtr,(FKeySize+KEY_DATA));
                     end;
                  end;
               end;
            end
         else
            begin
            TempPos:=0;
            TempBufferPtr:=FBuffer;
            for I:=1 to FHeader.NumberOfKeys do
               begin
               { Move actual key buffer into page buffer }
               Move((PageBuffer+TempPos)^,TempBufferPtr^,(FKeySize+RECORD_SIZE));
               Inc(TempPos,(FKeySize+RECORD_SIZE));
               Inc(TempBufferPtr,(FKeySize+KEY_DATA));
               end;
            end;
         end
      else
         begin
         AllocateBuffer;
         Move(PageBuffer^,FBuffer^,FBufferedFile.BufferSize);
         end;
      end
   else
      begin
      TempPos:=0;
      TempBufferPtr:=FBuffer;
      if FNoKeyStatistics then
         KeyCountSize:=0
      else
         KeyCountSize:=KEYCOUNT_SIZE;
      for I:=1 to FHeader.NumberOfKeys do
         begin
         { Move actual key buffer into page buffer }
         Move((PageBuffer+TempPos)^,TempBufferPtr^,
              (FKeySize+RECORD_SIZE+KeyCountSize));
         Inc(TempPos,(FKeySize+RECORD_SIZE+KeyCountSize));
         Inc(TempBufferPtr,(FKeySize+KEY_DATA));
         end;
      end;
end;

function TPage.GetRecordNumber(KeyCounter: Integer): Integer;
begin
   if (FHeader.NumberOfKeys > 0) then
      Result:=pInteger((FBuffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize)))^
   else
      Result:=0;
end;

procedure TPage.SetRecordNumber(KeyCounter: Integer; Value: Integer);
begin
   if (FHeader.NumberOfKeys > 0) then
      begin
      pInteger((FBuffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize)))^:=Value;
      FIsDirty:=True;
      end;
end;

function TPage.GetKey(KeyCounter: Integer): PChar;
begin
   Result:=(FBuffer+((FKeySize+KEY_DATA)*(KeyCounter-1)))
end;

procedure TPage.InsertKey(NewBuffer: PChar; var KeyCounter: Integer);
begin
   FIsDirty:=True;
   Inc(FHeader.NumberOfKeys);
   Size:=(FHeader.NumberOfKeys*(FKeySize+KEY_DATA));
   Move((FBuffer+(((FKeySize+KEY_DATA)*KeyCounter)))^,
        (FBuffer+(((FKeySize+KEY_DATA)*(KeyCounter+1))))^,
        ((FHeader.NumberOfKeys-1-KeyCounter)*(FKeySize+KEY_DATA)));
   Move(NewBuffer^,(FBuffer+(((FKeySize+KEY_DATA)*KeyCounter)))^,FKeySize);
   Inc(KeyCounter);
end;

procedure TPage.UpdateKey(NewBuffer: PChar; KeyCounter: Integer);
begin
   FIsDirty:=True;
   Move(NewBuffer^,(FBuffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))))^,FKeySize);
end;

procedure TPage.DeleteKey(var KeyCounter: Integer);
begin
   FIsDirty:=True;
   Move((FBuffer+(((FKeySize+KEY_DATA)*KeyCounter)))^,
        (FBuffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))))^,
        ((FHeader.NumberOfKeys-KeyCounter)*(FKeySize+KEY_DATA)));
   Dec(FHeader.NumberOfKeys);
   Size:=(FHeader.NumberOfKeys*(FKeySize+KEY_DATA));
   if (KeyCounter > FHeader.NumberOfKeys) then
      KeyCounter:=FHeader.NumberOfKeys;
end;

function TPage.GetLowerKeyCount(KeyCounter: Integer): Integer;
begin
   if (FHeader.PageType < EXTERNAL_NODE) then
      begin
      if (FHeader.NumberOfKeys > 0) then
         Result:=pInteger((Buffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize+RECORD_SIZE)))^
      else
         Result:=0;
      end
   else
      Result:=1;
end;

procedure TPage.SetLowerKeyCount(KeyCounter: Integer; Value: Integer);
begin
   if (FHeader.PageType < EXTERNAL_NODE) and (not FNoKeyStatistics) then
      begin
      if (FHeader.NumberOfKeys > 0) then
         begin
         pInteger((Buffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize+RECORD_SIZE)))^:=Value;
         FIsDirty:=True;
         end;
      end;
end;

procedure TPage.IncLowerKeyCount(KeyCounter: Integer);
begin
   if (FHeader.PageType < EXTERNAL_NODE) and (not FNoKeyStatistics) then
      begin
      if (FHeader.NumberOfKeys > 0) then
         begin
         Inc(pInteger((Buffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize+RECORD_SIZE)))^);
         FIsDirty:=True;
         end;
      end;
end;

procedure TPage.DecLowerKeyCount(KeyCounter: Integer);
begin
   if (FHeader.PageType < EXTERNAL_NODE) and (not FNoKeyStatistics) then
      begin
      if (FHeader.NumberOfKeys > 0) then
         begin
         Dec(pInteger((Buffer+(((FKeySize+KEY_DATA)*(KeyCounter-1))+FKeySize+RECORD_SIZE)))^);
         FIsDirty:=True;
         end;
      end;
end;

function TPage.GetTotalLowerKeyCount: Integer;
var
   I: Word;
   KeyPtr: PChar;
begin
   if (FHeader.PageType > INTERNAL_NODE) then
      Result:=FHeader.NumberOfKeys
   else
      begin
      Result:=0;
      KeyPtr:=(Buffer+FKeySize+RECORD_SIZE);
      for I:=1 to FHeader.NumberOfKeys do
         begin
         Inc(Result,pInteger(KeyPtr)^);
         Inc(KeyPtr,(FKeySize+KEY_DATA));
         end;
      end;
end;

function TPage.GetPageKeyCount(KeyCounter: Integer): Integer;
var
   I: Word;
   KeyPtr: PChar;
begin
   if (FHeader.PageType > INTERNAL_NODE) then
      Result:=(KeyCounter-1)
   else
      begin
      Result:=0;
      KeyPtr:=(Buffer+FKeySize+RECORD_SIZE);
      for I:=1 to KeyCounter-1 do
         begin
         Inc(Result,pInteger(KeyPtr)^);
         Inc(KeyPtr,(FKeySize+KEY_DATA));
         end;
      end;
end;

function TPage.GetMaximumKeys: Word;
begin
   Result:=0;
   if (FHeader.PageType > INTERNAL_NODE) then
      Result:=(FBufferedFile.BufferSize div (FKeySize+(KEY_DATA-KEYCOUNT_SIZE-BOTH_SIZE)))
   else if (FHeader.PageType < EXTERNAL_NODE) and (not FNoKeyStatistics) then
      Result:=(FBufferedFile.BufferSize div (FKeySize+(KEY_DATA-BOTH_SIZE)))
   else if (FHeader.PageType < EXTERNAL_NODE) and FNoKeyStatistics then
      Result:=(FBufferedFile.BufferSize div (FKeySize+(KEY_DATA-KEYCOUNT_SIZE-BOTH_SIZE)));
end;

function TPage.PageDataOverflowed: Boolean;
begin
   Result:=False;
   if (((FHeader.PageType < EXTERNAL_NODE) or
       ((FHeader.PageType > INTERNAL_NODE) and (FKeyCompressionType=NO_COMPRESS))) and
        (FHeader.NumberofKeys > MaximumKeys)) or
      (((FHeader.PageType > INTERNAL_NODE) and (FKeyCompressionType > NO_COMPRESS)) and
        (FHeader.CompressedSize > FBufferedFile.BufferSize)) then
      Result:=True;
end;

{ TIndexFile }

constructor TIndexFile.Create(Owner: TObject);
begin
   inherited Create(Owner);
   if (not FDataTable.IsRemote) then
      FIndexesAreDirty:=False;
end;

destructor TIndexFile.Destroy;
begin
   if FDataTable.IsRemote then
      FreeIndexDefinitions;
   inherited Destroy;
end;

function TIndexFile.GetProperFileName: string;
begin
   Result:=FDataTable.ProperTableName;
end;

procedure TIndexFile.UnpackStaticTableInfo;
var
   I: Byte;
begin
   FDataTable.Unpack(FHeader);
   for I:=0 to FHeader.IndexCount do
      FDataTable.Unpack(FIndexDefinitions[I]);
   FDataTable.Unpack(FIndexDefinitions[TEXT_INDEX_POS]);
end;

procedure TIndexFile.ReadIndexes;
var
   I: Byte;
begin
   ResizeReadBuffer(((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)));
   try
      LockFile;
      try
         Seek(SizeOf(TIndexHeader),FROM_BOF);
         Read(FReadBuffer^,((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)),False);
      finally
         UnlockFile;
      end;
      if FDataTable.Encrypted then
         FDataTable.Decrypt(FReadBuffer,((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)));
      for I:=0 to FHeader.IndexCount do
         Move((FReadBuffer+(I*SizeOf(TIndexDefinition)))^,
              FIndexDefinitions[I],SizeOf(TIndexDefinition));
      Move((FReadBuffer+(TEXT_INDEX_POS*SizeOf(TIndexDefinition)))^,
            FIndexDefinitions[TEXT_INDEX_POS],SizeOf(TIndexDefinition));
      FIndexesAreDirty:=False;
   finally
      ResizeReadBuffer(0);
   end;
end;

function TIndexFile.WriteIndexes(ForceIndexes: Boolean): Boolean;
var
   I: Word;
begin
   Result:=False;
   if FIndexesAreDirty or ForceIndexes then
      begin
      Result:=True;
      ResizeWriteBuffer(((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)));
      try
         for I:=0 to FHeader.IndexCount do
            Move(FIndexDefinitions[I],
                 (FWriteBuffer+(I*SizeOf(TIndexDefinition)))^,
                 SizeOf(TIndexDefinition));
         Move(FIndexDefinitions[TEXT_INDEX_POS],
              (FWriteBuffer+(TEXT_INDEX_POS*SizeOf(TIndexDefinition)))^,
              SizeOf(TIndexDefinition));
         if FDataTable.Encrypted then
            FDataTable.Encrypt(FWriteBuffer,((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)));
         LockFile;
         try
            Seek(SizeOf(TIndexHeader),FROM_BOF);
            Write(FWriteBuffer^,((MAX_NUM_INDEXES+1)*SizeOf(TIndexDefinition)));
            if FDataTable.DataDirectory.DataSession.ForceBufferFlush then
               Flush;
         finally
            UnlockFile;
         end;
         FIndexesAreDirty:=False;
      finally
         ResizeWriteBuffer(0);
      end;
      end;
end;

function TIndexFile.CreateBuffer: TBuffer;
begin
   Result:=TPage.Create(Self);
end;

procedure TIndexFile.CorruptError;
begin
   DataEngine.RaiseError(DBISAM_INDEXCORRUPT,'','',ProperDataDirectoryName,
                           TableName);
end;

procedure TIndexFile.CheckMaxBuffers;
begin
   if (FileSize > DataEngine.MaximumFileSize) then
      DataEngine.RaiseError(DBISAM_TABLEFULL,'','',ProperDataDirectoryName,
                              TableName);
end;

procedure TIndexFile.IncNextBuffer;
begin
   Inc(FHeader.NextEndingPage);
   FHeader.IsDirty:=True;
end;

function TIndexFile.CalculateCapacity: Integer;
begin
   if (BufferSize <> 0) then
      Result:=(DataEngine.MaxIndexBufferSize div (BufferSize+TPage.InstanceSize))
   else
      Result:=DataEngine.MaxIndexBufferCount;
   Result:=MinimumInteger(Result,DataEngine.MaxIndexBufferCount);
   Result:=MaximumInteger(Result,1);
end;

function TIndexFile.CalculateReadAhead: Integer;
begin
   Result:=1;
end;

function TIndexFile.GetIOBlockSize: Word;
begin
   Result:=FDataTable.IndexPageSize;
end;

function TIndexFile.GetBufferSize: Word;
begin
   Result:=(FDataTable.IndexPageSize-SizeOf(TPageHeader));
end;

function TIndexFile.GetHeaderSize: Int64;
begin
   Result:=(Int64(SizeOf(TIndexHeader))+(Int64(SizeOf(TIndexDefinition))*Int64(MAX_NUM_INDEXES+1)));
end;

function TIndexFile.GetIOBlocksUsed: Integer;
begin
   Result:=(FHeader.NextEndingPage-1);
end;

function TIndexFile.GetLastUpdateStamp: Integer;
begin
   Result:=FHeader.UpdateStamp;
end;

function TIndexFile.GetMRUBuffers: Byte;
begin
   Result:=DEFAULT_MRU_PAGES;
end;

function TIndexFile.GetBufferExpand: Byte;
begin
   Result:=PAGE_BUFFER_EXPAND;
end;

procedure TIndexFile.OpenFile;
begin
   inherited OpenFile;
   FillChar(FHeader,SizeOf(TIndexHeader),#0);
   FillChar(FIndexDefinitions,SizeOf(FIndexDefinitions),#0);
   { Read the header data }
   ReadHeader;
   { Check the version information }
   if (FHeader.VersionNum <> VERSION_NUMBER) then
      begin
      if DataEngine.ValidVersion(FHeader.VersionNum) then
         DataEngine.RaiseError(DBISAM_OLDVERSION,'','',ProperDataDirectoryName,
                               TableName)
      else
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end
   else
      begin
      if (not MD5DigestCompare(FHeader.FileSignature,DataEngine.SignatureDigest)) and
         (not MD5DigestCompare(FHeader.FileSignature,MD5String(DBISAM_SIGNATURE))) then
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end;
   if (FHeader.IndexCount > MAX_USER_INDEXES) then
      DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                            TableName);
   { Read in the index definitions }
   ReadIndexes;
   InitializeBuffers;
end;

procedure TIndexFile.CloseFile;
begin
   FreeIndexDefinitions;
   inherited CloseFile;
end;

procedure TIndexFile.FreeIndexDefinitions;
begin
   FillChar(FIndexDefinitions,SizeOf(FIndexDefinitions),#0);
end;

procedure TIndexFile.CreateFile;
begin
   inherited CreateFile;
   FillChar(FHeader,SizeOf(TIndexHeader),#0);
   FillChar(FIndexDefinitions,SizeOf(FIndexDefinitions),#0);
   FHeader.VersionNum:=VERSION_NUMBER;
   FHeader.FileSignature:=DataEngine.SignatureDigest;
   FHeader.NextEndingPage:=1;
   FHeader.IsDirty:=True;
end;

function TIndexFile.CheckForChanges: Boolean;
var
   LastUpdateStamp: Integer;
begin
   Result:=False;
   LastUpdateStamp:=FHeader.UpdateStamp;
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TIndexHeader),False);
   finally
      UnlockFile;
   end;
   if FDataTable.Encrypted then
      FDataTable.Decrypt(@FHeader,SizeOf(TIndexHeader));
   FHeader.IsDirty:=False;
   if (FHeader.UpdateStamp <> LastUpdateStamp) then
      Result:=True;
end;

procedure TIndexFile.GetHeader(var Header: TIndexHeader);
begin
   Header:=FHeader;
end;

procedure TIndexFile.ReadHeader;
begin
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TIndexHeader),False);
   finally
      UnlockFile;
   end;
   if FDataTable.Encrypted then
      FDataTable.Decrypt(@FHeader,SizeOf(TIndexHeader));
   FHeader.IsDirty:=False;
end;

function TIndexFile.WriteHeader(ForceHeader: Boolean): Boolean;
var
   TempHeader: TDataHeader;
begin
   Result:=False;
   if FHeader.IsDirty or ForceHeader then
      begin
      Result:=True;
      Inc(FHeader.UpdateStamp);
      if FDataTable.Encrypted then
         begin
         Move(FHeader,TempHeader,SizeOf(TIndexHeader));
         FDataTable.Encrypt(@TempHeader,SizeOf(TIndexHeader));
         end;
      LockFile;
      try
         Seek(0,FROM_BOF);
         if FDataTable.Encrypted then
            Write(TempHeader,SizeOf(TIndexHeader))
         else
            Write(FHeader,SizeOf(TIndexHeader));
         FDataTable.WrittenTo:=True;
         FHeader.IsDirty:=False;
      finally
         UnlockFile;
      end;
      end;
end;

procedure TIndexFile.UpdateHeaderStamp;
begin
   Inc(FHeader.UpdateStamp);
   FHeader.IsDirty:=True;
   FDataTable.WrittenTo:=True;
end;

procedure TIndexFile.ClearHeader;
var
   I: Byte;
begin
   inherited;
   with FHeader do
      begin
      VersionNum:=VERSION_NUMBER;
      UpdateStamp:=0;
      NextEndingPage:=1;
      NextFreePage:=0;
      for I:=0 to MAX_NUM_INDEXES do
         begin
         RootPages[I]:=0;
         DataRootPages[I]:=0;
         end;
      IsDirty:=True;
      end;
end;

procedure TIndexFile.CheckHeader;
var
   I: Word;
   J: Byte;
   H: Word;
   TempKeySize: Word;
   TempFieldPos: Word;
   TempFieldDefinition: pFieldDefinition;
begin
   with FHeader do
      begin
      if (not CheckPageNumber(NextFreePage)) then
         DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                               TableName);
      for I:=0 to IndexCount do
         begin
         with FIndexDefinitions[I] do
            begin
            if (I > 0) then
               begin
               if (not IsAlpha(IndexName[1])) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                        TableName);
               if (System.Length(IndexName) > MAX_INDEXNAME_SIZE) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                        TableName);
               for H:=1 to IndexCount do
                  begin
                  if (H <> I) and
                     (AnsiCompareText(Trim(FIndexDefinitions[H].IndexName),IndexName)=0) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                           TableName);
                  end;
               end
            else
               begin
               if (IndexName <> '') or (not KeyUnique) or (KeyFields[1]=0) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                        TableName);
               end;
            if (KeyFieldCount=0) or (KeyFieldCount > MAX_NUM_FLDSINKEY) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            J:=1;
            TempKeySize:=0;
            while True do
               begin
               if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
                  begin
                  if (KeyFields[J+1] <> 0) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                             TableName)
                  else
                     Break;
                  end
               else if (KeyFields[J] <> 0) and
                       (KeyFields[J] <> RECORDID_FIELD_NUM) and
                       (KeyFields[J] <> RECORDHASH_FIELD_NUM) and
                       (J <= MAX_NUM_FLDSINKEY) then
                  begin
                  TempFieldPos:=0;
                  TempFieldDefinition:=nil;
                  for H:=1 to FDataTable.FieldCount do
                     begin
                     TempFieldDefinition:=FDataTable.GetFieldDefinitionByNumber(H);
                     if (TempFieldDefinition^.FieldNum=KeyFields[J]) then
                        begin
                        TempFieldPos:=H;
                        Break;
                        end;
                     end;
                  if (TempFieldPos <= 0) or (TempFieldPos > FDataTable.FieldCount) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                             TableName);
                  if (TempFieldDefinition.DataType=TYPE_BLOB) then
                     DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                             TableName);
                  Inc(TempKeySize,FLDCHG_DATA+GetIndexedSize(TempFieldDefinition));
                  Inc(J);
                  end
               else if (KeyFields[J]=RECORDID_FIELD_NUM) and
                       (J <= MAX_NUM_FLDSINKEY) then
                  begin
                  Inc(TempKeySize,FLDCHG_DATA+RECORDID_SIZE);
                  Inc(J);
                  end
               else if (KeyFields[J]=RECORDHASH_FIELD_NUM) and
                       (J <= MAX_NUM_FLDSINKEY) then
                  begin
                  Inc(TempKeySize,FLDCHG_DATA+RECORDHASH_SIZE);
                  Inc(J);
                  end
               else
                  Break;
               end;
            if (TempKeySize > MAX_KEYLEN) or (TempKeySize=0) or
               (TempKeySize > (BufferSize div 3)) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                       TableName);
            if (not CheckPageNumber(RootPages[I])) or
               (not CheckPageNumber(DataRootPages[I])) then
               DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                     TableName);
            end;
         end;
      with FIndexDefinitions[TEXT_INDEX_POS] do
         begin
         if (KeyFieldCount > MAX_NUM_FLDSINKEY) or
            (AnsiCompareText(IndexName,TEXT_INDEX_NAME) <> 0) or
            (KeySize <> TEXT_KEY_SIZE) or
            (KeyCompressionType <> BOTH_COMPRESS) or
            (not NoKeyStatistics) then
            DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                    TableName);
         J:=1;
         while True do
            begin
            if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
               begin
               if (KeyFields[J+1] <> 0) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName)
               else
                  Break;
               end
            else if (KeyFields[J] <> 0) and (J <= MAX_NUM_FLDSINKEY) then
               begin
               TempFieldPos:=0;
               TempFieldDefinition:=nil;
               for H:=1 to FDataTable.FieldCount do
                  begin
                  TempFieldDefinition:=FDataTable.GetFieldDefinitionByNumber(H);
                  if (TempFieldDefinition^.FieldNum=KeyFields[J]) then
                     begin
                     TempFieldPos:=H;
                     Break;
                     end;
                  end;
               if (TempFieldPos <= 0) or (TempFieldPos > FDataTable.FieldCount) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName);
               if (not (((TempFieldDefinition^.DataType=TYPE_BLOB) and
                         (TempFieldDefinition^.SubType=SUBTYPE_MEMO)) or
                         (TempFieldDefinition^.DataType=TYPE_ZSTRING))) then
                  DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                          TableName);
               Inc(J);
               end
            else
               Break;
            end;
         if (not CheckPageNumber(RootPages[TEXT_INDEX_POS])) or
            (not CheckPageNumber(DataRootPages[TEXT_INDEX_POS])) then
            DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                                  TableName);
         end;
      end;
end;

function TIndexFile.CheckPageNumber(PageNumber: Integer): Boolean;
begin
   Result:=True;
   if (FHeader.NextEndingPage=1) and (PageNumber <> 0) or
      ((FHeader.NextEndingPage <> 1) and (PageNumber <> 0) and
       ((PageNumber > IOBlocksUsed) or (PageNumber < 0))) then
      Result:=False;
end;

function TIndexFile.RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean;
var
   I: Word;
   J: Byte;
   H: Word;
   TempKeySize: Word;
   TempFieldPos: Word;
   CurIndexName: string;
   TempFieldDefinition: pFieldDefinition;
begin
   Result:=True;
   if (not CheckPageNumber(FHeader.NextFreePage)) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Invalid free index page pointer')
      else
         DataCursor.DoLog('Invalid free index page pointer, error fixed');
      Result:=False;
      end;
   for I:=0 to FHeader.IndexCount do
      begin
      with FIndexDefinitions[I] do
         begin
         RemoveIndex:=False;
         if (I > 0) then
            begin
            CurIndexName:=AnsiUpperCase(Trim(IndexName));
            if (not IsAlpha(CurIndexName[1])) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid index name for index '+IndexName)
               else
                  begin
                  DataCursor.DoLog('Invalid index name for index '+IndexName+', error fixed');
                  IndexName:='_'+IndexName;
                  end;
               Result:=False;
               end;
            if (System.Length(CurIndexName) > MAX_INDEXNAME_SIZE) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid index name (too long) for index '+IndexName)
               else
                  begin
                  DataCursor.DoLog('Invalid index name (too long) for index '+IndexName+', error fixed');
                  IndexName:=Substr(IndexName,1,MAX_INDEXNAME_SIZE);
                  end;
               Result:=False;
               end;
            for H:=1 to IndexCount do
               begin
               if (H <> I) and
                  (AnsiCompareText(Trim(FIndexDefinitions[H].IndexName),CurIndexName)=0) then
                  begin
                  if VerifyOnly then
                     DataCursor.DoLog('Duplicate index name for index '+IndexName)
                  else
                     begin
                     DataCursor.DoLog('Duplicate index name for index '+IndexName+', error fixed');
                     IndexName:='_'+IndexName;
                     end;
                  Result:=False;
                  end;
               end;
            end
         else
            begin
            if (IndexName <> '') or (not KeyUnique) or (KeyFields[1]=0) then
               begin
               if (not VerifyOnly) then
                  begin
                  DataCursor.DoLog('Invalid primary index definition, error fixed');
                  with FIndexDefinitions[I] do
                     begin
                     IndexName:='';
                     KeyUnique:=True;
                     { If no fields are defined then there is no primary index,
                       so add an automatic primary index }
                     if (KeyFields[1]=0) then
                        begin
                        KeyDescending:=False;
                        KeyCaseInsensitive:=False;
                        KeyFieldCount:=1;
                        FillChar(KeyFields,SizeOf(TKeyFields),#0);
                        KeyFields[1]:=RECORDID_FIELD_NUM;
                        KeySize:=AUTO_PRIMARYKEY_SIZE;
                        FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
                        NoKeyStatistics:=False;
                        KeyCompressionType:=NO_COMPRESS;
                        end;
                     end;
                  end
               else
                  DataCursor.DoLog('Invalid primary index definition');
               end;
            end;
         TempKeySize:=0;
         J:=1;
         while True do
            begin
            if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
               begin
               if (KeyFields[J+1] <> 0) then
                  begin
                  if VerifyOnly then
                     DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                      ' in index '+IndexName)
                  else
                     begin
                     DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                      ' in index '+IndexName+', error fixed and field '+
                                      'removed from index');
                     Move(KeyFields[J+1],KeyFields[J],((MAX_NUM_FLDSINKEY-J)*SizeOf(Word)));
                     KeyFields[MAX_NUM_FLDSINKEY]:=0;
                     end;
                  Result:=False;
                  Continue;
                  end
               else
                  Break;
               end
            else if (KeyFields[J] <> 0) and
                    (KeyFields[J] <> RECORDID_FIELD_NUM) and
                    (KeyFields[J] <> RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               TempFieldPos:=0;
               TempFieldDefinition:=nil;
               for H:=1 to FDataTable.FieldCount do
                  begin
                  TempFieldDefinition:=FDataTable.GetFieldDefinitionByPos(H);
                  if (TempFieldDefinition^.FieldNum=KeyFields[J]) then
                     begin
                     TempFieldPos:=H;
                     Break;
                     end;
                  end;
               if (TempFieldPos <= 0) or (TempFieldPos > FDataTable.FieldCount) then
                  begin
                  if VerifyOnly then
                     DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                      ' in index '+IndexName)
                  else
                     begin
                     DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                      ' in index '+IndexName+', error fixed and field '+
                                      'removed from index');
                     Move(KeyFields[J+1],KeyFields[J],((MAX_NUM_FLDSINKEY-J)*SizeOf(Word)));
                     KeyFields[MAX_NUM_FLDSINKEY]:=0;
                     end;
                  Result:=False;
                  end
               else
                  begin
                  Inc(TempKeySize,FLDCHG_DATA+GetIndexedSize(TempFieldDefinition));
                  Inc(J);
                  end;
               end
            else if (KeyFields[J]=RECORDID_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDID_SIZE);
               Inc(J);
               end
            else if (KeyFields[J]=RECORDHASH_FIELD_NUM) and
                    (J <= MAX_NUM_FLDSINKEY) then
               begin
               Inc(TempKeySize,FLDCHG_DATA+RECORDHASH_SIZE);
               Inc(J);
               end
            else
               Break;
            end;
         if (TempKeySize > MAX_KEYLEN) or (TempKeySize=0) or
            (TempKeySize > (BufferSize div 3)) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid key size of '+IntToStr(TempKeySize)+
                                ' for index '+IndexName)
            else
               begin
               DataCursor.DoLog('Invalid key size of '+IntToStr(TempKeySize)+
                                ' for index '+IndexName+', error fixed and index removed');
               RemoveIndex:=True;
               end;
            Result:=False;
            end;
         if (not RemoveIndex) then
            begin
            { Add the automatic record ID size if the current index is not unique
              or if it's the automatic primary index }
            if (not KeyUnique) then
               Inc(TempKeySize,RECORDID_SIZE);
            if (KeySize <> TempKeySize) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid key size of '+IntToStr(KeySize)+
                                   ' for index '+IndexName)
               else
                  begin
                  DataCursor.DoLog('Invalid key size of '+IntToStr(KeySize)+
                                   ' for index '+IndexName+', error fixed');
                  KeySize:=TempKeySize;
                  end;
               Result:=False;
               end;
            end;
         if (KeyFieldCount <> (J-1)) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid key field count of '+IntToStr(KeyFieldCount)+
                                ' for index '+IndexName)
            else
               begin
               DataCursor.DoLog('Invalid key field count of '+IntToStr(KeyFieldCount)+
                                ' for index '+IndexName+', error fixed');
               KeyFieldCount:=(J-1);
               end;
            Result:=False;
            end;
         if (not CheckPageNumber(FHeader.RootPages[I])) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid root page pointer for index '+IndexName)
            else
               DataCursor.DoLog('Invalid root page pointer for index '+IndexName+
                                ', error fixed');
            Result:=False;
            end;
         if (not CheckPageNumber(FHeader.DataRootPages[I])) then
            begin
            if VerifyOnly then
               DataCursor.DoLog('Invalid data root page pointer for index '+IndexName)
            else
               DataCursor.DoLog('Invalid data root page pointer for index '+IndexName+
                                ', error fixed');
            Result:=False;
            end;
         end;
      end;
   with FIndexDefinitions[TEXT_INDEX_POS] do
      begin
      if (AnsiCompareText(IndexName,TEXT_INDEX_NAME) <> 0) or
         (KeySize <> TEXT_KEY_SIZE) or
         (KeyCompressionType <> BOTH_COMPRESS) or
         (not NoKeyStatistics) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('Invalid index definition for index '+IndexName)
         else
            begin
            DataCursor.DoLog('Invalid index definition for index '+IndexName+
                             ', error fixed');
            IndexName:=TEXT_INDEX_NAME;
            KeySize:=TEXT_KEY_SIZE;
            KeyCompressionType:=BOTH_COMPRESS;
            NoKeyStatistics:=True;
            end;
         end;
      J:=1;
      while True do
         begin
         if (KeyFields[J]=0) and ((J+1) <= MAX_NUM_FLDSINKEY) then
            begin
            if (KeyFields[J+1] <> 0) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                   ' in index '+IndexName)
               else
                  begin
                  DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                   ' in index '+IndexName+', error fixed and field '+
                                   'removed from index');
                  Move(KeyFields[J+1],KeyFields[J],((MAX_NUM_FLDSINKEY-J)*SizeOf(Word)));
                  KeyFields[MAX_NUM_FLDSINKEY]:=0;
                  end;
               Result:=False;
               Continue;
               end
            else
               Break;
            end
         else if (KeyFields[J] <> 0) and (J <= MAX_NUM_FLDSINKEY) then
            begin
            TempFieldPos:=0;
            for H:=1 to FDataTable.FieldCount do
               begin
               TempFieldDefinition:=FDataTable.GetFieldDefinitionByPos(H);
               if (TempFieldDefinition^.FieldNum=KeyFields[J]) then
                  begin
                  TempFieldPos:=H;
                  Break;
                  end;
               end;
            if (TempFieldPos <= 0) or (TempFieldPos > FDataTable.FieldCount) then
               begin
               if VerifyOnly then
                  DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                   ' in index '+IndexName)
               else
                  begin
                  DataCursor.DoLog('Invalid field number '+IntToStr(KeyFields[J])+
                                   ' in index '+IndexName+', error fixed and field '+
                                   'removed from index');
                  Move(KeyFields[J+1],KeyFields[J],((MAX_NUM_FLDSINKEY-J)*SizeOf(Word)));
                  KeyFields[MAX_NUM_FLDSINKEY]:=0;
                  end;
               Result:=False;
               end
            else
               Inc(J);
            end
         else
            Break;
         end;
      if (KeyFieldCount <> (J-1)) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('Invalid key field count of '+IntToStr(KeyFieldCount)+
                             ' for index '+IndexName)
         else
            begin
            DataCursor.DoLog('Invalid key field count of '+IntToStr(KeyFieldCount)+
                             ' for index '+IndexName+', error fixed');
            KeyFieldCount:=(J-1);
            end;
         Result:=False;
         end;
      if (not CheckPageNumber(FHeader.RootPages[TEXT_INDEX_POS])) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('Invalid root page pointer for index '+IndexName)
         else
            DataCursor.DoLog('Invalid root page pointer for index '+IndexName+
                             ', error fixed');
         Result:=False;
         end;
      if (not CheckPageNumber(FHeader.DataRootPages[TEXT_INDEX_POS])) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('Invalid data root page pointer for index '+IndexName)
         else
            DataCursor.DoLog('Invalid data root page pointer for index '+IndexName+
                             ', error fixed');
         Result:=False;
         end;
      end;
   if (not VerifyOnly) then
      begin
      for I:=FHeader.IndexCount downto 0 do
         begin
         if FIndexDefinitions[I].RemoveIndex then
            DeleteIndex(I,True);
         end;
      FHeader.VersionNum:=VERSION_NUMBER;
      FHeader.IsDirty:=True;
      FIndexesAreDirty:=True;
      end;
end;

function TIndexFile.GetRootPageNumber(IndexPos: Byte): Integer;
begin
   Result:=FHeader.RootPages[IndexPos];
end;

procedure TIndexFile.SetRootPageNumber(IndexPos: Byte; Value: Integer);
begin
   if (Value <> FHeader.RootPages[IndexPos]) then
      begin
      FHeader.RootPages[IndexPos]:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TIndexFile.GetDataRootPageNumber(IndexPos: Byte): Integer;
begin
   Result:=FHeader.DataRootPages[IndexPos];
end;

procedure TIndexFile.SetDataRootPageNumber(IndexPos: Byte; Value: Integer);
begin
   if (Value <> FHeader.DataRootPages[IndexPos]) then
      begin
      FHeader.DataRootPages[IndexPos]:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TIndexFile.GetNextFreePageNumber: Integer;
begin
   if (FHeader.NextFreePage <> 0) then
      Result:=FHeader.NextFreePage
   else
      Result:=FHeader.NextEndingPage;
end;

procedure TIndexFile.SetNextFreePageNumber(Value: Integer);
begin
   if (Value <> FHeader.NextFreePage) then
      begin
      FHeader.NextFreePage:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TIndexFile.GetIndexCount: Byte;
begin
   Result:=FHeader.IndexCount;
end;

procedure TIndexFile.SetIndexCount(Value: Byte);
begin
   if (Value <> FHeader.IndexCount) then
      begin
      FHeader.IndexCount:=Value;
      FHeader.IsDirty:=True;
      end;
end;

function TIndexFile.GetAutoPrimaryIndex: Boolean;
begin
   Result:=(FIndexDefinitions[0].KeyFields[1]=RECORDID_FIELD_NUM);
end;

function TIndexFile.GetIndexDefinition(IndexPos: Byte): pIndexDefinition;
begin
   Result:=@FIndexDefinitions[IndexPos];
end;

procedure TIndexFile.SetIndexDefinition(IndexPos: Byte; Buffer: pIndexDefinition);
begin
   with FIndexDefinitions[IndexPos] do
      begin
      IndexName:=Buffer^.IndexName;
      KeySize:=Buffer^.KeySize;
      KeyDescending:=Buffer^.KeyDescending;
      KeyCaseInsensitive:=Buffer^.KeyCaseInsensitive;
      KeyUnique:=Buffer^.KeyUnique;
      NoKeyStatistics:=Buffer^.NoKeyStatistics;
      KeyCompressionType:=Buffer^.KeyCompressionType;
      KeyFieldCount:=Buffer^.KeyFieldCount;
      KeyFields:=Buffer^.KeyFields;
      KeyDescendingFields:=Buffer^.KeyDescendingFields;
      IndexChanged:=False;
      FillChar(EmptySpace,SizeOf(EmptySpace),#0);
      end;
   FHeader.RootPages[IndexPos]:=0;
   FHeader.IsDirty:=True;
   FIndexesAreDirty:=True;
end;

procedure TIndexFile.UpdateIndexDefinition(IndexPos: Byte; Buffer: pIndexDefinition);
begin
   with FIndexDefinitions[IndexPos] do
      begin
      IndexName:=Buffer^.IndexName;
      KeyFields:=Buffer^.KeyFields;
      KeyDescendingFields:=Buffer^.KeyDescendingFields;
      end;
   FIndexesAreDirty:=True;
end;

procedure TIndexFile.AddPrimaryIndex(NewIndexDefinition: pIndexDefinition);
var
   I: Byte;
begin
   if (FIndexDefinitions[0].KeySize > 0) and (not AutoPrimaryIndex) then
      DataEngine.RaiseError(DBISAM_PRIMARYKEYREDEFINE,'','',ProperDataDirectoryName,
                              TableName,'','Primary');
   if (NewIndexDefinition^.KeyFieldCount > MAX_NUM_FLDSINKEY) then
      DataEngine.RaiseError(DBISAM_INDEXLIMIT,'','',ProperDataDirectoryName,
                              TableName,'','Primary');
   for I:=1 to NewIndexDefinition^.KeyFieldCount do
      begin
      with FDataTable.GetFieldDefinitionByNumber(NewIndexDefinition^.KeyFields[I])^ do
         begin
         if (DataType=TYPE_BLOB) then
            DataEngine.RaiseError(DBISAM_SEARCHCOLREQD,'','',ProperDataDirectoryName,
                                    TableName,FieldName,'Primary');
         end;
      end;
   with FIndexDefinitions[0] do
      begin
      IndexName:='';
      KeySize:=NewIndexDefinition^.KeySize;
      KeyDescending:=NewIndexDefinition^.KeyDescending;
      KeyCaseInsensitive:=NewIndexDefinition^.KeyCaseInsensitive;
      KeyUnique:=True;
      NoKeyStatistics:=NewIndexDefinition^.NoKeyStatistics;
      KeyCompressionType:=NewIndexDefinition^.KeyCompressionType;
      KeyFieldCount:=NewIndexDefinition^.KeyFieldCount;
      KeyFields:=NewIndexDefinition^.KeyFields;
      KeyDescendingFields:=NewIndexDefinition^.KeyDescendingFields;
      end;
   with FHeader do
      begin
      RootPages[0]:=0;
      DataRootPages[0]:=0;
      IsDirty:=True;
      end;
   FIndexesAreDirty:=True;
end;

procedure TIndexFile.AddSecondaryIndex(NewIndexDefinition: pIndexDefinition);
var
   I: Byte;
begin
   if (FHeader.IndexCount=MAX_USER_INDEXES) then
      DataEngine.RaiseError(DBISAM_INDEXLIMIT,'','',ProperDataDirectoryName,
                              TableName,'',NewIndexDefinition^.IndexName);
   if (NewIndexDefinition^.KeyFieldCount > MAX_NUM_FLDSINKEY) then
      DataEngine.RaiseError(DBISAM_INDEXLIMIT,'','',ProperDataDirectoryName,
                              TableName,'',NewIndexDefinition^.IndexName);
   if (NewIndexDefinition^.IndexName='') then
      DataEngine.RaiseError(DBISAM_INDEXNAMEREQUIRED,'','',ProperDataDirectoryName,
                              TableName,'',NewIndexDefinition^.IndexName);
   if (not IsAlpha(NewIndexDefinition^.IndexName[1])) then
      DataEngine.RaiseError(DBISAM_INVALIDINDEXNAME,'','',ProperDataDirectoryName,
                              TableName,'',NewIndexDefinition^.IndexName);
   for I:=1 to FHeader.IndexCount do
      begin
      if (AnsiCompareText(Trim(NewIndexDefinition^.IndexName),
                          Trim(FIndexDefinitions[I].IndexName))=0) then
         DataEngine.RaiseError(DBISAM_INDEXEXISTS,'','',ProperDataDirectoryName,
                                 TableName,'',NewIndexDefinition^.IndexName);
      end;
   for I:=1 to NewIndexDefinition^.KeyFieldCount do
      begin
      with FDataTable.GetFieldDefinitionByNumber(NewIndexDefinition^.KeyFields[I])^ do
         begin
         if (DataType=TYPE_BLOB) then
            DataEngine.RaiseError(DBISAM_SEARCHCOLREQD,'','',ProperDataDirectoryName,
                                    TableName,FieldName,NewIndexDefinition^.IndexName);
         end;
      end;
   Inc(FHeader.IndexCount);
   with FIndexDefinitions[FHeader.IndexCount] do
      begin
      IndexName:=NewIndexDefinition^.IndexName;
      KeySize:=NewIndexDefinition^.KeySize;
      KeyDescending:=NewIndexDefinition^.KeyDescending;
      KeyCaseInsensitive:=NewIndexDefinition^.KeyCaseInsensitive;
      KeyUnique:=NewIndexDefinition^.KeyUnique;
      NoKeyStatistics:=NewIndexDefinition^.NoKeyStatistics;
      KeyCompressionType:=NewIndexDefinition^.KeyCompressionType;
      KeyFieldCount:=NewIndexDefinition^.KeyFieldCount;
      KeyFields:=NewIndexDefinition^.KeyFields;
      KeyDescendingFields:=NewIndexDefinition^.KeyDescendingFields;
      end;
   with FHeader do
      begin
      RootPages[IndexCount]:=0;
      DataRootPages[IndexCount]:=0;
      IsDirty:=True;
      end;
   FIndexesAreDirty:=True;
end;

procedure TIndexFile.DeleteIndex(IndexPos: Byte; AdjustIndexDefinitions: Boolean);
begin
   if AdjustIndexDefinitions and
      (IndexPos > 0) and (IndexPos <= MAX_USER_INDEXES) then
      begin
      if (IndexPos < MAX_USER_INDEXES) then
         Move(FIndexDefinitions[IndexPos+1],FIndexDefinitions[IndexPos],
              ((MAX_USER_INDEXES-(IndexPos+1))*SizeOf(TIndexDefinition)));
      FillChar(FIndexDefinitions[MAX_USER_INDEXES],SizeOf(TIndexDefinition),#0);
      with FHeader do
         begin
         if (IndexPos < MAX_USER_INDEXES) then
            Move(RootPages[IndexPos+1],RootPages[IndexPos],
                 ((MAX_USER_INDEXES-(IndexPos+1))*SizeOf(Integer)));
         RootPages[MAX_USER_INDEXES]:=0;
         if (IndexPos < MAX_USER_INDEXES) then
            Move(DataRootPages[IndexPos+1],DataRootPages[IndexPos],
                 ((MAX_USER_INDEXES-(IndexPos+1))*SizeOf(Integer)));
         DataRootPages[MAX_USER_INDEXES]:=0;
         Dec(IndexCount);
         end;
      end
   else
      begin
      if (IndexPos > 0) or ((IndexPos=0) and (not AutoPrimaryIndex)) then
         begin
         FHeader.RootPages[IndexPos]:=0;
         { Add auto primary index, if necessary }
         if (IndexPos=0) then
            begin
            with FIndexDefinitions[IndexPos] do
               begin
               IndexName:='';
               KeyUnique:=True;
               KeyDescending:=False;
               KeyCaseInsensitive:=False;
               KeyFieldCount:=1;
               FillChar(KeyFields,SizeOf(TKeyFields),#0);
               KeyFields[1]:=RECORDID_FIELD_NUM;
               KeySize:=AUTO_PRIMARYKEY_SIZE;
               FillChar(KeyDescendingFields,SizeOf(TDescendingKeyFields),#0);
               NoKeyStatistics:=False;
               KeyCompressionType:=NO_COMPRESS;
               IndexChanged:=False;
               FillChar(EmptySpace,SizeOf(EmptySpace),#0);
               end;
            end;
         end;
      end;
   FHeader.IsDirty:=True;
   FIndexesAreDirty:=True;
end;

function TIndexFile.IndexExists(const NewName: string): Boolean;
var
   I: Integer;
begin
   Result:=False;
   for I:=0 to FHeader.IndexCount do
      begin
      if (AnsiCompareText(FIndexDefinitions[I].IndexName,NewName)=0) then
         begin
         Result:=True;
         Break;
         end;
      end;
end;

{ TBlock }

procedure TBlock.Copy(BufferToCopy: TBuffer);
begin
   inherited;
   Move(TBlock(BufferToCopy).FHeader,FHeader,SizeOf(TBlockHeader));
end;

function TBlock.GetLength: Word;
begin
   Result:=FHeader.Length;
end;

procedure TBlock.SetLength(Value: Word);
begin
   if (Value <> FHeader.Length) then
      begin
      FIsDirty:=True;
      FHeader.Length:=Value;
      Size:=FHeader.Length;
      end;
end;

function TBlock.GetTotalLength: Integer;
begin
   Result:=FHeader.TotalLength;
end;

procedure TBlock.SetTotalLength(Value: Integer);
begin
   if (Value <> FHeader.TotalLength) then
      begin
      FIsDirty:=True;
      FHeader.TotalLength:=Value;
      end;
end;

function TBlock.GetSignature: Integer;
begin
   Result:=FHeader.Signature;
end;

procedure TBlock.SetSignature(Value: Integer);
begin
   if (Value <> FHeader.Signature) then
      begin
      FIsDirty:=True;
      FHeader.Signature:=Value;
      end;
end;

function TBlock.GetPrevNumber: Integer;
begin
   Result:=FHeader.PrevNumber;
end;

procedure TBlock.SetPrevNumber(Value: Integer);
begin
   if (Value <> FHeader.PrevNumber) then
      begin
      FIsDirty:=True;
      FHeader.PrevNumber:=Value;
      end;
end;

function TBlock.GetNextNumber: Integer;
begin
   Result:=FHeader.NextNumber;
end;

procedure TBlock.SetNextNumber(Value: Integer);
begin
   if (Value <> FHeader.NextNumber) then
      begin
      FIsDirty:=True;
      FHeader.NextNumber:=Value;
      end;
end;

procedure TBlock.Initialize(DefinitionPos: Byte=0);
begin
   inherited;
   FillChar(FHeader,SizeOf(TBlockHeader),#0);
end;

procedure TBlock.Read(ReadBuffer: PChar);
begin
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Decrypt(ReadBuffer,FBufferedFile.IOBlockSize);
   Move(ReadBuffer^,FHeader,SizeOf(TBlockHeader));
   Move((ReadBuffer+SizeOf(TBlockHeader))^,FBuffer^,FBufferedFile.BufferSize);
   FIsDirty:=False;
end;

procedure TBlock.Write(WriteBuffer: PChar);
begin
   Move(FHeader,WriteBuffer^,SizeOf(TBlockHeader));
   Move(FBuffer^,(WriteBuffer+SizeOf(TBlockHeader))^,FBufferedFile.BufferSize);
   if FBufferedFile.DataTable.Encrypted then
      FBufferedFile.DataTable.Encrypt(WriteBuffer,FBufferedFile.IOBlockSize);
   FIsDirty:=False;
end;

function TBlock.GetBlockData(Offset: Word; LengthToGet: Word;
                             BlobBuffer: PChar): Word;
begin
   if (LengthToGet > FBufferedFile.BufferSize) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBLEN,'','',FBufferedFile.ProperDataDirectoryName,
                              FBufferedFile.TableName,'','','');
   if (LengthToGet > Length) then
      LengthToGet:=Length;
   Move((FBuffer+Offset)^,BlobBuffer^,LengthToGet);
   Result:=LengthToGet;
end;

function TBlock.PutBlockData(Offset: Word; LengthToSet: Word;
                             BlobBuffer: PChar): Word;
begin
   if (LengthToSet > FBufferedFile.BufferSize) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBLEN,'','',FBufferedFile.ProperDataDirectoryName,
                             FBufferedFile.TableName,'','','');
   Length:=Offset+LengthToSet;
   Move(BlobBuffer^,(FBuffer+Offset)^,LengthToSet);
   FIsDirty:=True;
   Result:=LengthToSet;
end;

procedure TBlock.TruncateBlockData(Offset: Word);
begin
   if (Offset >= FBufferedFile.BufferSize) then
      DataEngine.RaiseError(DBISAM_INVALIDBLOBLEN,'','',FBufferedFile.ProperDataDirectoryName,
                            FBufferedFile.TableName,'','','');
   Length:=Offset;
   FillChar((FBuffer+Offset)^,(FBufferedFile.BufferSize-Offset),#0);
   FIsDirty:=True;
end;

{ TBlobBuffer }

constructor TBlobBuffer.Create(Owner: TDataCursor);
begin
   inherited Create;
   FDataCursor:=Owner;
   FIsDirty:=False;
   FSize:=0;
   FOldSize:=0;
end;

destructor TBlobBuffer.Destroy;
begin
   ResizeBuffer(0,FBuffer,FSize);
   ResizeBuffer(0,FOldBuffer,FOldSize);
   inherited Destroy;
end;

procedure TBlobBuffer.SetSize(Value: Integer);
begin
   if (Value <> FSize) then
      begin
      FIsDirty:=True;
      ResizeBuffer(Value,FBuffer,FSize,True);
      end;
end;

procedure TBlobBuffer.IncUseCount;
begin
   Inc(FUseCount);
end;

procedure TBlobBuffer.DecUseCount;
begin
   if (FUseCount > 0) then
      Dec(FUseCount);
end;

procedure TBlobBuffer.SaveBuffer;
begin
   ResizeBuffer(FSize,FOldBuffer,FOldSize);
   Move(FBuffer^,FOldBuffer^,FOldSize);
end;

procedure TBlobBuffer.Compress;
var
   TempCompressedBuffer: PChar;
   TempCompressedBytes: Integer;
begin
   if (FFieldDefinition^.Compression > NO_COMPRESSION) and
      (FSize > 0) then
      begin
      TempCompressedBuffer:=nil;
      TempCompressedBytes:=0;
      DataEngine.Compress(Pointer(FBuffer),FSize,FFieldDefinition^.Compression,
                          Pointer(TempCompressedBuffer),TempCompressedBytes);
      try
         ResizeBuffer(TempCompressedBytes,FBuffer,FSize,True);
         Move(TempCompressedBuffer^,FBuffer^,TempCompressedBytes);
      finally
         DeAllocMem(TempCompressedBuffer);
      end;
      end;
end;

procedure TBlobBuffer.Decompress;
var
   TempDecompressedBuffer: PChar;
   TempDecompressedBytes: Integer;
begin
   if (FFieldDefinition^.Compression > NO_COMPRESSION) and
      (FSize > 0) then
      begin                                                       
      TempDecompressedBuffer:=nil;
      TempDecompressedBytes:=0;
      DataEngine.Decompress(Pointer(FBuffer),FSize,
                            Pointer(TempDecompressedBuffer),TempDecompressedBytes);
      try
         ResizeBuffer(TempDecompressedBytes,FBuffer,FSize,True);
         Move(TempDecompressedBuffer^,FBuffer^,TempDecompressedBytes);
      finally
         DeAllocMem(TempDecompressedBuffer);
      end;
      end;
end;

{ TBlobFile }

function TBlobFile.GetProperFileName: string;
begin
   Result:=FDataTable.ProperTableName;
end;

procedure TBlobFile.UnpackStaticTableInfo;
begin
   FDataTable.Unpack(FHeader);
end;

function TBlobFile.CreateBuffer: TBuffer;
begin
   Result:=TBlock.Create(Self);
end;

procedure TBlobFile.CorruptError;
begin
   DataEngine.RaiseError(DBISAM_MEMOCORRUPT,'','',ProperDataDirectoryName,
                           TableName);
end;

procedure TBlobFile.CheckMaxBuffers;
begin
   if (FileSize > DataEngine.MaximumFileSize) then
      DataEngine.RaiseError(DBISAM_TABLEFULL,'','',ProperDataDirectoryName,
                              TableName);
end;

procedure TBlobFile.IncNextBuffer;
begin
   Inc(FHeader.NextEndingBlock);
   FHeader.IsDirty:=True;
end;

function TBlobFile.CalculateCapacity: Integer;
begin
   if (BufferSize <> 0) then
      Result:=(DataEngine.MaxBlobBufferSize div (BufferSize+TBlock.InstanceSize))
   else
      Result:=DataEngine.MaxBlobBufferCount;
   Result:=MinimumInteger(Result,DataEngine.MaxBlobBufferCount);
   Result:=MaximumInteger(Result,1);
end;

function TBlobFile.CalculateReadAhead: Integer;
begin
   Result:=1;
end;

function TBlobFile.GetIOBlockSize: Word;
begin
   Result:=FDataTable.BlobBlockSize;
end;

function TBlobFile.GetBufferSize: Word;
begin
   Result:=(FDataTable.BlobBlockSize-SizeOf(TBlockHeader));
end;

function TBlobFile.GetHeaderSize: Int64;
begin
   Result:=Int64(SizeOf(TBlobHeader));
end;

function TBlobFile.GetIOBlocksUsed: Integer;
begin
   Result:=(FHeader.NextEndingBlock-1);
end;

function TBlobFile.GetLastUpdateStamp: Integer;
begin
   Result:=FHeader.UpdateStamp;
end;

function TBlobFile.GetMRUBuffers: Byte;
begin
   Result:=DEFAULT_MRU_BLOCKS;
end;

function TBlobFile.GetBufferExpand: Byte;
begin
   Result:=BLOCK_BUFFER_EXPAND;
end;

function TBlobFile.GetReadAheadBuffers(DataCursor: TDataCursor;
                                       Direction: Byte): Integer;
begin
   Result:=DataCursor.GetNumReadAheadBlocks(ReadAheadBuffers,Direction);
end;

procedure TBlobFile.OpenFile;
begin
   inherited OpenFile;
   FillChar(FHeader,SizeOf(TBlobHeader),#0);
   ReadHeader;
   { Check the version information }
   if (FHeader.VersionNum <> VERSION_NUMBER) then
      begin
      if DataEngine.ValidVersion(FHeader.VersionNum) then
         DataEngine.RaiseError(DBISAM_OLDVERSION,'','',ProperDataDirectoryName,
                               TableName)
      else
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end
   else
      begin
      if (not MD5DigestCompare(FHeader.FileSignature,DataEngine.SignatureDigest)) and
         (not MD5DigestCompare(FHeader.FileSignature,MD5String(DBISAM_SIGNATURE))) then
         DataEngine.RaiseError(DBISAM_BADSIGNATURE,'','',ProperDataDirectoryName,
                               TableName);
      end;
   InitializeBuffers;
end;

procedure TBlobFile.CreateFile;
begin
   inherited CreateFile;
   FillChar(FHeader,SizeOf(TBlobHeader),#0);
   FHeader.VersionNum:=VERSION_NUMBER;
   FHeader.FileSignature:=DataEngine.SignatureDigest;
   FHeader.NextEndingBlock:=1;
   FHeader.IsDirty:=True;
end;

function TBlobFile.CheckForChanges: Boolean;
var
   LastUpdateStamp: Integer;
begin
   Result:=False;
   LastUpdateStamp:=FHeader.UpdateStamp;
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TBlobHeader),False);
   finally
      UnlockFile;
   end;
   if FDataTable.Encrypted then
      FDataTable.Decrypt(@FHeader,SizeOf(TBlobHeader));
   FHeader.IsDirty:=False;
   if (FHeader.UpdateStamp <> LastUpdateStamp) then
      Result:=True
end;

procedure TBlobFile.GetHeader(var Header: TBlobHeader);
begin
   Header:=FHeader;
end;

procedure TBlobFile.ReadHeader;
begin
   LockFile;
   try
      Seek(0,FROM_BOF);
      Read(FHeader,SizeOf(TBlobHeader),False);
   finally
      UnlockFile;
   end;
   if FDataTable.Encrypted then
      FDataTable.Decrypt(@FHeader,SizeOf(TBlobHeader));
   FHeader.IsDirty:=False;
end;

function TBlobFile.WriteHeader(ForceHeader: Boolean): Boolean;
var
   TempHeader: TDataHeader;
begin
   Result:=False;
   if FHeader.IsDirty or ForceHeader then
      begin
      Result:=True;
      Inc(FHeader.UpdateStamp);
      if FDataTable.Encrypted then
         begin
         Move(FHeader,TempHeader,SizeOf(TBlobHeader));
         FDataTable.Encrypt(@TempHeader,SizeOf(TBlobHeader));
         end;
      LockFile;
      try
         Seek(0,FROM_BOF);
         if FDataTable.Encrypted then
            Write(TempHeader,SizeOf(TBlobHeader))
         else
            Write(FHeader,SizeOf(TBlobHeader));
         FDataTable.WrittenTo:=True;
         FHeader.IsDirty:=False;
      finally
         UnlockFile;
      end;
      end;
end;

procedure TBlobFile.UpdateHeaderStamp;
begin
   Inc(FHeader.UpdateStamp);
   FHeader.IsDirty:=True;
   FDataTable.WrittenTo:=True;
end;

procedure TBlobFile.ClearHeader;
begin
   inherited;
   with FHeader do
      begin
      VersionNum:=VERSION_NUMBER;
      UpdateStamp:=0;
      NextEndingBlock:=1;
      NextFreeBlock:=0;
      IsDirty:=True;
      end;
end;

procedure TBlobFile.CheckHeader;
begin
   if (not CheckBlockNumber(FHeader.NextFreeBlock)) then
      DataEngine.RaiseError(DBISAM_HEADERCORRUPT,'','',ProperDataDirectoryName,
                            TableName,'','','');
end;

function TBlobFile.CheckBlockNumber(BlockNumber: Integer): Boolean;
begin
   Result:=True;
   if (FHeader.NextEndingBlock=1) and (BlockNumber <> 0) or
      ((FHeader.NextEndingBlock <> 1) and (BlockNumber <> 0) and
         ((BlockNumber > IOBlocksUsed) or
        (BlockNumber < 0))) then
      Result:=False;
end;

function TBlobFile.RepairHeader(DataCursor: TDataCursor; VerifyOnly: Boolean): Boolean;
var
   TempHeaderSize: Integer;
   TempBlockHangSize: Integer;
   Buffer: array[1..1] of Char;
begin
   Result:=True;
   TempHeaderSize:=SizeOf(TBlobHeader);
   { Check to make sure that the blocks align properly }
   if (GetSize > TempHeaderSize) then
      begin
      TempBlockHangSize:=((GetSize-TempHeaderSize) mod FDataTable.BlobBlockSize);
      { If there is a discrepancy in the block alignment then
        truncate the file size to match }
      if (TempBlockHangSize <> 0) then
         begin
         if VerifyOnly then
            DataCursor.DoLog('BLOB blocks not aligned on '+
                             'even block size boundaries')
         else
            begin
            DataCursor.DoLog('BLOB blocks not aligned on '+
                             'even block size boundaries, '+
                             'error fixed');
            Seek(-TempBlockHangSize,FROM_EOF);
            Write(Buffer,0);
            if FDataTable.DataDirectory.DataSession.ForceBufferFlush then
               Flush;
            end;
         Result:=False;
         end;
      end;
   { Check BLOB header for incorrect block count }
   if (FHeader.NextEndingBlock <>
      (((GetSize-TempHeaderSize) div FDataTable.BlobBlockSize)+1)) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Physical BLOB block count not correct')
      else
         begin
         DataCursor.DoLog('Physical BLOB block count not correct, '+
                          'error fixed');
         FHeader.NextEndingBlock:=(((GetSize-TempHeaderSize)
                                      div FDataTable.BlobBlockSize)+1);
         end;
      Result:=False;
      end;
   if (not CheckBlockNumber(FHeader.NextFreeBlock)) then
      begin
      if VerifyOnly then
         DataCursor.DoLog('Invalid free BLOB block pointer in header')
      else
         begin
         DataCursor.DoLog('Invalid free BLOB block pointer in header, '+
                          'error fixed');
         FHeader.NextFreeBlock:=0;
         end;
      Result:=False;
      end;
   if (not VerifyOnly) then
      begin
      FHeader.VersionNum:=VERSION_NUMBER;
      FHeader.IsDirty:=True;
      end;
end;

function TBlobFile.GetNextFreeBlockNumber: Integer;
begin
   if (FHeader.NextFreeBlock <> 0) then
      Result:=FHeader.NextFreeBlock
   else
      Result:=FHeader.NextEndingBlock;
end;

procedure TBlobFile.SetNextFreeBlockNumber(Value: Integer);
begin
   if (Value <> FHeader.NextFreeBlock) then
      begin
      FHeader.NextFreeBlock:=Value;
      FHeader.IsDirty:=True;
      end;
end;

end.



